<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Script" referent="1">
      <Properties>
        <string name="Name">client</string>
        <token name="RunContext">2</token>
        <string name="Source">print("Hello world, from client!")</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">packages</string>
      </Properties>
      <Item class="Folder" referent="3">
        <Properties>
          <string name="Name">.pesde</string>
        </Properties>
        <Item class="Folder" referent="4">
          <Properties>
            <string name="Name">centau_vide@0.3.1</string>
          </Properties>
          <Item class="ModuleScript" referent="5">
            <Properties>
              <string name="Name">vide</string>
              <string name="Source"><![CDATA[--------------------------------------------------------------------------------
-- vide.luau
--------------------------------------------------------------------------------

local version = { major = 0, minor = 3, patch = 1 }

if not game then script = require "test/relative-string" end

local root = require(script.root)
local mount = require(script.mount)
local create = require(script.create)
local apply = require(script.apply)
local source = require(script.source)
local effect = require(script.effect)
local derive = require(script.derive)
local cleanup = require(script.cleanup)
local untrack = require(script.untrack)
local read = require(script.read)
local batch = require(script.batch)
local context = require(script.context)
local switch = require(script.switch)
local show = require(script.show)
local indexes, values = require(script.maps)()
local spring, update_springs = require(script.spring)()
local action = require(script.action)()
local changed = require(script.changed)
local throw = require(script.throw)
local flags = require(script.flags)

export type Source<T> = source.Source<T>
export type source<T> = Source<T>
export type Context<T> = context.Context<T>
export type context<T> = Context<T>

local function step(dt: number)
    if game then
        debug.profilebegin("VIDE STEP")
        debug.profilebegin("VIDE SPRING")
    end

    update_springs(dt)

    if game then
        debug.profileend()
        debug.profileend()
    end
end

local stepped = game and game:GetService("RunService").Heartbeat:Connect(function(dt: number)
    task.defer(step, dt)
end)

local vide = {
    version = version,

    -- core
    root = root,
    mount = mount,
    create = create,
    source = source,
    effect = effect,
    derive = derive,
    switch = switch,
    show = show,
    indexes = indexes,
    values = values,

    -- util
    cleanup = cleanup,
    untrack = untrack,
    read = read,
    batch = batch,
    context = context,

    -- animations
    spring = spring,

    -- actions
    action = action,
    changed = changed,

    -- flags
    strict = (nil :: any) :: boolean,

    -- temporary
    apply = function(instance: Instance)
        return function(props: { [any]: any })
            apply(instance, props)
            return instance
        end
    end,

    -- runtime
    step = function(dt: number)
        if stepped then
            stepped:Disconnect()
            stepped = nil
        end
        step(dt)
    end
}

setmetatable(vide :: any, {
    __index = function(_, index: unknown): ()
        if index == "strict" then
            return flags.strict
        else
            throw(`{tostring(index)} is not a valid member of vide`)
        end
    end,

    __newindex = function(_, index: unknown, value: unknown)
        if index == "strict" then
            flags.strict = value :: boolean
        else
            throw(`{tostring(index)} is not a valid member of vide`)
        end
    end
})

return vide
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="6">
              <Properties>
                <string name="Name">action</string>
                <string name="Source"><![CDATA[type Action = {
    priority: number,
    callback: (Instance) -> ()
}

local ActionMT = table.freeze {}

local function is_action(v: any)
    return getmetatable(v) == ActionMT
end

local function action(callback: (Instance) -> (), priority: number?): Action
    local a = {
        priority = priority or 1,
        callback = callback
    }

    setmetatable(a :: any, ActionMT)

    return table.freeze(a)
end

return function()
    return action, is_action
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="7">
              <Properties>
                <string name="Name">apply</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof :: never
local Vector2 = game and Vector2 or require "test/mock".Vector2 :: never
local UDim2 = game and UDim2 or require "test/mock".UDim2 :: never

local flags = require(script.Parent.flags)
local throw = require(script.Parent.throw)
local bind = require(script.Parent.bind)
local _, is_action = require(script.Parent.action)()
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>

type Array<V> = { V }
type ArrayOrV<V> = {ArrayOrV<V>} | V
type Map<K, V> = { [K]: V }

local free_caches: {
    -- event listeners to connect after properties are set
    events: Map<
        string, -- event name
        () -> () -- listener
    >,

    -- actions to run after events are connected
    actions: Map<
        number, -- priority
        Array<(Instance) -> ()> -- action callbacks
    >,

    -- cache to detect duplicate property setting at same nesting depth
    nested_debug: Map<
        number, -- depth
        Map<string, true> -- set of property names
    >,

    -- use stack instead of recursive function to process nesting layers one at time
    -- deeper-nested properties take precedence over shallower-nested ones
    -- each nested layer occupies two indexes: 1. table ref 2. nested depth
    -- e.g. { t1 = { t3 = {} }, t2 = {} } -> { t1, 1, t2, 1, t3, 2 }
    nested_stack: { {} | number }
}?

local function borrow_caches(): typeof(assert(free_caches))
    if free_caches then
        local caches = free_caches :: typeof(assert(free_caches))
        free_caches = nil
        return caches
    else
        return {
            events = {},
            actions = setmetatable({} :: any, { -- lazy init
                __index = function(self, i) self[i] = {}; return self[i] end
            }),
            nested_debug = setmetatable({} :: any, {
                __index = function(self, i: number) self[i] = {}; return self[i] end
            }),
            nested_stack = {}
        }
    end
end

local function return_caches(caches: typeof(free_caches) )
    free_caches = caches
end

-- map of datatype names to class default constructor for aggregate init
local aggregates = {}
for name, class in {
    CFrame = CFrame,
    Color3 = Color3,
    UDim = UDim,
    UDim2 = UDim2,
    Vector2 = Vector2,
    Vector3 = Vector3,
    Rect = Rect
} :: Map<string, { [string]: any }> do
    aggregates[name] = class.new
end

-- applies table of nested properties to an instance using full vide semantics
local function apply<T>(instance: T & Instance, properties: { [unknown]: unknown }): T
    if not properties then
        throw("attempt to call a constructor returned by create() with no properties")
    end

    local strict = flags.strict

    -- queue parent assignment if any for last
    local parent: unknown = properties.Parent 

    local caches = borrow_caches()
    local events = caches.events
    local actions = caches.actions
    local nested_debug = caches.nested_debug
    local nested_stack = caches.nested_stack

    -- process all properties
    local depth = 1
    repeat
        for property, value in properties do
            if property == "Parent" then continue end

            if type(property) == "string" then
                if strict then -- check for duplicate prop assignment at nesting depth
                    if nested_debug[depth][property] then
                        throw(`duplicate property {property} at depth {depth}`)
                    end
                    nested_debug[depth][property] = true
                end

                if type(value) == "table" then -- attempt aggregate init
                    local ctor = aggregates[typeof((instance :: any)[property])]
                    if ctor == nil then
                        throw(`cannot aggregate type {typeof(value)} for property {property}`)
                    end
                    (instance :: any)[property] = ctor(unpack(value :: {}))
                elseif type(value) == "function" then 
                    if typeof((instance :: any)[property]) == "RBXScriptSignal" then
                        events[property] = value  :: () -> () -- add event to buffer
                    else
                        bind.property(instance, property, value :: () -> ()) -- bind property
                    end
                else
                    (instance :: any)[property] = value -- set property
                end    
            elseif type(property) == "number" then
                if type(value) == "function" then
                    bind.children(instance, value :: () -> ArrayOrV<Instance>) -- bind children
                elseif type(value) == "table" then
                    if is_action(value) then
                        table.insert(actions[(value :: any).priority], (value :: any).callback :: () -> ()) -- add action to buffer
                    else
                        table.insert(nested_stack, value :: {})
                        table.insert(nested_stack, depth + 1) -- push table to stack for later processing
                    end
                else
                    (value :: Instance).Parent = instance -- parent child
                end
            end
        end

        depth = table.remove(nested_stack) :: number
        properties = table.remove(nested_stack) :: {}

    until not properties

    for event, listener in next, events do
        (instance :: any)[event]:Connect(listener)   
    end

    for _, queued in next, actions do
        for _, callback in next, queued do
            callback(instance)
        end
    end

    -- finally set parent if any
    if parent then
        if type(parent) == "function" then
            bind.parent(instance, parent :: () -> Instance)
        else
            instance.Parent = parent :: Instance
        end
    end

    -- clear caches
    table.clear(events)
    for _, queued in next, actions do table.clear(queued) end
    if strict then table.clear(nested_debug) end
    table.clear(nested_stack)

    return_caches(caches)

    return instance
end

return apply
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="8">
              <Properties>
                <string name="Name">batch</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local flags = require(script.Parent.flags)
local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)

local function batch(setter: () -> ())
    local already_batching = flags.batch
    local from

    if not already_batching then
        flags.batch = true
        from = graph.get_update_queue_length()
    end

    local ok, err: string? = pcall(setter)

    if not already_batching then
        flags.batch = false
        graph.flush_update_queue(from)
    end

    if not ok then throw(`error occured while batching updates: {err}`) end
end

return batch
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="9">
              <Properties>
                <string name="Name">bind</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

function create_implicit_effect<T>(updater: (T) -> T, binding: T)
    evaluate_node(create_node(assert_stable_scope(), updater, binding))
end

type PropertyBinding = {
    instance: Instance,
    property: string,
    source: () -> unknown
}

local function update_property_effect(p: PropertyBinding)
    (p.instance :: any)[p.property] = p.source()
    return p
end

type ParentBinding = {
    instance: Instance,
    parent: () -> Instance
}

local function update_parent_effect(p: ParentBinding)
    p.instance.Parent = p.parent()
    return p
end

type ChildrenBinding = {
    instance: Instance,
    cur_children_set: { [Instance]: true },
    new_children_set: { [Instance]: true },
    children: () -> Instance | { Instance }
}

type ArrayOrV<V> = V | { V }
local function update_children_effect(p: ChildrenBinding)
    local cur_children_set: { [Instance]: true } = p.cur_children_set -- cache of all children parented before update
    local new_child_set: { [Instance]: true } = p.new_children_set -- cache of all children parented after update

    local new_children = p.children() -- all (and only) children that should be parented after this update
    
    if type(new_children) ~= "table" then
        new_children = { new_children }
    end

    local function process_child(child: ArrayOrV<Instance>)
        if type(child) == "table" then
            for _, child in next, child do
                process_child(child)
            end
        else
            if new_child_set[child] then return end -- stops redundant reparenting

            new_child_set[child] = true -- record child set from this update
            if not cur_children_set[child] then
                child.Parent = p.instance -- if child wasn't already parented then parent it
            else 
                cur_children_set[child] = nil -- remove child from cache if it was already in cache
            end
        end
    end

    process_child(new_children)

    for child in next, cur_children_set do
        child.Parent = nil -- unparent all children that weren't in the new children set
    end

    table.clear(cur_children_set) -- clear cache, preserve capacity
    p.cur_children_set, p.new_children_set = new_child_set, cur_children_set

    return p
end

return {
    property = function(instance, property, source)
        return create_implicit_effect(update_property_effect, {
            instance = instance,
            property = property,
            source = source
        })
    end,

    parent = function(instance, parent)
        return create_implicit_effect(update_parent_effect, {
            instance = instance,
            parent = parent
        })
    end,

    children = function(instance, children)
        return create_implicit_effect(update_children_effect, {
            instance = instance,
            cur_children_set = {},
            new_children_set = {},
            children = children
        })
    end
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="10">
              <Properties>
                <string name="Name">changed</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local action = require(script.Parent.action)()
local cleanup = require(script.Parent.cleanup)

local function changed<T>(property: string, callback: (T) -> ())
    return action(function(instance)
        local con = instance:GetPropertyChangedSignal(property):Connect(function()
            callback((instance :: any)[property])
        end)

        cleanup(function()
            con:Disconnect()
        end)

        callback((instance :: any)[property])
    end)
end

return changed
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="11">
              <Properties>
                <string name="Name">cleanup</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof :: never

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
local get_scope = graph.get_scope
local push_cleanup = graph.push_cleanup

local function helper(obj: any)
    return
        if typeof(obj) == "RBXScriptConnection" then function() obj:Disconnect() end
        elseif typeof(obj) == "Instance" then function() obj:Destroy() end
        elseif obj.destroy then function() obj:destroy() end
        elseif obj.disconnect then function() obj:disconnect() end
        elseif obj.Destroy then function() obj:Destroy() end
        elseif obj.Disconnect then function() obj:Disconnect() end
        else throw("cannot cleanup given object")
end

local function cleanup(value: unknown)
    local scope = get_scope()

    if not scope then
        throw "cannot cleanup outside a stable or reactive scope"
    end; assert(scope)

    if type(value) == "function" then
        push_cleanup(scope, value :: () -> ())
    else
        push_cleanup(scope, helper(value))
    end
end

type Destroyable = { destroy: (any) -> () } | { Destroy: (any) -> () }
type Disconnectable = { disconnect: (any) -> () } | { Disconnect: (any) -> () }

return cleanup ::
    ( (callback: () -> ()) -> () ) &
    ( (instance: Destroyable) -> () ) &
    ( (connection: Disconnectable) -> () ) &
    ( (instance: Instance) -> () ) &
    ( (connection: RBXScriptConnection) -> () )

]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="12">
              <Properties>
                <string name="Name">context</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local get_scope = graph.get_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local set_context = graph.set_context

export type Context<T> = (() -> T) & (<U>(T, () -> U) -> U)

local nil_symbol = newproxy()
local count = 0

local function context<T>(...: T): Context<T>
    count += 1
    local id = count

    local has_default = select("#", ...) > 0
    local default_value = ...

    return function<T>(...): any -- todo: fix type error
        local scope: Node<unknown>? | false = get_scope()

        if select("#", ...) == 0 then -- get
            while scope do
                local ctx = scope.context
    
                if not ctx then
                    scope = scope.owner
                    continue
                end

                local value = (ctx :: { unknown })[id]

                if value == nil then
                    scope = scope.owner
                    continue
                end
                
                return (if value ~= nil_symbol then value else nil) :: T
            end

            if has_default ~= nil then
                return default_value
            else
                throw("attempt to get context when no context is set and no default context is set")
            end
        else -- set
            if not scope then return throw("attempt to set context outside of a vide scope") end

            local value, component = ...
            
            local new_scope = create_node(scope, false, false)
            set_context(new_scope, id, if value == nil then nil_symbol else value)

            push_scope(new_scope)

            local function efn(err: string) return debug.traceback(err, 3) end
            local ok, result = xpcall(component, efn)

            pop_scope()

            if not ok then
                throw(`error while running context:\n\n{result}`)
            end

            return result
        end

        return nil :: any
    end
end

return context
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="13">
              <Properties>
                <string name="Name">create</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof:: never
local Instance = game and Instance or require "test/mock".Instance :: never

local throw = require(script.Parent.throw)
local defaults = require(script.Parent.defaults)
local apply = require(script.Parent.apply)

local ctor_cache = {} :: { [string]: () -> Instance }

setmetatable(ctor_cache :: any, {
    __index = function(self, class)
        local ok, instance: Instance = pcall(Instance.new, class :: any)
        if not ok then throw(`invalid class name, could not create instance of class { class }`) end

        local default: { [string]: unknown }? = defaults[class]
        if default then
            for i, v in next, default do
                (instance :: any)[i] = v
            end
        end

        local function ctor(properties: Props): Instance
            return apply(instance:Clone(), properties)    
        end  

        self[class] = ctor
        return ctor
    end
})

local function create_instance(class: string)
    return ctor_cache[class]
end

local function clone_instance(instance: Instance)
    return function(properties: Props): Instance
        local clone = instance:Clone()
        if not clone then throw "attempt to clone a non-archivable instance" end
        return apply(clone, properties)
    end
end

local function create(class_or_instance: string|Instance): (Props) -> Instance
    if type(class_or_instance) == "string" then
        return create_instance(class_or_instance)
    elseif typeof(class_or_instance) == "Instance" then
        return clone_instance(class_or_instance)
    else
        throw("bad argument #1, expected string or instance, got " .. typeof(class_or_instance))
        return nil :: never
    end
end

type Props = { [any]: any }
return (create :: any) :: 
( <T>(T & Instance) -> (Props) -> T ) &
( ("Folder") -> (Props) -> Folder ) &
( ("BillboardGui") -> (Props) -> BillboardGui ) &
( ("CanvasGroup") -> (Props) -> CanvasGroup ) &
( ("Frame") -> (Props) -> Frame ) &
( ("ImageButton") -> (Props) -> ImageButton ) &
( ("ImageLabel") -> (Props) -> ImageLabel ) &
( ("ScreenGui") -> (Props) -> ScreenGui ) &
( ("ScrollingFrame") -> (Props) -> ScrollingFrame ) &
( ("SurfaceGui") -> (Props) -> SurfaceGui ) &
( ("TextBox") -> (Props) -> TextBox ) &
( ("TextButton") -> (Props) -> TextButton ) &
( ("TextLabel") -> (Props) -> TextLabel ) &
( ("UIAspectRatioConstraint") -> (Props) -> UIAspectRatioConstraint ) &
( ("UICorner") -> (Props) -> UICorner ) &
( ("UIGradient") -> (Props) -> UIGradient ) &
( ("UIGridLayout") -> (Props) -> UIGridLayout ) &
( ("UIListLayout") -> (Props) -> UIListLayout ) &
( ("UIPadding") -> (Props) -> UIPadding ) &
( ("UIPageLayout") -> (Props) -> UIPageLayout ) &
( ("UIScale") -> (Props) -> UIScale ) &
( ("UISizeConstraint") -> (Props) -> UISizeConstraint ) &
( ("UIStroke") -> (Props) -> UIStroke ) &
( ("UITableLayout") -> (Props) -> UITableLayout ) &
( ("UITextSizeConstraint") -> (Props) -> UITextSizeConstraint ) &
( ("VideoFrame") -> (Props) -> VideoFrame ) &
( ("ViewportFrame") -> (Props) -> ViewportFrame ) &
( (string) -> (Props) -> Instance )
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="14">
              <Properties>
                <string name="Name">defaults</string>
                <string name="Source"><![CDATA[local Enum = game and Enum or require "test/mock".Enum :: never
local Color3 = game and Color3 or require "test/mock".Color3 :: never
local Vector3 = game and Vector3 or require "test/mock".Vector3 :: never

return {
    Part = {
        Material = Enum.Material.SmoothPlastic,
        Size = Vector3.new(1, 1, 1),
        Anchored = true
    },

    BillboardGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    },

    CanvasGroup = nil,

    Frame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    },

    ImageButton = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        AutoButtonColor = false
    },

    ImageLabel = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
    },

    ScreenGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    },

    ScrollingFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        ScrollBarImageColor3 = Color3.new(0, 0, 0)
    },
    
    SurfaceGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

        PixelsPerStud = 50,
        SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
    },
    
    TextBox = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        ClearTextOnFocus = false,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },

    TextButton = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        AutoButtonColor = false,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },
    
    TextLabel = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },
    
    UIListLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },
   
    UIGridLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },

    UITableLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },

    UIPageLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },
    
    VideoFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    },
    
    ViewportFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    }
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="15">
              <Properties>
                <string name="Name">derive</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
local create_node = graph.create_node
local push_child_to_scope = graph.push_child_to_scope
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

local function derive<T>(source: () -> T): () -> T
    local node = create_node(assert_stable_scope(), source, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

return derive
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="16">
              <Properties>
                <string name="Name">effect</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
local create_node = graph.create_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

local function effect<T>(callback: (T) -> T, initial_value: T)
    local node = create_node(assert_stable_scope(), callback, initial_value)

    evaluate_node(node)
end

return effect :: (<T>(callback: (T) -> T, initial_value: T) -> ()) & ((callback: () -> ()) -> ())
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="17">
              <Properties>
                <string name="Name">flags</string>
                <string name="Source"><![CDATA[local function inline_test(): string
    return debug.info(1, "n")
end

local is_O2 = inline_test() ~= "inline_test"

return { strict = not is_O2, batch = false }
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="18">
              <Properties>
                <string name="Name">graph</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local flags = require(script.Parent.flags)

export type SourceNode<T> = {
    cache: T,
    [number]: Node<T>
}

export type Node<T> =  {
    cache: T,
    effect:  ((T) -> T) | false,
    cleanups: { () -> () } | false,

    context: { [number]: unknown } | false,

    owned: { Node<T> } | false,
    owner: Node<T> | false,

    parents: { SourceNode<T> },
    [number]: Node<T> -- children
}

local scopes = { n = 0 } :: { [number]: Node<any>, n: number } -- scopes stack

local function ycall<T, U>(fn: (T) -> U, arg: T): (boolean, string|U)
    local thread = coroutine.create(xpcall)
    local function efn(err: string) return debug.traceback(err, 3) end
    local resume_ok, run_ok, result = coroutine.resume(thread, fn, efn, arg)

    assert(resume_ok)
        
    if coroutine.status(thread) ~= "dead" then
        return false, debug.traceback(thread, "attempt to yield in reactive scope")
    end

    return run_ok, result
end

local function get_scope(): Node<unknown>?
    return scopes[scopes.n]
end

local function assert_stable_scope(): Node<unknown>
    local scope = get_scope()

    if not scope then
        local caller_name = debug.info(2, "n")
        return throw(`cannot use {caller_name}() outside a stable or reactive scope`)
    elseif scope.effect then
        throw("cannot create a new reactive scope inside another reactive scope")
    end

    return scope
end

local function push_child<T>(parent: SourceNode<any>, child: Node<any>)
    table.insert(parent, child)
    table.insert(child.parents, parent)
end

local function push_scope<T>(node: Node<T>)
    local n = scopes.n + 1
    scopes.n = n
    scopes[n] = node
end

local function pop_scope()
    local n = scopes.n
    scopes.n = n - 1
    scopes[n] = nil
end

local function push_cleanup<T>(node: Node<T>, cleanup: () -> ())
    if node.cleanups then
        table.insert(node.cleanups, cleanup)
    else
        node.cleanups = { cleanup }
    end
end

local function flush_cleanups<T>(node: Node<T>)
    if node.cleanups then
        for _, fn in next, node.cleanups do
            local ok, err: string? = pcall(fn)
            if not ok then throw(`cleanup error: {err}`) end
        end

        table.clear(node.cleanups)
    end
end

local function find_and_swap_pop<T>(t: { T }, v: T)
    local i = table.find(t, v) :: number
    local n = #t
    t[i] = t[n]
    t[n] = nil
end

local function unparent<T>(node: Node<T>)
    local parents = node.parents

    for i, parent in parents do
        find_and_swap_pop(parent, node)
        parents[i] = nil
    end
end

local function destroy<T>(node: Node<T>)
    flush_cleanups(node)
    unparent(node)
    
    if node.owner then
        find_and_swap_pop(node.owner.owned :: { Node<T> }, node)
        node.owner = false
    end

    if node.owned then
        local owned = node.owned
        while owned[1] do destroy(owned[1]) end
    end
end

local function destroy_owned<T>(node: Node<T>)
    if node.owned then
        local owned = node.owned
        while owned[1] do destroy(owned[1]) end
    end
end

local update_queue = { n = 0 } :: { n: number, [number]: Node<any> }

local function evaluate_node<T>(node: Node<T>)
    if flags.strict then
        local initial_value = node.cache

        for i = 1, 2 do
            local cur_value = node.cache

            flush_cleanups(node)
            destroy_owned(node)
    
            push_scope(node)
            local ok, new_value = ycall(node.effect :: (T) -> T, cur_value)
            pop_scope()
            
            if not ok then
                table.clear(update_queue)
                update_queue.n = 0
                throw(`effect stacktrace:\n{new_value :: string}`)
            end

            node.cache = new_value :: T
        end

        return initial_value ~= node.cache
    else
        local cur_value = node.cache

        flush_cleanups(node)
        destroy_owned(node)

        push_scope(node)
        local ok, new_value = pcall(node.effect :: (T) -> T, node.cache)
        pop_scope()

        if not ok then
            table.clear(update_queue)
            update_queue.n = 0
            throw(`effect stacktrace:\n{new_value}\n`)
        end
    
        node.cache = new_value
        return cur_value ~= new_value
    end
end

local function queue_children_for_update<T>(node: SourceNode<T>)
    local i = update_queue.n
    while node[1] do
        i += 1
        update_queue[i] = node[1]
        unparent(node[1])
    end
    update_queue.n = i
end

local function get_update_queue_length()
    return update_queue.n
end

local function flush_update_queue(from: number)
    local i = from + 1
    while i <= update_queue.n do
        local node = update_queue[i]
        --assert(node.effect)

        if node.owner and evaluate_node(node) then
            queue_children_for_update(node)
        end

        update_queue[i] = false :: any
        i += 1
    end
    
    update_queue.n = from
end

local function update_descendants<T>(root: SourceNode<T>)
    local n0 = update_queue.n
    queue_children_for_update(root)

    if flags.batch then return end

    local i = n0 + 1
    while i <= update_queue.n do
        local node = update_queue[i]
        --assert(node.effect)

        -- check if node is still owned in case destroyed after queued
        if node.owner and evaluate_node(node) then
            queue_children_for_update(node)
        end

        update_queue[i] = false :: any -- false instead of nil to avoid sparse
        i += 1
    end

    update_queue.n = n0
end

local function push_child_to_scope<T>(node: SourceNode<T>)
    local scope = get_scope()
    if scope and scope.effect then -- do not track nodes with no effect
        push_child(node, scope)
    end
end

local function create_node<T>(owner: false | Node<any>, effect: false | (T) -> T, value: T): Node<T>
    local node: Node<T> = {
        cache = value,
        effect = effect,
        cleanups = false,

        context = false,

        owner = owner,
        owned = false,

        parents = {},
    }

    if owner then
        if owner.owned then
            table.insert(owner.owned, node)
        else
            owner.owned = { node }
        end
    end

    return node
end

local function create_source_node<T>(value: T): SourceNode<T>
    return { cache = value }
end

local function get_children<T>(node: Node<T>): { Node<unknown> }
    return { unpack(node) } :: { Node<any> }
end

local function set_context<T>(node: Node<T>, key: number, value: unknown)
    if node.context then
        node.context[key] = value
    else
        node.context = { [key] = value }
    end
end

return table.freeze {
    push_scope = push_scope,
    pop_scope = pop_scope,
    evaluate_node = evaluate_node,
    get_scope = get_scope,
    assert_stable_scope = assert_stable_scope,
    push_cleanup = push_cleanup,
    destroy = destroy,
    flush_cleanups = flush_cleanups,
    push_child_to_scope = push_child_to_scope,
    update_descendants = update_descendants,
    push_child = push_child,
    create_node = create_node,
    create_source_node = create_source_node,
    get_children = get_children,
    flush_update_queue = flush_update_queue,
    get_update_queue_length = get_update_queue_length,
    set_context = set_context,
    scopes = scopes
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="19">
              <Properties>
                <string name="Name">maps</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local flags = require(script.Parent.flags)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local create_source_node = graph.create_source_node
local push_child_to_scope = graph.push_child_to_scope
local update_descendants = graph.update_descendants
local assert_stable_scope = graph.assert_stable_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local evaluate_node = graph.evaluate_node
local destroy = graph.destroy

type Map<K, V> = { [K]: V }

local function check_primitives(t: {})
    if not flags.strict then return end

    for _, v in next, t do
        if type(v) == "table" or type(v) == "userdata" or type(v) == "function" then continue end
        throw("table source map cannot return primitives")
    end
end

local function indexes<K, VI, VO>(input: () -> Map<K, VI>, transform: (() -> VI, K) -> VO): () -> { VO }
    local owner = assert_stable_scope()
    local subowner = create_node(owner, false, false)

    local input_cache = {} :: Map<K, VI>
    local output_cache = {} :: Map<K, VO>
    local input_nodes = {} :: Map<K, SourceNode<VI>>
    local remove_queue = {} :: { K }
    local scopes = {} :: Map<K, Node<unknown>>

    local function update_children(data)
        -- queue removed values
        for i in next, input_cache do
            if data[i] == nil then
                table.insert(remove_queue, i)
            end
        end

        -- remove queued values
        for _, i in next, remove_queue do
            destroy(scopes[i])

            input_cache[i] = nil
            output_cache[i] = nil
            input_nodes[i] = nil
            scopes[i] = nil
        end

        table.clear(remove_queue)

        push_scope(subowner)

        -- process new or changed values
        for i, v in next, data do
            local cv = input_cache[i]

            if cv ~= v then
                if cv == nil then -- create new scope and run transform
                    local scope = create_node(subowner, false, false)
                    scopes[i] = scope :: Node<any>

                    local node = create_source_node(v)

                    push_scope(scope)

                    local ok, result = pcall(transform, function()
                        push_child_to_scope(node)
                        return node.cache
                    end, i)
                    
                    pop_scope()

                    if not ok then
                        pop_scope() -- subowner scope
                        error(result, 0)
                    end
                    
                    input_nodes[i] = node
                    output_cache[i] = result
                else -- update source
                    input_nodes[i].cache = v
                    update_descendants(input_nodes[i])
                end

                input_cache[i] = v
            end
        end

        pop_scope()

        local output_array = table.create(#scopes)
        for _, v in next, output_cache do
            table.insert(output_array, v)
        end
        check_primitives(output_array)
        
        return output_array
    end

    local node = create_node(owner, function()
        return update_children(input())
    end, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

local function values<K, VI, VO>(input: () -> Map<K, VI>, transform: (VI, () -> K) -> VO): () -> { VO }
    local owner  = assert_stable_scope()
    local subowner = create_node(owner, false, false)
    
    local cur_input_cache_up = {} :: Map<VI, K>
    local new_input_cache_up = {} :: Map<VI, K>
    local output_cache = {} :: Map<VI, VO>
    local input_nodes = {} :: Map<VI, SourceNode<K>>
    local scopes = {} :: Map<VI, Node<unknown>>

    local function update_children(data: Map<K, VI>)
        local cur_input_cache, new_input_cache = cur_input_cache_up, new_input_cache_up

        if flags.strict then
            local cache = {}
            for _, v in next, data do
                if cache[v] ~= nil then
                    throw "duplicate table value detected"
                end
                cache[v] = true
            end
        end

        push_scope(subowner)
    
        -- process data
        for i, v in next, data do
            new_input_cache[v] = i

            local cv = cur_input_cache[v]
            
            if cv == nil then -- create new scope and run transform
                local scope = create_node(subowner, false, false)
                scopes[v] = scope :: Node<any>

                local node = create_source_node(i)
    
                push_scope(scope)
                
                local ok, result = pcall(transform, v, function()
                    push_child_to_scope(node)
                    return node.cache
                end)
                
                pop_scope()

                if not ok then
                    pop_scope() -- subowner scope
                    error(result, 0)
                end

                input_nodes[v] = node
                output_cache[v] = result
            else -- update source
                if cv ~= i then
                    input_nodes[v].cache = i
                    update_descendants(input_nodes[v])
                end

                cur_input_cache[v] = nil
            end
        end

        pop_scope()

        -- remove old values
        for v in next, cur_input_cache do
            destroy(scopes[v])

            output_cache[v] = nil
            input_nodes[v] = nil
            scopes[v] = nil
        end

        -- update buffer cache
        table.clear(cur_input_cache)
        cur_input_cache_up, new_input_cache_up = new_input_cache, cur_input_cache

        local output_array = table.create(#scopes)
        for _, v in next, output_cache do
            table.insert(output_array, v)
        end
        check_primitives(output_array)

        return output_array
    end

    local node = create_node(owner, function()
        return update_children(input())
    end, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

return function() return indexes, values end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="20">
              <Properties>
                <string name="Name">mount</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local root = require(script.Parent.root)
local apply = require(script.Parent.apply)

local function mount<T>(component: () -> T, target: Instance?): () -> ()
    return root(function()
        local result = component()
        if target then apply(target, { result }) end
    end)
end

return mount :: (<T>(component: () -> T, target: Instance) -> () -> ()) & ((component: () -> ()) -> () -> ())
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="21">
              <Properties>
                <string name="Name">read</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local function read<T>(value: T | () -> T): T
    return if type(value) == "function" then value() else value
end

return read
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="22">
              <Properties>
                <string name="Name">root</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local destroy = graph.destroy

local refs = {}

local function root<T...>(fn: (destroy: () -> ()) -> T...): (() -> (), T...)
    local node = create_node(false, false, false)

    refs[node] = true -- prevent gc of root node

    local destroy = function()
        if not refs[node] then throw "root already destroyed" end
        refs[node] = nil
        destroy(node)
    end

    push_scope(node)

    local function efn(err: string) return debug.traceback(err, 3) end
    local result = { xpcall(fn, efn, destroy) }

    pop_scope()

    if not result[1] then
        destroy()
        throw(`error while running root():\n\n{result[2]}`)
    end

    return destroy, unpack(result :: any, 2)
end

return root :: <T...>(fn: (destroy: () -> ()) -> T...) -> (() -> (), T...)
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="23">
              <Properties>
                <string name="Name">show</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local switch = require(script.Parent.switch)

local function show<T>(source: () -> any, component: () -> T, fallback: (() -> T)?): () -> T?
    local function truthy()
        return not not source()
    end

    return switch(truthy) {
        [true] = component,
        [false] = fallback,
    }
end

return show ::
    (<T>(source: () -> any, component: () -> T) -> () -> T?) &
    (<T, U>(source: () -> any, component: () -> T, fallback: () -> U) -> () -> (T | U)?)
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="24">
              <Properties>
                <string name="Name">source</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_source_node = graph.create_source_node
local push_child_to_scope = graph.push_child_to_scope
local update_descendants = graph.update_descendants

export type Source<T> = (() -> T) & ((value: T) -> T)

local function source<T>(initial_value: T): Source<T>
    local node = create_source_node(initial_value)

    return function(...): T
        if select("#", ...) == 0 then -- no args were given
            push_child_to_scope(node)
            return node.cache
        end

        local v = ... :: T
        if node.cache == v and (type(v) ~= "table" or table.isfrozen(v)) then 
            return v
        end

        node.cache = v
        update_descendants(node)
        return v
    end
end

return source :: (<T>(initial_value: T) -> Source<T>) & (<T>() -> Source<T>)
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="25">
              <Properties>
                <string name="Name">spring</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local Vector3 = game and Vector3 or require "test/mock".Vector3 :: never

--[[

Supported datatypes:
- number
- CFrame
- Color3
- UDim
- UDim2
- Vector2
- Vector3
- Rect

Unsupported datatypes:
- bool
- Vector2int16
- Vector3int16
- EnumItem

]]

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local create_source_node = graph.create_source_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node
local update_descendants = graph.update_descendants
local push_child_to_scope = graph.push_child_to_scope

local UPDATE_RATE = 120
local TOLERANCE = 0.0001

type Vec3 = Vector3

local function Vec3(x: number?, y: number?, z: number?)
    return Vector3.new(x, y, z)
end

local ZERO = Vec3(0, 0, 0)

type Animatable = number | CFrame | Color3 | UDim | UDim2 | Vector2 | Vector3

type SpringData<T> = {
    k: number, -- spring constant
    c: number, -- damping coeff

    -- dimensions 1-3
    x0_123: Vec3,
    x1_123: Vec3,
    v_123: Vec3,

    -- dimensions 4-6
    x0_456: Vec3,
    x1_456: Vec3,
    v_456: Vec3,

    source_value: T -- current value of spring input source
}

type TypeToVec6<T> = (T) -> (Vec3, Vec3)
type Vec6ToType<T> = (Vec3, Vec3) -> T

local type_to_vec6 = {
    number = function(v)
        return Vec3(v, 0, 0), ZERO
    end :: TypeToVec6<number>,

    CFrame = function(v)
        return v.Position, Vec3(v:ToEulerAnglesXYZ())
    end :: TypeToVec6<CFrame>,

    Color3 = function(v)
        -- todo: hsv, oklab?
        return Vec3(v.R, v.G, v.B), ZERO
    end :: TypeToVec6<Color3>,

    UDim = function(v)
        return Vec3(v.Scale, v.Offset, 0), ZERO
    end :: TypeToVec6<UDim>,
    
    UDim2 = function(v)
        return Vec3(v.X.Scale, v.X.Offset, v.Y.Scale), Vec3(v.Y.Offset, 0, 0)
    end :: TypeToVec6<UDim2>,

    Vector2 = function(v)
        return Vec3(v.X, v.Y, 0), ZERO
    end :: TypeToVec6<Vector2>,

    Vector3 = function(v)
        return v, ZERO
    end :: TypeToVec6<Vector3>,

    Rect = function(v)
        return Vec3(v.Min.X, v.Min.Y, v.Max.X), Vec3(v.Max.Y, 0, 0)
    end :: TypeToVec6<Rect>
}

local vec6_to_type = {
    number = function(a, b)
        return a.X
    end :: Vec6ToType<number>,

    CFrame = function(a, b)
        return CFrame.new(a) * CFrame.fromEulerAnglesXYZ(b.X, b.Y, b.Z)
    end :: Vec6ToType<CFrame>,

    Color3 = function(v)
        return Color3.new(math.clamp(v.X, 0, 1), math.clamp(v.Y, 0, 1), math.clamp(v.Z, 0, 1))
    end :: Vec6ToType<Color3>,

    UDim = function(v)
        return UDim.new(v.X, math.round(v.Y))
    end :: Vec6ToType<UDim>,
    
    UDim2 = function(a, b)
        return UDim2.new(a.X, math.round(a.Y), a.Z, math.round(b.X))
    end :: Vec6ToType<UDim2>,

    Vector2 = function(v)
        return Vector2.new(v.X, v.Y)
    end :: Vec6ToType<Vector2>,

    Vector3 = function(v)
        return v
    end :: Vec6ToType<Vector3>,

    Rect = function(a, b)
        return Rect.new(a.X, a.Y, a.Z, b.X)
    end :: Vec6ToType<Rect>
}

local invalid_type = {
    __index = function(_, t: string)
        throw(`cannot spring type {t}`)
    end
}

setmetatable(type_to_vec6, invalid_type)
setmetatable(vec6_to_type, invalid_type)

-- maps spring data to its corresponding output node
-- lifetime of spring data is tied to output node
local springs: { [SpringData<any>]: SourceNode<any> } = {}
setmetatable(springs, { __mode = "v" })

local function spring<T>(source: () -> T, period: number?, damping_ratio: number?): () -> T
    local owner = assert_stable_scope()

    -- https://en.wikipedia.org/wiki/Damping

    local w_n = 2*math.pi / (period or 1)
    local z = damping_ratio or 1

    local k = w_n^2
    local c_c = 2*w_n
    local c = z * c_c

    -- todo: is there a solution other than reducing step size?
    -- todo: this does not catch all solver exploding cases
    if c > UPDATE_RATE*2 then -- solver will explode if this is true
        throw("spring damping too high, consider reducing damping or increasing period")
    end

    local data: SpringData<T> = {
        k = k,
        c = c,

        x0_123 = ZERO,
        x1_123 = ZERO,
        v_123 = ZERO,

        x0_456 = ZERO,
        x1_456 = ZERO,
        v_456 = ZERO,

        source_value = false :: any,
    }
    
    local output = create_source_node(false :: any)

    local function updater_effect()
        local value = source()
        data.x1_123, data.x1_456 = type_to_vec6[typeof(value)](value)
        data.source_value = value
        springs[data] = output -- todo: investigate why insertion is not O(1) at ~20k springs
        return value
    end

    local updater = create_node(owner, updater_effect, false :: any)

    evaluate_node(updater)

    -- set initial position to goal
    data.x0_123, data.x0_456 = data.x1_123, data.x1_456

    -- set output to goal
    output.cache = data.source_value

    return function(...)
        if select("#", ...) == 0 then -- no args were given
            push_child_to_scope(output)
            return output.cache
        end

        -- set current position to value
        local v = ... :: T
        data.x0_123, data.x0_456 = type_to_vec6[typeof(v)](v)

        -- reset velocity
        data.v_123 = ZERO
        data.v_456 = ZERO

        -- schedule spring
        springs[data] = output

        -- set output to value
        output.cache = v

        return v
    end
end

local function step_springs(dt: number)
    for data in next, springs do
        local k, c,
        x0_123, x1_123, u_123,
        x0_456, x1_456, u_456 =
            data.k, data.c,
            data.x0_123, data.x1_123, data.v_123,
            data.x0_456, data.x1_456, data.v_456

        -- calculate displacement from target
        local dx_123 = x0_123 - x1_123
        local dx_456 = x0_456 - x1_456

        -- calculate spring force
        local fs_123 = dx_123*-k
        local fs_456 = dx_456*-k

        -- calculate friction force
        local ff_123 = u_123*-c
        local ff_456 = u_456*-c

        -- calculate acceleration step
        local dv_123 = (fs_123 + ff_123)*dt
        local dv_456 = (fs_456 + ff_456)*dt

        -- apply acceleration step
        local v_123 = u_123 + dv_123
        local v_456 = u_456 + dv_456

        -- calculate new position
        local x_123 = x0_123 + v_123*dt
        local x_456 = x0_456 + v_456*dt

        data.x0_123, data.x0_456 = x_123, x_456
        data.v_123, data.v_456 = v_123, v_456
    end
end

local remove_queue = {}

local function update_spring_sources()
    for data, output in next, springs do
        local x0_123, x1_123, v_123,
        x0_456, x1_456, v_456 =
            data.x0_123, data.x1_123, data.v_123,
            data.x0_456, data.x1_456, data.v_456
    
        local dx_123, dx_456 =
            x0_123 - x1_123,
            x0_456 - x1_456

        -- todo: can this false positive?
        if (v_123 + v_456 + dx_123 + dx_456).Magnitude < TOLERANCE then
            -- close enough to target, unshedule spring and set value to target
            table.insert(remove_queue, data)
            output.cache = data.source_value
        else
            output.cache = vec6_to_type[typeof(data.source_value)](x0_123, x0_456)
        end

        update_descendants(output)
    end

    for _, data in next, remove_queue do
        springs[data] = nil
    end

    table.clear(remove_queue)
end

return function()
    local time_elapsed = 0

    return spring, function(dt: number)
        time_elapsed += dt

        while time_elapsed > 1 / UPDATE_RATE do
            time_elapsed -= 1 / UPDATE_RATE
            step_springs(1 / UPDATE_RATE)
        end

        update_spring_sources()
    end
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="26">
              <Properties>
                <string name="Name">switch</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local evaluate_node = graph.evaluate_node
local push_child_to_scope = graph.push_child_to_scope
local destroy = graph.destroy
local assert_stable_scope = graph.assert_stable_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope

type Map<K, V> = { [K]: V }

local function switch<T, U>(source: () -> T): (map: Map<T, ((() -> U)?)>) -> () -> U?
    local owner = assert_stable_scope()

    return function(map)
        local last_scope: Node<false>?
        local last_component: (() -> U)?

        local function update(cached): U?
            local component = map[source()]
            if component == last_component then return cached end
            last_component = component

            if last_scope then
                destroy(last_scope :: Node<any>)
                last_scope = nil
            end

            if component == nil then return nil end

            if type(component) ~= "function" then
                throw "map must map a value to a function"
            end

            local new_scope = create_node(owner, false, false)
            last_scope = new_scope :: Node<any>
            
            push_scope(new_scope)
        
            local ok, result = pcall(component)

            pop_scope()

            if not ok then error(result, 0) end

            return result
        end

        local node = create_node(owner, update, nil)

        evaluate_node(node)

        return function()
            push_child_to_scope(node)
            return node.cache
        end
    end
end

return switch
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="27">
              <Properties>
                <string name="Name">throw</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local function VIDE_ASSERT(msg): any
    error(msg, 0)
end

return VIDE_ASSERT
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="28">
              <Properties>
                <string name="Name">untrack</string>
                <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local get_scope = graph.get_scope

local function untrack<T>(source: () -> T): T
    local scope = get_scope()
    
    if scope then
        -- sources are only tracked if the node in scope has an effect
        local effect = scope.effect
        scope.effect = false

        local ok, result = pcall(source)

        scope.effect = effect :: () -> ()

        if not ok then error(result, 0) end

        return result
    else
        return source()
    end
end

return untrack
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="29">
          <Properties>
            <string name="Name">evaera_promise@4.0.0</string>
          </Properties>
          <Item class="ModuleScript" referent="30">
            <Properties>
              <string name="Name">promise</string>
              <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="31">
              <Properties>
                <string name="Name">init.spec</string>
                <string name="Source"><![CDATA[return function()
	local Promise = require(script.Parent)
	Promise.TEST = true

	local timeEvent = Instance.new("BindableEvent")
	Promise._timeEvent = timeEvent.Event

	local advanceTime
	do
		local injectedPromiseTime = 0

		Promise._getTime = function()
			return injectedPromiseTime
		end

		function advanceTime(delta)
			delta = delta or (1 / 60)

			injectedPromiseTime = injectedPromiseTime + delta
			timeEvent:Fire(delta)
		end
	end

	local function pack(...)
		local len = select("#", ...)

		return len, { ... }
	end

	describe("Promise.Status", function()
		it("should error if indexing nil value", function()
			expect(function()
				local _ = Promise.Status.wrong
			end).to.throw()
		end)
	end)

	describe("Unhandled rejection signal", function()
		it("should call unhandled rejection callbacks", function()
			local badPromise = Promise.new(function(_resolve, reject)
				reject(1, 2)
			end)

			local callCount = 0

			local function callback(promise, rejectionA, rejectionB)
				callCount += 1

				expect(promise).to.equal(badPromise)
				expect(rejectionA).to.equal(1)
				expect(rejectionB).to.equal(2)
			end

			local unregister = Promise.onUnhandledRejection(callback)

			advanceTime()

			expect(callCount).to.equal(1)

			unregister()

			Promise.new(function(_resolve, reject)
				reject(3, 4)
			end)

			advanceTime()

			expect(callCount).to.equal(1)
		end)
	end)

	describe("Promise.new", function()
		it("should instantiate with a callback", function()
			local promise = Promise.new(function() end)

			expect(promise).to.be.ok()
		end)

		it("should invoke the given callback with resolve and reject", function()
			local callCount = 0
			local resolveArg
			local rejectArg

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				resolveArg = resolve
				rejectArg = reject
			end)

			expect(promise).to.be.ok()

			expect(callCount).to.equal(1)
			expect(resolveArg).to.be.a("function")
			expect(rejectArg).to.be.a("function")
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should resolve promises on resolve()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve)
				callCount = callCount + 1
				resolve()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should reject promises on reject()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				reject()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.new(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(tostring(promise._values[1]):find("init.spec")).to.be.ok()
			expect(tostring(promise._values[1]):find("runExecutor")).to.be.ok()
		end)

		it("should work with C functions", function()
			expect(function()
				Promise.new(tick):andThen(tick)
			end).to.never.throw()
		end)

		it("should have a nice tostring", function()
			expect(tostring(Promise.resolve()):gmatch("Promise(Resolved)")).to.be.ok()
		end)

		it("should allow yielding", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.new(function(resolve)
				bindable.Event:Wait()
				resolve(5)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should preserve stack traces of resolve-chained promises", function()
			local function nestedCall(text)
				error(text)
			end

			local promise = Promise.new(function(resolve)
				resolve(Promise.new(function()
					nestedCall("sample text")
				end))
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)

			local trace = tostring(promise._values[1])
			expect(trace:find("sample text")).to.be.ok()
			expect(trace:find("nestedCall")).to.be.ok()
			expect(trace:find("runExecutor")).to.be.ok()
			expect(trace:find("runPlanNode")).to.be.ok()
			expect(
				trace:find("...Rejected because it was chained to the following Promise, which encountered an error:")
			).to.be.ok()
		end)

		it("should report errors from Promises with _error (< v2)", function()
			local oldPromise = Promise.reject()
			oldPromise._error = "Sample error"

			local newPromise = Promise.resolve():andThenReturn(oldPromise)

			expect(newPromise:getStatus()).to.equal(Promise.Status.Rejected)

			local trace = tostring(newPromise._values[1])
			expect(trace:find("Sample error")).to.be.ok()
			expect(
				trace:find("...Rejected because it was chained to the following Promise, which encountered an error:")
			).to.be.ok()
			expect(trace:find("%[No stack trace available")).to.be.ok()
		end)

		it("should allow callable tables", function()
			local promise = Promise.new(setmetatable({}, {
				__call = function(_, resolve)
					resolve(1)
				end,
			}))

			local called = false
			promise:andThen(setmetatable({}, {
				__call = function(_, var)
					expect(var).to.equal(1)
					called = true
				end,
			}))

			expect(called).to.equal(true)
		end)

		itSKIP("should close the thread after resolve", function()
			local count = 0
			Promise.new(function(resolve)
				count += 1
				resolve()
				Promise.delay(1):await()
				count += 1
			end)

			task.wait(1)

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise.defer", function()
		it("should execute after the time event", function()
			local callCount = 0
			local promise = Promise.defer(function(resolve, reject, onCancel, nothing)
				expect(type(resolve)).to.equal("function")
				expect(type(reject)).to.equal("function")
				expect(type(onCancel)).to.equal("function")
				expect(type(nothing)).to.equal("nil")

				callCount = callCount + 1

				resolve("foo")
			end)

			expect(callCount).to.equal(0)
			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)

			advanceTime()
			expect(callCount).to.equal(1)
		end)
	end)

	describe("Promise.delay", function()
		it("should schedule promise resolution", function()
			local promise = Promise.delay(1)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime()
			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should allow for delays to be cancelled", function()
			local promise = Promise.delay(2)

			Promise.delay(1):andThen(function()
				promise:cancel()
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			advanceTime()
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			advanceTime(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			advanceTime(1)
		end)
	end)

	describe("Promise.resolve", function()
		it("should immediately resolve with a value", function()
			local promise = Promise.resolve(5, 6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
			expect(promise._values[2]).to.equal(6)
		end)

		it("should chain onto passed promises", function()
			local promise = Promise.resolve(Promise.new(function(_, reject)
				reject(7)
			end))

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(7)
		end)
	end)

	describe("Promise.reject", function()
		it("should immediately reject with a value", function()
			local promise = Promise.reject(6, 7)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)
			expect(promise._values[2]).to.equal(7)
		end)

		it("should pass a promise as-is as an error", function()
			local innerPromise = Promise.new(function(resolve)
				resolve(6)
			end)

			local promise = Promise.reject(innerPromise)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(innerPromise)
		end)
	end)

	describe("Promise:andThen", function()
		it("should allow yielding", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.resolve():andThen(function()
				bindable.Event:Wait()
				return 5
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should run andThens on a new thread", function()
			local bindable = Instance.new("BindableEvent")

			local resolve
			local parentPromise = Promise.new(function(_resolve)
				resolve = _resolve
			end)

			local deadlockedPromise = parentPromise:andThen(function()
				bindable.Event:Wait()
				return 5
			end)

			local successfulPromise = parentPromise:andThen(function()
				return "foo"
			end)

			expect(parentPromise:getStatus()).to.equal(Promise.Status.Started)
			resolve()
			expect(successfulPromise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(successfulPromise._values[1]).to.equal("foo")
			expect(deadlockedPromise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should chain onto resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.resolve(5)

			local chained = promise:andThen(function(...)
				argsLength, args = pack(...)
				callCount = callCount + 1
			end, function()
				badCallCount = badCallCount + 1
			end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.reject(5)

			local chained = promise:andThen(function(...)
				badCallCount = badCallCount + 1
			end, function(...)
				argsLength, args = pack(...)
				callCount = callCount + 1
			end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.resolve(1):andThen(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(tostring(promise._values[1]):find("init.spec")).to.be.ok()
			expect(tostring(promise._values[1]):find("runExecutor")).to.be.ok()
		end)

		it("should chain onto asynchronously resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(resolve)
				startResolution = resolve
			end)

			local chained = promise:andThen(function(...)
				args = { ... }
				argsLength = select("#", ...)
				callCount = callCount + 1
			end, function()
				badCallCount = badCallCount + 1
			end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(_, reject)
				startResolution = reject
			end)

			local chained = promise:andThen(function()
				badCallCount = badCallCount + 1
			end, function(...)
				args = { ... }
				argsLength = select("#", ...)
				callCount = callCount + 1
			end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should propagate errors through multiple levels", function()
			local x, y, z
			Promise.new(function(resolve, reject)
				reject(1, 2, 3)
			end):andThen(function() end):catch(function(a, b, c)
				x, y, z = a, b, c
			end)

			expect(x).to.equal(1)
			expect(y).to.equal(2)
			expect(z).to.equal(3)
		end)

		it("should not call queued callbacks from a cancelled sub-promise", function()
			local resolve
			local count = 0

			local root = Promise.new(function(r)
				resolve = r
			end)

			root:andThen(function()
				count += 1
			end)

			root
				:andThen(function()
					count += 1
				end)
				:cancel()

			resolve("foo")

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise:cancel", function()
		it("should mark promises as cancelled and not resolve or reject them", function()
			local callCount = 0
			local finallyCallCount = 0
			local promise = Promise.new(function() end)
				:andThen(function()
					callCount = callCount + 1
				end)
				:finally(function()
					finallyCallCount = finallyCallCount + 1
				end)

			promise:cancel()
			promise:cancel() -- Twice to check call counts

			expect(callCount).to.equal(0)
			expect(finallyCallCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should call the cancellation hook once", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject, onCancel)
				onCancel(function()
					callCount = callCount + 1
				end)
			end)

			promise:cancel()
			promise:cancel() -- Twice to check call count

			expect(callCount).to.equal(1)
		end)

		it("should propagate cancellations", function()
			local promise = Promise.new(function() end)

			local consumer1 = promise:andThen()
			local consumer2 = promise:andThen()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer1:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer2:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should affect downstream promises", function()
			local promise = Promise.new(function() end)
			local consumer = promise:andThen()

			promise:cancel()

			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should track consumers", function()
			local pending = Promise.new(function() end)
			local p0 = Promise.resolve()
			local p1 = p0:andThen(function()
				return pending
			end)
			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end)
			local p3 = p2:andThen(function() end)

			expect(p1._parent).to.never.equal(p0)
			expect(p2._parent).to.never.equal(p1)
			expect(p2._consumers[p3]).to.be.ok()
			expect(p3._parent).to.equal(p2)
		end)

		it("should cancel resolved pending promises", function()
			local p1 = Promise.new(function() end)

			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end):finally(function() end)

			p2:cancel()

			expect(p1._status).to.equal(Promise.Status.Cancelled)
			expect(p2._status).to.equal(Promise.Status.Cancelled)
		end)

		it("should close the promise thread", function()
			local count = 0
			local promise = Promise.new(function()
				count += 1
				Promise.delay(1):await()
				count += 1
			end)

			promise:cancel()
			advanceTime(2)

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise:finally", function()
		it("should be called upon resolve, reject, or cancel", function()
			local callCount = 0

			local function finally()
				callCount = callCount + 1
			end

			-- Resolved promise
			Promise.new(function(resolve, reject)
				resolve()
			end):finally(finally)

			-- Chained promise
			Promise.resolve():andThen(function() end):finally(finally):finally(finally)

			-- Rejected promise
			Promise.reject():finally(finally)

			local cancelledPromise = Promise.new(function() end):finally(finally)
			cancelledPromise:cancel()

			expect(callCount).to.equal(5)
		end)

		it("should not forward return values", function()
			local value

			Promise.resolve(2)
				:finally(function()
					return 1
				end)
				:andThen(function(v)
					value = v
				end)

			expect(value).to.equal(2)
		end)

		it("should not consume rejections", function()
			local catchRan = false
			local thenRan = false
			Promise.reject(5)
				:finally(function()
					return 42
				end)
				:andThen(function()
					thenRan = true
				end)
				:catch(function(value)
					catchRan = true
					expect(value).to.equal(5)
				end)

			expect(catchRan).to.equal(true)
			expect(thenRan).to.equal(false)
		end)

		it("should wait for returned promises", function()
			local resolve
			local promise = Promise.reject("foo"):finally(function()
				return Promise.new(function(r)
					resolve = r
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			resolve()

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			local _, value = promise:_unwrap()
			expect(value).to.equal("foo")
		end)

		it("should reject with a returned rejected promise's value", function()
			local reject
			local promise = Promise.reject("foo"):finally(function()
				return Promise.new(function(_, r)
					reject = r
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			reject("bar")

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			local _, value = promise:_unwrap()
			expect(value).to.equal("bar")
		end)

		it("should reject when handler errors", function()
			local errorValue = {}
			local promise = Promise.reject("bar"):finally(function()
				error(errorValue)
			end)

			local ok, value = promise:_unwrap()

			expect(ok).to.equal(false)
			expect(value).to.equal(errorValue)
		end)

		it("should not prevent cancellation", function()
			local promise = Promise.new(function() end)

			local finallyRan = false
			promise:finally(function()
				finallyRan = true
			end)

			local consumer = promise:andThen(function() end)

			consumer:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(finallyRan).to.equal(true)
		end)

		it("should propagate cancellation downwards", function()
			local finallyRan = false
			local andThenRan = false
			local root = Promise.new(function() end)

			local consumer = root:finally(function()
				finallyRan = true
			end)

			root:cancel()

			expect(root:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)

			expect(finallyRan).to.equal(true)
			expect(andThenRan).to.equal(false)
		end)

		it("should propagate cancellation upwards", function()
			local finallyRan = false
			local andThenRan = false
			local root = Promise.new(function() end)

			local consumer = root:finally(function()
				finallyRan = true
			end)

			consumer:cancel()

			expect(root:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)

			expect(finallyRan).to.equal(true)
			expect(andThenRan).to.equal(false)
		end)

		it("should cancel returned promise if cancelled", function()
			local internal = Promise.new(function() end)

			local promise = Promise.resolve():finally(function()
				return internal
			end)

			promise:cancel()

			expect(internal:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.all", function()
		it("should error if given something other than a table", function()
			expect(function()
				Promise.all(1)
			end).to.throw()
		end)

		it("should resolve instantly with an empty table if given no promises", function()
			local promise = Promise.all({})
			local success, value = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(value).to.be.a("table")
			expect(next(value)).to.equal(nil)
		end)

		it("should error if given non-promise values", function()
			expect(function()
				Promise.all({ {}, {}, {} })
			end).to.throw()
		end)

		it("should wait for all promises to be resolved and return their values", function()
			local resolveFunctions = {}

			local testValuesLength, testValues = pack(1, "A string", nil, false)

			local promises = {}

			for i = 1, testValuesLength do
				promises[i] = Promise.new(function(resolve)
					resolveFunctions[i] = { resolve, testValues[i] }
				end)
			end

			local combinedPromise = Promise.all(promises)

			for _, resolve in ipairs(resolveFunctions) do
				expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)
				resolve[1](resolve[2])
			end

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, resolved = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(2)
			expect(success).to.equal(true)
			expect(resolved).to.be.a("table")
			expect(#resolved).to.equal(#promises)

			for i = 1, testValuesLength do
				expect(resolved[i]).to.equal(testValues[i])
			end
		end)

		it("should reject if any individual promise rejected", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
			expect(b:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should not resolve if resolved after rejecting", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should only reject once", function()
			local rejectA
			local rejectB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(_, reject)
				rejectB = reject
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("foo", "bar")

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Rejected)

			rejectB("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("foo")
			expect(second).to.equal("bar")
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.all(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel pending promises if one rejects", function()
			local p = Promise.new(function() end)
			expect(Promise.all({
				Promise.resolve(),
				Promise.reject(),
				p,
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.all(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.fold", function()
		it("should return the initial value in a promise when the list is empty", function()
			local initialValue = {}
			local result = Promise.fold({}, function()
				error("should not be called")
			end, initialValue)

			expect(Promise.is(result)).to.equal(true)
			expect(result:getStatus()).to.equal(Promise.Status.Resolved)
			expect(result:expect()).to.equal(initialValue)
		end)

		it("should accept promises in the list", function()
			local resolve

			local sum = Promise.fold({ Promise.new(function(r)
				resolve = r
			end), 2, 3 }, function(sum, element)
				return sum + element
			end, 0)

			resolve(1)

			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Resolved)
			expect(sum:expect()).to.equal(6)
		end)

		it("should always return a promise even if the list or reducer don't use them", function()
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 2 then
					return Promise.delay(1):andThenReturn(sum + element)
				else
					return sum + element
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Started)
			advanceTime(2)
			expect(sum:getStatus()).to.equal(Promise.Status.Resolved)
			expect(sum:expect()).to.equal(6)
		end)

		it("should return the first rejected promise", function()
			local errorMessage = "foo"
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 2 then
					return Promise.reject(errorMessage)
				else
					return sum + element
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			local status, rejection = sum:awaitStatus()
			expect(status).to.equal(Promise.Status.Rejected)
			expect(rejection).to.equal(errorMessage)
		end)

		it("should return the first canceled promise", function()
			local secondPromise
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 1 then
					return sum + element
				elseif index == 2 then
					secondPromise = Promise.delay(1):andThenReturn(sum + element)
					return secondPromise
				else
					error("this should not run if the promise is cancelled")
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Started)
			secondPromise:cancel()
			expect(sum:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.race", function()
		it("should resolve with the first settled value", function()
			local promise = Promise.race({
				Promise.resolve(1),
				Promise.resolve(2),
			}):andThen(function(value)
				expect(value).to.equal(1)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should cancel other promises", function()
			local promise = Promise.new(function() end)
			promise:andThen(function() end)
			local promises = {
				promise,
				Promise.new(function() end),
				Promise.new(function(resolve)
					resolve(2)
				end),
			}

			local promise = Promise.race(promises)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(2)
			expect(promises[1]:getStatus()).to.equal(Promise.Status.Started)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Resolved)

			local p = Promise.new(function() end)
			expect(Promise.race({
				Promise.reject(),
				Promise.resolve(),
				p,
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.race(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.race(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.promisify", function()
		it("should wrap functions", function()
			local function test(n)
				return n + 1
			end

			local promisified = Promise.promisify(test)
			local promise = promisified(1)
			local success, result = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(result).to.equal(2)
		end)

		it("should catch errors after a yield", function()
			local bindable = Instance.new("BindableEvent")
			local test = Promise.promisify(function()
				bindable.Event:Wait()
				error("errortext")
			end)

			local promise = test()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise.tap", function()
		it("should thread through values", function()
			local first, second

			Promise.resolve(1)
				:andThen(function(v)
					return v + 1
				end)
				:tap(function(v)
					first = v
					return v + 1
				end)
				:andThen(function(v)
					second = v
				end)

			expect(first).to.equal(2)
			expect(second).to.equal(2)
		end)

		it("should chain onto promises", function()
			local resolveInner, finalValue

			local promise = Promise.resolve(1)
				:tap(function()
					return Promise.new(function(resolve)
						resolveInner = resolve
					end)
				end)
				:andThen(function(v)
					finalValue = v
				end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(finalValue).to.never.be.ok()

			resolveInner(1)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(finalValue).to.equal(1)
		end)
	end)

	describe("Promise.try", function()
		it("should catch synchronous errors", function()
			local errorText
			Promise.try(function()
				error("errortext")
			end):catch(function(e)
				errorText = tostring(e)
			end)

			expect(errorText:find("errortext")).to.be.ok()
		end)

		it("should reject with error objects", function()
			local object = {}
			local success, value = Promise.try(function()
				error(object)
			end):_unwrap()

			expect(success).to.equal(false)
			expect(value).to.equal(object)
		end)

		it("should catch asynchronous errors", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.try(function()
				bindable.Event:Wait()
				error("errortext")
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise:andThenReturn", function()
		it("should return the given values", function()
			local value1, value2

			Promise.resolve():andThenReturn(1, 2):andThen(function(one, two)
				value1 = one
				value2 = two
			end)

			expect(value1).to.equal(1)
			expect(value2).to.equal(2)
		end)
	end)

	describe("Promise:andThenCall", function()
		it("should call the given function with arguments", function()
			local value1, value2
			Promise.resolve():andThenCall(function(a, b)
				value1 = a
				value2 = b
			end, 3, 4)

			expect(value1).to.equal(3)
			expect(value2).to.equal(4)
		end)
	end)

	describe("Promise.some", function()
		it("should resolve once the goal is reached", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.reject(),
				Promise.resolve(2),
			}, 2)
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should error if the goal can't be reached", function()
			expect(Promise.some({
				Promise.resolve(),
				Promise.reject(),
			}, 2):getStatus()).to.equal(Promise.Status.Rejected)

			local reject
			local p = Promise.some({
				Promise.resolve(),
				Promise.new(function(_, r)
					reject = r
				end),
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject("foo")
			expect(p:getStatus()).to.equal(Promise.Status.Rejected)
			expect(p._values[1]).to.equal("foo")
		end)

		it("should cancel pending Promises once the goal is reached", function()
			local resolve
			local pending1 = Promise.new(function() end)
			local pending2 = Promise.new(function(r)
				resolve = r
			end)

			local some = Promise.some({
				pending1,
				pending2,
				Promise.resolve(),
			}, 2)

			expect(some:getStatus()).to.equal(Promise.Status.Started)
			expect(pending1:getStatus()).to.equal(Promise.Status.Started)
			expect(pending2:getStatus()).to.equal(Promise.Status.Started)

			resolve()

			expect(some:getStatus()).to.equal(Promise.Status.Resolved)
			expect(pending1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(pending2:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should error if passed a non-number", function()
			expect(function()
				Promise.some({}, "non-number")
			end).to.throw()
		end)

		it("should return an empty array if amount is 0", function()
			local p = Promise.some({
				Promise.resolve(2),
			}, 0)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(0)
		end)

		it("should not return extra values", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.resolve(2),
				Promise.resolve(3),
				Promise.resolve(4),
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(2)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.some(promises, 3):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)

		describe("Promise.any", function()
			it("should return the value directly", function()
				local p = Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.resolve(1),
				})

				expect(p:getStatus()).to.equal(Promise.Status.Resolved)
				expect(p._values[1]).to.equal(1)
			end)

			it("should error if all are rejected", function()
				expect(Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.reject(),
				}):getStatus()).to.equal(Promise.Status.Rejected)
			end)
		end)
	end)

	describe("Promise.allSettled", function()
		it("should resolve with an array of PromiseStatuses", function()
			local reject
			local p = Promise.allSettled({
				Promise.resolve(),
				Promise.reject(),
				Promise.resolve(),
				Promise.new(function(_, r)
					reject = r
				end),
			})

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject()
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][2]).to.equal(Promise.Status.Rejected)
			expect(p._values[1][3]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][4]).to.equal(Promise.Status.Rejected)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.allSettled(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise:await", function()
		it("should return the correct values", function()
			local promise = Promise.resolve(5, 6, nil, 7)

			local a, b, c, d, e = promise:await()

			expect(a).to.equal(true)
			expect(b).to.equal(5)
			expect(c).to.equal(6)
			expect(d).to.equal(nil)
			expect(e).to.equal(7)
		end)

		it("should work if yielding is needed", function()
			local ran = false
			task.spawn(function()
				local _, actualTime = Promise.delay(1):await()
				expect(type(actualTime)).to.equal("number")
				ran = true
			end)

			advanceTime(2)
			expect(ran).to.equal(true)
		end)
	end)

	describe("Promise:expect", function()
		it("should throw the correct values", function()
			local rejectionValue = {}
			local promise = Promise.reject(rejectionValue)

			local success, value = pcall(function()
				promise:expect()
			end)

			expect(success).to.equal(false)
			expect(value).to.equal(rejectionValue)
		end)
	end)

	describe("Promise:now", function()
		it("should resolve if the Promise is resolved", function()
			local success, value = Promise.resolve("foo"):now():_unwrap()

			expect(success).to.equal(true)
			expect(value).to.equal("foo")
		end)

		it("should reject if the Promise is not resolved", function()
			local success, value = Promise.new(function() end):now():_unwrap()

			expect(success).to.equal(false)
			expect(Promise.Error.isKind(value, "NotResolvedInTime")).to.equal(true)
		end)

		it("should reject with a custom rejection value", function()
			local success, value = Promise.new(function() end):now("foo"):_unwrap()

			expect(success).to.equal(false)
			expect(value).to.equal("foo")
		end)
	end)

	describe("Promise.each", function()
		it("should iterate", function()
			local ok, result = Promise.each({
				"foo",
				"bar",
				"baz",
				"qux",
			}, function(...)
				return { ... }
			end):_unwrap()

			expect(ok).to.equal(true)
			expect(result[1][1]).to.equal("foo")
			expect(result[1][2]).to.equal(1)
			expect(result[2][1]).to.equal("bar")
			expect(result[2][2]).to.equal(2)
			expect(result[3][1]).to.equal("baz")
			expect(result[3][2]).to.equal(3)
			expect(result[4][1]).to.equal("qux")
			expect(result[4][2]).to.equal(4)
		end)

		it("should iterate serially", function()
			local resolves = {}
			local callCounts = {}

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				callCounts[index] = (callCounts[index] or 0) + 1

				return Promise.new(function(resolve)
					table.insert(resolves, function()
						resolve(value:upper())
					end)
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(#resolves).to.equal(1)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(#resolves).to.equal(1)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.equal(1)
			expect(callCounts[3]).to.never.be.ok()

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.equal(1)
			expect(callCounts[3]).to.equal(1)

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(type(promise._values[1])).to.equal("table")
			expect(type(promise._values[2])).to.equal("nil")

			local result = promise._values[1]

			expect(result[1]).to.equal("FOO")
			expect(result[2]).to.equal("BAR")
			expect(result[3]).to.equal("BAZ")
		end)

		it("should reject with the value if the predicate promise rejects", function()
			local promise = Promise.each({ 1, 2, 3 }, function()
				return Promise.reject("foobar")
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("foobar")
		end)

		it("should allow Promises to be in the list and wait when it gets to them", function()
			local innerResolve
			local innerPromise = Promise.new(function(resolve)
				innerResolve = resolve
			end)

			local promise = Promise.each({
				innerPromise,
			}, function(value)
				return value * 2
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			innerResolve(2)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1][1]).to.equal(4)
		end)

		it("should reject with the value if a Promise from the list rejects", function()
			local called = false
			local promise = Promise.each({ 1, 2, Promise.reject("foobar") }, function(value)
				called = true
				return "never"
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("foobar")
			expect(called).to.equal(false)
		end)

		it("should reject immediately if there's a cancelled Promise in the list initially", function()
			local cancelled = Promise.new(function() end)
			cancelled:cancel()

			local called = false
			local promise = Promise.each({ 1, 2, cancelled }, function()
				called = true
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(called).to.equal(false)
			expect(promise._values[1].kind).to.equal(Promise.Error.Kind.AlreadyCancelled)
		end)

		it("should stop iteration if Promise.each is cancelled", function()
			local callCounts = {}

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				callCounts[index] = (callCounts[index] or 0) + 1

				return Promise.new(function() end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()

			promise:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()
		end)

		it("should cancel the Promise returned from the predicate if Promise.each is cancelled", function()
			local innerPromise

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				innerPromise = Promise.new(function() end)
				return innerPromise
			end)

			promise:cancel()

			expect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should cancel Promises in the list if Promise.each is cancelled", function()
			local innerPromise = Promise.new(function() end)

			local promise = Promise.each({ innerPromise }, function() end)

			promise:cancel()

			expect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.retry", function()
		it("should retry N times", function()
			local counter = 0

			local promise = Promise.retry(function(parameter)
				expect(parameter).to.equal("foo")

				counter = counter + 1

				if counter == 5 then
					return Promise.resolve("ok")
				end

				return Promise.reject("fail")
			end, 5, "foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("ok")
		end)

		it("should reject if threshold is exceeded", function()
			local promise = Promise.retry(function()
				return Promise.reject("fail")
			end, 5)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("fail")
		end)
	end)

	describe("Promise.retryWithDelay", function()
		it("should retry after a delay", function()
			local counter = 0

			local promise = Promise.retryWithDelay(function(parameter)
				expect(parameter).to.equal("foo")

				counter = counter + 1

				if counter == 3 then
					return Promise.resolve("ok")
				end

				return Promise.reject("fail")
			end, 3, 10, "foo")

			expect(counter).to.equal(1)

			advanceTime(11)

			expect(counter).to.equal(2)

			advanceTime(11)

			expect(counter).to.equal(3)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("ok")
		end)
	end)

	describe("Promise.fromEvent", function()
		it("should convert a Promise into an event", function()
			local event = Instance.new("BindableEvent")

			local promise = Promise.fromEvent(event.Event)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("foo")
		end)

		it("should convert a Promise into an event with the predicate", function()
			local event = Instance.new("BindableEvent")

			local promise = Promise.fromEvent(event.Event, function(param)
				return param == "foo"
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("bar")

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("foo")
		end)
	end)

	describe("Promise.is", function()
		it("should work with current version", function()
			local promise = Promise.resolve(1)

			expect(Promise.is(promise)).to.equal(true)
		end)

		it("should work with any object with an andThen", function()
			local obj = {
				andThen = function()
					return 1
				end,
			}

			expect(Promise.is(obj)).to.equal(true)
		end)

		it("should work with older promises", function()
			local OldPromise = {}
			OldPromise.prototype = {}
			OldPromise.__index = OldPromise.prototype

			function OldPromise.prototype:andThen() end

			local oldPromise = setmetatable({}, OldPromise)

			expect(Promise.is(oldPromise)).to.equal(true)
		end)
	end)
end
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="32">
          <Properties>
            <string name="Name">littensy_reflex@4.3.1</string>
          </Properties>
          <Item class="ModuleScript" referent="33">
            <Properties>
              <string name="Name">Promise</string>
              <string name="Source">local module = require(script.Parent.Parent["evaera_promise@4.0.0"]["promise"])
return module</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="34">
            <Properties>
              <string name="Name">reflex</string>
              <string name="Source"><![CDATA[local types = require(script.types)
local broadcast = require(script.broadcast)
local createProducer = require(script.createProducer)
local combineProducers = require(script.combineProducers)
local createSelector = require(script.createSelector)
local applyMiddleware = require(script.applyMiddleware)
local loggerMiddleware = require(script.middleware.loggerMiddleware)
local shallowEqual = require(script.utils.shallowEqual)

export type Broadcaster = types.Broadcaster
export type BroadcastAction = types.BroadcastAction
export type BroadcasterOptions = types.BroadcasterOptions

export type BroadcastReceiver = types.BroadcastReceiver
export type BroadcastReceiverOptions = types.BroadcastReceiverOptions

export type Producer<State = any, Dispatchers = { [string]: (...any) -> State }> = types.Producer<State, Dispatchers>
export type Middleware = types.Middleware

return {
	createProducer = createProducer,
	combineProducers = combineProducers,
	createSelector = createSelector,
	applyMiddleware = applyMiddleware,
	loggerMiddleware = loggerMiddleware,
	createBroadcaster = broadcast.createBroadcaster,
	createBroadcastReceiver = broadcast.createBroadcastReceiver,
	shallowEqual = shallowEqual,
}
]]></string>
            </Properties>
            <Item class="Folder" referent="35">
              <Properties>
                <string name="Name">Producer.spec</string>
              </Properties>
              <Item class="ModuleScript" referent="36">
                <Properties>
                  <string name="Name">getDispatchers.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
			decrement = function(state, amount)
				return { count = state.count - amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should return a table of dispatchers", function()
		local dispatchers = producer:getDispatchers()
		expect(dispatchers).to.be.a("table")
		expect(dispatchers.increment).to.be.a("function")
		expect(dispatchers.decrement).to.be.a("function")
	end)

	it("should return dispatchers that update the state", function()
		local dispatchers = producer:getDispatchers()
		dispatchers.increment(1)
		expect(producer:getState().count).to.equal(1)
		dispatchers.decrement(1)
		expect(producer:getState().count).to.equal(0)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="37">
                <Properties>
                  <string name="Name">getState.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should return the initial state", function()
		expect(producer:getState()).to.be.a("table")
		expect(producer:getState().count).to.equal(0)
	end)

	it("should return the updated state", function()
		producer.increment(1)
		expect(producer:getState().count).to.equal(1)
	end)

	it("should receive a selector function", function()
		local function selector(state)
			return state.count
		end
		expect(producer:getState(selector)).to.equal(0)
		producer.increment(1)
		expect(producer:getState(selector)).to.equal(1)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="38">
                <Properties>
                  <string name="Name">init.spec</string>
                  <string name="Source"><![CDATA[return function()
	local Promise = require(script.Parent.Parent.Promise)
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
			decrement = function(state, amount)
				return { count = state.count - amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should return a producer", function()
		expect(producer).to.be.a("table")
		expect(producer.getState).to.be.a("function")
		expect(producer.setState).to.be.a("function")
		expect(producer.getDispatchers).to.be.a("function")
		expect(producer.getActions).to.be.a("function")
		expect(producer.clone).to.be.a("function")
		expect(producer.flush).to.be.a("function")
		expect(producer.subscribe).to.be.a("function")
		expect(producer.once).to.be.a("function")
		expect(producer.wait).to.be.a("function")
		expect(producer.observe).to.be.a("function")
		expect(producer.destroy).to.be.a("function")
		expect(producer.enhance).to.be.a("function")
		expect(producer.applyMiddleware).to.be.a("function")
		expect(producer.Connect).to.be.a("function")
		expect(producer.Once).to.be.a("function")
		expect(producer.Wait).to.be.a("function")
	end)

	it("should expose the dispatcher functions", function()
		expect(producer.increment).to.be.a("function")
		expect(producer.decrement).to.be.a("function")
		producer.increment(1)
		expect(producer:getState().count).to.equal(1)
		producer.decrement(1)
		expect(producer:getState().count).to.equal(0)
	end)

	it("should support Promise.fromEvent", function()
		local promise = Promise.fromEvent(producer, function(current, previous)
			return current.count > previous.count
		end)

		producer.decrement(1)
		producer:flush()

		expect(promise:getStatus()).to.equal(Promise.Status.Started)

		producer.increment(1)
		producer:flush()

		local status, state = promise:timeout(1):awaitStatus()
		expect(status).to.equal(Promise.Status.Resolved)
		expect(state.count).to.equal(0)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="39">
                <Properties>
                  <string name="Name">observe.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	local function selector(state)
		return state
	end

	local function discriminator(item)
		return item.id
	end

	local function create(id)
		return { id = id }
	end

	local function hasId(items, id)
		for _, item in items do
			if item.id == id then
				return true
			end
		end

		return false
	end

	beforeEach(function()
		producer = createProducer({}, {})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should observe the initial items", function()
		local items = {}

		producer:setState({ create(1), create(2) })
		producer:flush()

		producer:observe(selector, discriminator, function(item)
			table.insert(items, item)
		end)

		expect(#items).to.equal(2)
		expect(hasId(items, 1)).to.equal(true)
		expect(hasId(items, 2)).to.equal(true)
	end)

	it("should observe additions", function()
		local items = {}

		producer:observe(selector, discriminator, function(item)
			table.insert(items, item)
		end)

		expect(#items).to.equal(0)

		producer:setState({ create(1), create(2) })
		producer:flush()

		expect(#items).to.equal(2)
		expect(hasId(items, 1)).to.equal(true)
		expect(hasId(items, 2)).to.equal(true)
	end)

	it("should observe additions to a set", function()
		local items = {}

		producer:observe(selector, function(_, key)
			return key
		end, function(_, key)
			table.insert(items, key)
		end)

		expect(#items).to.equal(0)

		producer:setState({ a = true, b = true })
		producer:flush()

		expect(#items).to.equal(2)
		expect(table.find(items, "a")).to.be.ok()
		expect(table.find(items, "b")).to.be.ok()
	end)

	it("should call the cleanup function when an item is deleted", function()
		local items = {}

		producer:setState({ create(1), create(2), create(3) })
		producer:flush()

		producer:observe(selector, discriminator, function(item)
			table.insert(items, item)
			return function()
				table.remove(items, table.find(items, item) or 0)
			end
		end)

		expect(#items).to.equal(3)
		expect(hasId(items, 1)).to.equal(true)
		expect(hasId(items, 2)).to.equal(true)
		expect(hasId(items, 3)).to.equal(true)

		producer:setState({ create(1), create(3) })
		producer:flush()

		expect(#items).to.equal(2)
		expect(hasId(items, 1)).to.equal(true)
		expect(hasId(items, 2)).to.equal(false)
		expect(hasId(items, 3)).to.equal(true)

		producer:setState({ create(3) })
		producer:flush()

		expect(#items).to.equal(1)
		expect(hasId(items, 1)).to.equal(false)
		expect(hasId(items, 2)).to.equal(false)
		expect(hasId(items, 3)).to.equal(true)

		producer:setState({})
		producer:flush()

		expect(#items).to.equal(0)
	end)

	it("should call the cleanup function when the observer is destroyed", function()
		local items = {}

		producer:setState({ create(1), create(2), create(3) })
		producer:flush()

		local unsubscribe = producer:observe(selector, discriminator, function(item)
			table.insert(items, item)
			return function()
				table.remove(items, table.find(items, item) or 0)
			end
		end)

		expect(#items).to.equal(3)
		expect(hasId(items, 1)).to.equal(true)
		expect(hasId(items, 2)).to.equal(true)
		expect(hasId(items, 3)).to.equal(true)

		unsubscribe()
		expect(#items).to.equal(0)
	end)

	it("should track objects with a discriminator", function()
		local items = {}
		local additions, deletions = 0, 0

		producer:observe(selector, discriminator, function(item)
			table.insert(items, item)
			additions += 1
			return function()
				table.remove(items, table.find(items, item) or 0)
				deletions += 1
			end
		end)

		expect(#items).to.equal(0)
		expect(additions).to.equal(0)
		expect(deletions).to.equal(0)

		producer:setState({ create(1), create(2), create(3), create(4), create(5) })
		producer:flush()

		expect(#items).to.equal(5)
		expect(additions).to.equal(5)
		expect(deletions).to.equal(0)

		producer:setState({ create(5), create(4), create(3), create(2), create(1) })
		producer:flush()

		expect(#items).to.equal(5)
		expect(additions).to.equal(5)
		expect(deletions).to.equal(0)
	end)

	it("should fail at tracking objects with no discriminator", function()
		local items = {}
		local additions, deletions = 0, 0

		producer:observe(selector, function(item)
			table.insert(items, item)
			additions += 1
			return function()
				table.remove(items, table.find(items, item) or 0)
				deletions += 1
			end
		end)

		expect(#items).to.equal(0)
		expect(additions).to.equal(0)
		expect(deletions).to.equal(0)

		producer:setState({ create(1), create(2), create(3), create(4), create(5) })
		producer:flush()

		expect(#items).to.equal(5)
		expect(additions).to.equal(5)
		expect(deletions).to.equal(0)

		producer:setState({ create(5), create(4), create(3), create(2), create(1) })
		producer:flush()

		expect(#items).to.equal(5)
		expect(additions).to.equal(10)
		expect(deletions).to.equal(5)
	end)

	it("should allow tracking objects by index", function()
		local items = {}
		local additions, deletions = 0, 0

		local function discriminator(item, index)
			return index
		end

		producer:observe(selector, discriminator, function(item, index)
			table.insert(items, item)
			additions += 1
			return function()
				table.remove(items, table.find(items, item) or 0)
				deletions += 1
			end
		end)

		producer:setState({ a = create(1), b = create(2), c = create(3) })
		producer:flush()

		expect(#items).to.equal(3)
		expect(additions).to.equal(3)
		expect(deletions).to.equal(0)

		producer:setState({ a = create(1), b = create(2), c = create(3), d = create(4) })
		producer:flush()

		expect(#items).to.equal(4)
		expect(additions).to.equal(4)
		expect(deletions).to.equal(0)

		producer:setState({ b = create(2), c = create(3), d = create(4) })
		producer:flush()

		expect(#items).to.equal(3)
		expect(additions).to.equal(4)
		expect(deletions).to.equal(1)
		expect(hasId(items, 1)).to.equal(false)
	end)

	it("should pass the index to the observer", function()
		local keys = {}

		producer:observe(selector, function(item, index)
			table.insert(keys, index)
		end)

		producer:setState({ a = 1, b = 2, c = 3 })
		producer:flush()

		expect(#keys).to.equal(3)

		expect(table.find(keys, "a")).to.be.ok()
		expect(table.find(keys, "b")).to.be.ok()
		expect(table.find(keys, "c")).to.be.ok()

		expect(table.find(keys, 1)).to.never.be.ok()
		expect(table.find(keys, 2)).to.never.be.ok()
		expect(table.find(keys, 3)).to.never.be.ok()
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="40">
                <Properties>
                  <string name="Name">observeWhile.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	beforeEach(function()
		producer = createProducer({}, {})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should observe while the value is truthy", function()
		local valueObserved

		producer:observeWhile(function(state)
			return state.value
		end, function(value)
			valueObserved = value

			return function()
				valueObserved = nil
			end
		end)

		expect(valueObserved).to.never.be.ok()

		producer:setState({ value = 1 })
		producer:flush()
		expect(valueObserved).to.equal(1)

		producer:setState({})
		producer:flush()
		expect(valueObserved).to.never.be.ok()
	end)

	it("should observe while the predicate returns true", function()
		local valueObserved

		producer:observeWhile(function(state)
			return state.value
		end, function(value)
			return value and value > 0
		end, function(value)
			valueObserved = value

			return function()
				valueObserved = nil
			end
		end)

		expect(valueObserved).to.never.be.ok()

		producer:setState({ value = 1 })
		producer:flush()
		expect(valueObserved).to.equal(1)

		producer:setState({ value = -1 })
		producer:flush()
		expect(valueObserved).to.never.be.ok()
	end)

	it("should observe if the initial value is already truthy", function()
		producer:setState({ value = 1 })
		producer:flush()

		local valueObserved

		producer:observeWhile(function(state)
			return state.value
		end, function(value)
			valueObserved = value

			return function()
				valueObserved = nil
			end
		end)

		expect(valueObserved).to.equal(1)
	end)

	it("should observe if the predicate returns true for the initial value", function()
		producer:setState({ value = 1 })
		producer:flush()

		local valueObserved

		producer:observeWhile(function(state)
			return state.value
		end, function(value)
			return value == 1
		end, function(value)
			valueObserved = value

			return function()
				valueObserved = nil
			end
		end)

		expect(valueObserved).to.equal(1)
	end)

	it("should observe a nil value if the predicate returns true", function()
		local valueObserved

		producer:observeWhile(function(state)
			return state.value
		end, function(value)
			return value == nil
		end, function(value)
			valueObserved = value
		end)

		expect(valueObserved).to.equal(nil)
	end)

	it("should not re-run until the value becomes falsy", function()
		local calls = 0
		local cleanups = 0

		producer:observeWhile(function(state)
			return state.value
		end, function(value)
			calls += 1
			return function()
				cleanups += 1
			end
		end)

		expect(calls).to.equal(0)
		expect(cleanups).to.equal(0)

		producer:setState({ value = 1 })
		producer:flush()
		producer:setState({ value = 1 })
		producer:flush()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(0)

		producer:setState({ value = 2 })
		producer:flush()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(0)

		producer:setState({})
		producer:flush()
		producer:setState({})
		producer:flush()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(1)

		producer:setState({ value = 3 })
		producer:flush()
		expect(calls).to.equal(2)
		expect(cleanups).to.equal(1)
	end)

	it("should not re-run until the predicate returns false", function()
		local calls = 0
		local cleanups = 0

		producer:observeWhile(function(state)
			return state.value
		end, function(value)
			return value == 1
		end, function(value)
			calls += 1
			return function()
				cleanups += 1
			end
		end)

		expect(calls).to.equal(0)
		expect(cleanups).to.equal(0)

		producer:setState({ value = 1 })
		producer:flush()
		producer:setState({ value = 1 })
		producer:flush()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(0)

		producer:setState({ value = 2 })
		producer:flush()
		producer:setState({ value = 2 })
		producer:flush()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(1)

		producer:setState({ value = 1 })
		producer:flush()
		expect(calls).to.equal(2)
		expect(cleanups).to.equal(1)
	end)

	it("should cleanup the observer when the cleanup function is called", function()
		local calls = 0
		local cleanups = 0

		local cleanup = producer:observeWhile(function(state)
			return state.value
		end, function(value)
			calls += 1
			return function()
				cleanups += 1
			end
		end)

		producer:setState({ value = 1 })
		producer:flush()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(0)

		cleanup()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(1)

		producer:setState({ value = 2 })
		producer:flush()
		expect(calls).to.equal(1)
		expect(cleanups).to.equal(1)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="41">
                <Properties>
                  <string name="Name">once.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	local function selectCount(state)
		return state.count
	end

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
			decrement = function(state, amount)
				return { count = state.count - amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should return a function to unsubscribe", function()
		local calls = 0
		local unsubscribe = producer:once(selectCount, function()
			calls += 1
		end)
		expect(unsubscribe).to.be.a("function")
		unsubscribe()
		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(0)
	end)

	it("should call the listener once", function()
		local calls = 0

		producer:once(selectCount, function()
			calls += 1
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)
	end)

	it("should pass the current and previous state to the listener", function()
		local initialState = producer:getState(selectCount)
		local previousState
		local currentState

		producer:once(selectCount, function(current, previous)
			previousState = previous
			currentState = current
		end)

		producer:flush()
		expect(previousState).to.equal(nil)
		expect(currentState).to.equal(nil)

		producer.increment(1)
		producer:flush()
		expect(previousState).to.equal(initialState)
		expect(currentState).to.equal(producer:getState(selectCount))
	end)

	it("should receive a predicate", function()
		local calls = 0

		local function isGreaterThan(current, previous)
			return current > previous
		end

		producer:once(selectCount, isGreaterThan, function(current, previous)
			calls += 1
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(-1)
		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="42">
                <Properties>
                  <string name="Name">resetState.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local initialState = { count = 0 }
	local producer

	beforeEach(function()
		producer = createProducer(initialState, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should reset the state to the initial state", function()
		producer.increment(1)
		producer:resetState()
		expect(producer:getState()).to.equal(initialState)
	end)

	it("should trigger a state update if state changed", function()
		local stateChanged = false
		producer.increment(1)
		producer:flush()
		producer:subscribe(function()
			stateChanged = true
		end)
		producer:resetState()
		producer:flush()
		expect(stateChanged).to.equal(true)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="43">
                <Properties>
                  <string name="Name">setState.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should set the state", function()
		local state = { count = 1 }
		producer:setState(state)
		expect(producer:getState()).to.equal(state)
	end)

	it("should schedule a flush", function()
		local thread = coroutine.running()

		producer:subscribe(function(state)
			coroutine.resume(thread)
		end)

		producer:setState({ count = 1 })

		task.delay(1, function()
			if thread then
				coroutine.resume(thread, "flush took too long")
			end
		end)

		expect(coroutine.yield()).to.equal(nil)
		thread = nil
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="44">
                <Properties>
                  <string name="Name">subscribe.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	local function selectCount(state)
		return state.count
	end

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
			decrement = function(state, amount)
				return { count = state.count - amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should return a function to unsubscribe", function()
		local calls = 0
		local unsubscribe = producer:subscribe(function()
			calls += 1
		end)
		expect(unsubscribe).to.be.a("function")
		unsubscribe()
		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(0)
	end)

	it("should call the listener when the state changes", function()
		local calls = 0

		producer:subscribe(function()
			calls += 1
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(2)
	end)

	it("should pass the current and previous state to the listener", function()
		local initialState = producer:getState()
		local previousState
		local currentState

		producer:subscribe(function(current, previous)
			previousState = previous
			currentState = current
		end)

		producer.increment(1)
		producer:flush()

		expect(previousState).to.equal(initialState)
		expect(currentState).to.equal(producer:getState())
		expect(currentState).to.never.equal(previousState)
	end)

	it("should call the listener once for bulk updates", function()
		local calls = 0

		producer:subscribe(function()
			calls += 1
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer.increment(1)
		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)
	end)

	it("should call the listener once for nested updates", function()
		local calls = 0

		producer:subscribe(function()
			calls += 1
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer.increment(1)
		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)
	end)

	it("should allow updates during a flush", function()
		local initialState = producer:getState()
		local stateBeforeFlush, stateDuringFlush

		producer:subscribe(function(current, previous)
			producer.increment(1)
			stateDuringFlush = producer:getState()

			expect(current).to.equal(stateBeforeFlush)
			expect(current).to.never.equal(stateDuringFlush)
			expect(previous).to.equal(initialState)
		end)

		producer:subscribe(function(current, previous)
			expect(current).to.equal(stateBeforeFlush)
			expect(current).to.never.equal(stateDuringFlush)
			expect(previous).to.equal(initialState)
		end)

		producer.increment(1)
		stateBeforeFlush = producer:getState()
		producer:flush()

		expect(stateDuringFlush).to.equal(producer:getState())
		expect(stateDuringFlush).to.never.equal(stateBeforeFlush)
	end)

	it("should defer subscriptions from within a listener", function()
		local calls = 0

		producer:subscribe(function()
			calls += 1
			if calls == 1 then
				producer:subscribe(function()
					calls += 1
				end)
			end
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(3)
	end)

	it("should receive a selector function", function()
		local value

		producer:subscribe(selectCount, function(count)
			value = count
		end)

		producer:flush()
		expect(value).to.equal(nil)

		producer.increment(1)
		producer:flush()
		expect(value).to.equal(1)

		producer.increment(1)
		producer:flush()
		expect(value).to.equal(2)
	end)

	it("should not call the listener if the selector returns the same value", function()
		local calls = 0

		producer:subscribe(selectCount, function()
			calls += 1
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(2)

		producer.increment(0)
		producer:flush()
		expect(calls).to.equal(2)
	end)

	it("should receive a predicate", function()
		local calls = 0

		local function isGreaterThan(current, previous)
			return current > previous
		end

		producer:subscribe(selectCount, isGreaterThan, function(current, previous)
			calls += 1
		end)

		producer:flush()
		expect(calls).to.equal(0)

		producer.decrement(1)
		producer:flush()
		expect(calls).to.equal(0)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(1)

		producer.increment(1)
		producer:flush()
		expect(calls).to.equal(2)

		producer.decrement(1)
		producer:flush()
		expect(calls).to.equal(2)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="45">
                <Properties>
                  <string name="Name">wait.spec</string>
                  <string name="Source"><![CDATA[return function()
	local Promise = require(script.Parent.Parent.Promise)
	local createProducer = require(script.Parent.Parent.createProducer)

	local producer

	local function selectCount(state)
		return state.count
	end

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
			decrement = function(state, amount)
				return { count = state.count - amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should unsubscribe on promise cancel", function()
		local calls = 0

		local function selectorSpy(state)
			calls += 1
			return state.count
		end

		local promise = producer:wait(selectorSpy)
		local initialCalls = calls

		promise:cancel()
		producer.increment(1)
		producer:flush()

		expect(calls).to.equal(initialCalls)
		expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
	end)

	it("should resolve with the new state", function()
		local promise = producer:wait(selectCount)
		producer.increment(1)
		producer:flush()
		local status, count = promise:timeout(1):awaitStatus()
		expect(status).to.equal(Promise.Status.Resolved)
		expect(count).to.equal(1)
	end)

	it("should receive a predicate", function()
		local function isGreaterThan(current, previous)
			return current > previous
		end

		local promise = producer:wait(selectCount, isGreaterThan)

		producer.decrement(1)
		producer:flush()

		expect(promise:getStatus()).to.equal(Promise.Status.Started)

		producer.increment(2)
		producer:flush()

		local status, count = promise:timeout(1):awaitStatus()
		expect(status).to.equal(Promise.Status.Resolved)
		expect(count).to.equal(1)
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="46">
              <Properties>
                <string name="Name">Promise</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local packages = script:FindFirstAncestor("rbxts_include")
	or script:FindFirstAncestor("include")
	or ReplicatedStorage:FindFirstChild("rbxts_include")
	or script.Parent.Parent

if packages and packages:FindFirstChild("Promise") then
	return require(packages.Promise)
else
	error(`Could not find Promise from {script:GetFullName()}`)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="47">
              <Properties>
                <string name="Name">applyMiddleware</string>
                <string name="Source"><![CDATA[--!nolint ImportUnused
local types = require(script.Parent.types)

--[=[
	Creates a producer enhancer that applies the given middleware to the
	producer.

	Initially, a middleware is called once when it is applied to a producer.
	Next, the returned function is called on a dispatcher in the producer.
	The final function is called whenever the dispatcher is called.

	```lua
	local loggerMiddleware: Reflex.Middleware = function(producer)
		print("Initial state:", producer.getState())
		return function(dispatch, name)
			return function(...)
				print(`Dispatching {name}:`, ...args)
				return dispatch(...)
			end
		end
	end

	producer:enhance(applyMiddleware(loggerMiddleware))
	```

	@param middlewares A list of middleware to apply.
	@return A producer enhancer.
]=]
local function applyMiddleware(...: types.Middleware): <T>(producer: T) -> T
	local arguments = { ... }

	return function(producer)
		local middlewares = table.clone(arguments)
		local dispatchers = producer:getDispatchers()

		for index, middleware in middlewares do
			middlewares[index] = middleware(producer)
		end

		for name, dispatcher in dispatchers do
			for index = #middlewares, 1, -1 do
				dispatcher = middlewares[index](dispatcher, name)
			end

			dispatchers[name] = dispatcher
			producer[name] = dispatcher
		end

		return producer
	end
end

return applyMiddleware
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="48">
              <Properties>
                <string name="Name">applyMiddleware.spec</string>
                <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.createProducer)
	local applyMiddleware = require(script.Parent.applyMiddleware)

	local producer

	beforeEach(function()
		producer = createProducer({ count = 0 }, {
			increment = function(state, amount)
				return { count = state.count + amount }
			end,
		})
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should call middleware with the right parameters", function()
		local function middleware(_producer)
			expect(_producer).to.equal(producer)

			return function(dispatch, name)
				expect(dispatch).to.be.a("function")
				expect(producer[name]).to.equal(dispatch)

				return function(...)
					expect(name).to.equal("increment")
					expect(select("#", ...)).to.equal(2)
					expect(select(1, ...)).to.equal(1)
					expect(select(2, ...)).to.equal(2)

					return dispatch(...)
				end
			end
		end

		applyMiddleware(middleware)(producer)
		expect(producer.increment(1, 2)).to.equal(producer:getState())
	end)

	it("should call middleware in order", function()
		local order = ""

		local function create(index)
			return function(producer)
				return function(dispatch)
					return function(...)
						order ..= index
						return dispatch(...)
					end
				end
			end
		end

		applyMiddleware(create(1), create(2), create(3))(producer)
		producer.increment(1)

		expect(order).to.equal("123")
	end)

	it("should pass forward the result of the middleware", function()
		local function middleware(producer)
			return function(dispatch)
				return function(...)
					dispatch(...)
					return 1
				end
			end
		end

		applyMiddleware(middleware)(producer)
		expect(producer.increment(1)).to.equal(1)
	end)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="49">
              <Properties>
                <string name="Name">broadcast</string>
                <string name="Source"><![CDATA[local createBroadcaster = require(script.createBroadcaster)
local createBroadcastReceiver = require(script.createBroadcastReceiver)

return {
	createBroadcaster = createBroadcaster,
	createBroadcastReceiver = createBroadcastReceiver,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="50">
                <Properties>
                  <string name="Name">createBroadcastReceiver</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local hydrate = require(script.Parent.hydrate)

--[=[
	Creates a broadcast receiver object that can be used to dispatch actions
	broadcasted by the server.
	@param options The options for the broadcast receiver.
	@return The broadcast receiver.
]=]
local function createBroadcastReceiver(options: types.BroadcastReceiverOptions): types.BroadcastReceiver
	local receiver = {} :: types.BroadcastReceiver
	local producer: types.Producer?

	local function hydrateState(serverState: { [string]: any })
		assert(producer, "Cannot use broadcast receiver before the middleware is applied.")

		local nextState = table.clone(producer:getState())

		for key, value in serverState do
			nextState[key] = value
		end

		producer:setState(nextState)
	end

	function receiver:dispatch(actions: { types.BroadcastAction })
		assert(producer, "Cannot dispatch actions before the middleware is applied")

		local dispatchers = producer:getDispatchers()

		for _, action in actions do
			local dispatcher = dispatchers[action.name]

			if dispatcher then
				dispatcher(table.unpack(action.arguments))
			elseif hydrate.isHydrate(action) then
				hydrateState(action.arguments[1])
			end
		end
	end

	function receiver:hydrate(serverState: { [string]: any })
		hydrateState(serverState)
	end

	function receiver.middleware(currentProducer)
		producer = currentProducer

		options.start()

		return function(dispatch)
			return dispatch
		end
	end

	return receiver
end

return createBroadcastReceiver
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="51">
                <Properties>
                  <string name="Name">createBroadcastReceiver.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)
	local combineProducers = require(script.Parent.Parent.combineProducers)
	local createBroadcaster = require(script.Parent.createBroadcaster)
	local createBroadcastReceiver = require(script.Parent.createBroadcastReceiver)
	local hydrate = require(script.Parent.hydrate)

	local mockPlayer: Player = {} :: any
	local producers, producer

	beforeEach(function()
		producers = {
			foo = createProducer({ count = 0 }, {
				incrementFoo = function(state, amount)
					return { count = state.count + amount }
				end,
			}),
			bar = createProducer({ count = 0 }, {
				incrementBar = function(state, amount)
					return { count = state.count + amount }
				end,
			}),
		}

		producer = combineProducers(producers)
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should return a broadcast receiver", function()
		local receiver = createBroadcastReceiver({
			start = function() end,
		})

		expect(receiver).to.be.a("table")
		expect(receiver.middleware).to.be.a("function")
		expect(receiver.dispatch).to.be.a("function")
	end)

	it("should apply a safe middleware", function()
		local receiver = createBroadcastReceiver({
			start = function() end,
		})

		producer:applyMiddleware(receiver.middleware)
		producer.incrementFoo(1)

		expect(producer:getState().foo.count).to.equal(1)
		expect(producer:getState().bar.count).to.equal(0)
	end)

	it("should hydrate the producer with the server state", function()
		local receiver = createBroadcastReceiver({
			start = function() end,
		})

		producer:applyMiddleware(receiver.middleware)
		receiver:dispatch({
			hydrate.createHydrateAction({ foo = { count = 1 } }),
		})

		local state = producer:getState()
		expect(state.foo.count).to.equal(1)
		expect(state.bar.count).to.equal(0)

		state = producer.incrementFoo(1)
		expect(state.foo.count).to.equal(2)
		expect(state.bar.count).to.equal(0)
	end)

	it("should dispatch actions from the server", function()
		local receiver = createBroadcastReceiver({
			start = function() end,
		})

		producer:applyMiddleware(receiver.middleware)

		receiver:dispatch({
			{ name = "incrementFoo", arguments = { 1 } },
			{ name = "incrementBar", arguments = { 2 } },
			{ name = "incrementBaz", arguments = { 3 } },
		})

		local state = producer:getState()
		expect(state.foo.count).to.equal(1)
		expect(state.bar.count).to.equal(2)
	end)

	it("should receive updates from a broadcaster", function()
		local clientProducer = producer
		local serverProducer = combineProducers(producers)
		local player, actions

		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function(...)
				player, actions = ...
			end,
		})

		local receiver = createBroadcastReceiver({
			start = function()
				broadcaster:start(mockPlayer)
			end,
		})

		-- Set the state to something other than the default
		clientProducer:setState({
			foo = { count = -1 },
			bar = { count = -1 },
		})

		serverProducer:applyMiddleware(broadcaster.middleware)
		clientProducer:applyMiddleware(receiver.middleware)

		-- Manually hydrate the state
		receiver:dispatch(actions)
		local state = clientProducer:getState()
		expect(state.foo.count).to.equal(0)
		expect(state.bar.count).to.equal(0)

		serverProducer.incrementFoo(1)
		serverProducer.incrementBar(2)

		broadcaster:flush()

		expect(player).to.equal(mockPlayer)
		expect(#actions).to.equal(2)

		local actionA, actionB = table.unpack(actions)
		expect(actionA.name).to.equal("incrementFoo")
		expect(actionA.arguments[1]).to.equal(1)
		expect(actionB.name).to.equal("incrementBar")
		expect(actionB.arguments[1]).to.equal(2)

		local stateBeforeDispatch = clientProducer:getState()
		expect(stateBeforeDispatch.foo.count).to.equal(0)
		expect(stateBeforeDispatch.bar.count).to.equal(0)

		receiver:dispatch(actions)

		local stateAfterDispatch = clientProducer:getState()
		expect(stateAfterDispatch.foo.count).to.equal(1)
		expect(stateAfterDispatch.bar.count).to.equal(2)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="52">
                <Properties>
                  <string name="Name">createBroadcaster</string>
                  <string name="Source"><![CDATA[local Players = game:GetService("Players")

local types = require(script.Parent.Parent.types)
local setInterval = require(script.Parent.Parent.utils.setInterval)
local hydrate = require(script.Parent.hydrate)

--[=[
	Creates a broadcaster that can be used to share actions with the client.
	It will track all actions that are dispatched by the provided producers and
	will broadcast them to the client.
	@param options The options for the broadcaster.
	@return The broadcaster.
]=]
local function createBroadcaster(options: types.BroadcasterOptions): types.Broadcaster
	local broadcaster = {} :: types.Broadcaster
	local producer: types.Producer?

	local pendingDispatch = false
	local pendingActionsByPlayer: { [Player]: { types.BroadcastAction } } = {}
	local actionFilter: { [string]: boolean } = {}

	for _, slice in options.producers do
		for name in slice:getDispatchers() do
			actionFilter[name] = true
		end
	end

	local function getSharedState()
		assert(producer, "Cannot use broadcaster before the middleware is applied.")

		local sharedState = {}
		local serverState = producer.getState()

		for name in options.producers do
			sharedState[name] = serverState[name]
		end

		return sharedState
	end

	local function hydratePlayer(player: Player)
		local state = getSharedState()

		if options.beforeHydrate then
			state = options.beforeHydrate(player, state)
		end

		if options.hydrate then
			options.hydrate(player, state)
		else
			options.dispatch(player, { hydrate.createHydrateAction(state) })
		end
	end

	local hydrateInterval = setInterval(function()
		for player in pendingActionsByPlayer do
			hydratePlayer(player)
		end
	end, options.hydrateRate or 60)

	local dispatchInterval = setInterval(function()
		broadcaster:flush()
	end, options.dispatchRate or 0)

	local playerRemoving = Players.PlayerRemoving:Connect(function(player)
		pendingActionsByPlayer[player] = nil
	end)

	function broadcaster:destroy()
		hydrateInterval()
		dispatchInterval()
		playerRemoving:Disconnect()
	end

	function broadcaster:flush()
		if not pendingDispatch then
			return
		end

		pendingDispatch = false

		for player, pendingActions in pendingActionsByPlayer do
			options.dispatch(player, pendingActions)
			pendingActionsByPlayer[player] = {}
		end
	end

	function broadcaster:start(player)
		if not pendingActionsByPlayer[player] then
			pendingActionsByPlayer[player] = {}
			hydratePlayer(player)
		end
	end

	broadcaster.middleware = function(currentProducer)
		producer = currentProducer

		return function(dispatch, name)
			if not actionFilter[name] then
				return dispatch
			end

			return function(...)
				for player, pendingActions in pendingActionsByPlayer do
					local action: types.BroadcastAction? = {
						name = name,
						arguments = { ... },
					}

					if options.beforeDispatch then
						action = options.beforeDispatch(player, action :: types.BroadcastAction)
					end

					table.insert(pendingActions, action)
				end

				pendingDispatch = true

				return dispatch(...)
			end
		end
	end

	return broadcaster
end

return createBroadcaster
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="53">
                <Properties>
                  <string name="Name">createBroadcaster.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createProducer = require(script.Parent.Parent.createProducer)
	local combineProducers = require(script.Parent.Parent.combineProducers)
	local createBroadcaster = require(script.Parent.createBroadcaster)

	local mockPlayer: Player = {} :: any
	local producers, producer

	beforeEach(function()
		producers = {
			foo = createProducer({ count = 0 }, {
				incrementFoo = function(state, amount)
					return { count = state.count + amount }
				end,
			}),
			bar = createProducer({ count = 0 }, {
				incrementBar = function(state, amount)
					return { count = state.count + amount }
				end,
			}),
		}

		producer = combineProducers(producers)
	end)

	afterEach(function()
		producer:destroy()
	end)

	it("should return a broadcaster", function()
		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function() end,
		})

		expect(broadcaster).to.be.a("table")
		expect(broadcaster.start).to.be.a("function")
		expect(broadcaster.middleware).to.be.a("function")
	end)

	it("should apply a safe middleware", function()
		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function() end,
		})

		producer:applyMiddleware(broadcaster.middleware)
		producer.incrementFoo(1)

		expect(producer:getState().foo.count).to.equal(1)
		expect(producer:getState().bar.count).to.equal(0)
	end)

	it("should hydrate the player on start", function()
		local player, actions

		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function(...)
				player, actions = ...
			end,
		})

		producer:applyMiddleware(broadcaster.middleware)
		broadcaster:start(mockPlayer)

		expect(player).to.equal(mockPlayer)
		expect(actions).to.be.a("table")
		expect(#actions).to.equal(1)

		expect(actions[1].name).to.equal("__hydrate__")
		expect(actions[1].arguments[1]).to.be.a("table")
		expect(actions[1].arguments[1].foo).to.be.a("table")
		expect(actions[1].arguments[1].foo.count).to.equal(0)
		expect(actions[1].arguments[1].bar).to.be.a("table")
		expect(actions[1].arguments[1].bar.count).to.equal(0)
	end)

	it("should call dispatch function", function()
		local player, actions

		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function(...)
				player, actions = ...
			end,
		})

		producer:applyMiddleware(broadcaster.middleware)
		broadcaster:start(mockPlayer)
		producer.incrementFoo(1)
		producer.incrementBar(2)
		broadcaster:flush()

		expect(player).to.equal(mockPlayer)
		expect(actions).to.be.a("table")
		expect(#actions).to.equal(2)

		expect(actions[1].name).to.equal("incrementFoo")
		expect(actions[1].arguments[1]).to.equal(1)

		expect(actions[2].name).to.equal("incrementBar")
		expect(actions[2].arguments[1]).to.equal(2)
	end)

	it("should exclude state and actions that are not provided", function()
		local actions, hydrateState

		local broadcaster = createBroadcaster({
			producers = {
				foo = producers.foo,
			},
			dispatch = function(player, _actions)
				actions = _actions
				hydrateState = hydrateState or actions[1].arguments[1]
			end,
		})

		producer:applyMiddleware(broadcaster.middleware)
		broadcaster:start(mockPlayer)
		producer.incrementFoo(1)
		producer.incrementBar(2)
		broadcaster:flush()

		-- initial state should only contain foo
		expect(hydrateState).to.be.a("table")
		expect(hydrateState.foo).to.be.a("table")
		expect(hydrateState.foo.count).to.equal(0)
		expect(hydrateState.bar).to.equal(nil)

		-- pending actions should only contain incrementFoo
		expect(#actions).to.equal(1)
		expect(actions[1].name).to.equal("incrementFoo")
		expect(actions[1].arguments[1]).to.equal(1)
	end)

	it("should receive a beforeHydrate option", function()
		local state, player

		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function(player, actions)
				state = actions[1].arguments[1]
			end,
			beforeHydrate = function(_player, state)
				player = _player
				return {
					foo = state.foo,
					bar = nil,
				}
			end,
		})

		producer:applyMiddleware(broadcaster.middleware)
		broadcaster:start(mockPlayer)

		expect(player).to.equal(mockPlayer)
		expect(state).to.be.ok()
		expect(state.foo).to.be.ok()
		expect(state.foo.count).to.equal(0)
		expect(state.bar).to.never.be.ok()
	end)

	it("should receive a beforeDispatch function", function()
		local actions, player

		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function(player, _actions)
				actions = _actions
			end,
			beforeDispatch = function(_player, action)
				player = _player
				return if action.name == "incrementFoo" then action else nil
			end,
		})

		producer:applyMiddleware(broadcaster.middleware)
		broadcaster:start(mockPlayer)
		producer.incrementFoo(1)
		producer.incrementBar(2)
		broadcaster:flush()

		expect(player).to.equal(mockPlayer)
		expect(actions).to.be.a("table")
		expect(#actions).to.equal(1)
		expect(actions[1].name).to.equal("incrementFoo")
		expect(actions[1].arguments[1]).to.equal(1)
	end)

	it("should accept a hydrate function", function()
		local actions, state, player

		local broadcaster = createBroadcaster({
			producers = producers,
			dispatch = function(...)
				player, actions = ...
			end,
			hydrate = function(...)
				player, state = ...
			end,
		})

		producer:applyMiddleware(broadcaster.middleware)
		broadcaster:start(mockPlayer)

		expect(player).to.equal(mockPlayer)
		expect(state).to.be.a("table")
		expect(state.foo.count).to.equal(0)
		expect(state.bar.count).to.equal(0)
		expect(actions).to.never.be.ok()

		producer.incrementFoo(1)
		producer.incrementBar(2)
		broadcaster:flush()

		expect(actions).to.be.a("table")
		expect(actions[1].name).to.equal("incrementFoo")
		expect(actions[2].name).to.equal("incrementBar")
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="54">
                <Properties>
                  <string name="Name">hydrate</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local HYDRATE = "__hydrate__"

local function createHydrateAction(state: any): types.BroadcastAction
	return {
		name = HYDRATE,
		arguments = { state },
	}
end

local function isHydrate(action: types.BroadcastAction): boolean
	return action.name == HYDRATE
end

return {
	createHydrateAction = createHydrateAction,
	isHydrate = isHydrate,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="55">
              <Properties>
                <string name="Name">combineProducers</string>
                <string name="Source"><![CDATA[local types = require(script.Parent.types)
local createProducer = require(script.Parent.createProducer)

local function combineInitialState(producers: types.ProducerMap)
	local initialState = {}

	for name, producer in producers do
		initialState[name] = producer:getState()
	end

	return initialState
end

local function combineActions(producers: types.ProducerMap)
	local combinedActions = {}
	local actionsByName = {}
	local producerNamesByAction = {}

	for producerName, producer in producers do
		for actionName, action in producer:getActions() do
			if actionsByName[actionName] then
				table.insert(actionsByName[actionName], action)
			else
				actionsByName[actionName] = { action }
			end

			producerNamesByAction[action] = producerName
		end
	end

	for actionName, actions in actionsByName do
		combinedActions[actionName] = function(combinedState, ...)
			local nextState = table.clone(combinedState)

			for _, action in actions do
				local producerName = producerNamesByAction[action]
				local producerState = nextState[producerName]
				nextState[producerName] = action(producerState, ...)
			end

			return nextState
		end
	end

	return combinedActions
end

--[=[
	Combines multiple producers into a single producer. Any dispatchers called
	on the combined producer will call the dispatchers of the same name on each
	of the producers passed in.

	**Don't use the individual producers.** The combined producer is the only
	one that should be used to prevent unexpected behavior.

	@param producers A map of producers to combine.
	@return A combined producer.
]=]
local function combineProducers(producers: types.ProducerMap)
	return createProducer(combineInitialState(producers), combineActions(producers))
end

return combineProducers
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="56">
              <Properties>
                <string name="Name">combineProducers.spec</string>
                <string name="Source"><![CDATA[return function()
	local combineProducers = require(script.Parent.combineProducers)
	local createProducer = require(script.Parent.createProducer)

	local producers, producer

	beforeEach(function()
		producers = {
			foo = createProducer({ count = 0 }, {
				incrementFoo = function(state, amount)
					return { count = state.count + amount }
				end,
				shared = function(state, amount)
					return { count = state.count + amount }
				end,
			}),
			bar = createProducer({ count = 0 }, {
				incrementBar = function(state, amount)
					return { count = state.count + amount }
				end,
				shared = function(state, amount)
					return { count = state.count + amount }
				end,
			}),
		}

		producer = combineProducers(producers)
	end)

	afterEach(function()
		producer:destroy()
		for _, producer in producers do
			producer:destroy()
		end
	end)

	it("should combine the initial state of each producer", function()
		local initialState = producer:getState()
		expect(initialState).to.be.a("table")
		expect(initialState.foo).to.be.a("table")
		expect(initialState.foo.count).to.equal(0)
		expect(initialState.bar).to.be.a("table")
		expect(initialState.bar.count).to.equal(0)
	end)

	it("should include every dispatcher function", function()
		expect(producer.incrementFoo).to.be.a("function")
		expect(producer.incrementBar).to.be.a("function")
		expect(producer.shared).to.be.a("function")
	end)

	it("should dispatch to the correct producer", function()
		producer.incrementFoo(1)
		expect(producer:getState().foo.count).to.equal(1)
		expect(producer:getState().bar.count).to.equal(0)

		producer.incrementBar(1)
		expect(producer:getState().foo.count).to.equal(1)
		expect(producer:getState().bar.count).to.equal(1)
	end)

	it("should combine dispatchers with the same name", function()
		producer.shared(1)
		expect(producer:getState().foo.count).to.equal(1)
		expect(producer:getState().bar.count).to.equal(1)
	end)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="57">
              <Properties>
                <string name="Name">createProducer</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Promise = require(script.Parent.Promise)
local types = require(script.Parent.types)
local applyMiddleware = require(script.Parent.applyMiddleware)
local createSelectArrayDiffs = require(script.Parent.utils.createSelectArrayDiffs)
local testSelector = require(script.Parent.utils.testSelector)

--[=[
	Creates a producer that can be used to manage state.

	A producer is a state container that exposes a set of dispatchers that can
	be used to modify the state. The state is immutable, so the dispatchers
	return a new state object.

	The dispatchers are also exposed as callbacks in the producer, and are based
	on the actions parameter, but with the first argument omitted.

	@param initialState The initial state of the producer.
	@param actions A set of actions that can be used to modify the state.
	@return A producer that can be used to manage state.
]=]
local function createProducer<State>(
	initialState: State,
	actions: { [string]: (state: State, ...any) -> any }
): types.Producer<State>
	local producer = {} :: types.Producer<State>

	local dispatchers = {}
	local currentListeners: {}? = {}
	local nextListeners = currentListeners :: {}
	local listenerIdCounter = 1

	local state = initialState
	local stateSinceLastFlush = initialState
	local pendingFlush: RBXScriptConnection?

	local function ensureCanMutateNextListeners()
		if nextListeners == currentListeners then
			nextListeners = table.clone(currentListeners :: {})
		end
	end

	local function scheduleFlush()
		if not pendingFlush then
			pendingFlush = RunService.Heartbeat:Once(function()
				pendingFlush = nil
				producer:flush()
			end)
		end
	end

	local function subscribe(listener: (state: State) -> ())
		local connected = true

		local id = listenerIdCounter
		listenerIdCounter += 1

		ensureCanMutateNextListeners()
		nextListeners[id] = listener

		return function()
			if connected then
				connected = false
				ensureCanMutateNextListeners()
				nextListeners[id] = nil
				currentListeners = nil
			end
		end
	end

	function producer:getState(selector)
		return if selector then selector(state) else state
	end

	function producer:setState(newState)
		state = newState
		scheduleFlush()
	end

	function producer:resetState()
		state = initialState
		scheduleFlush()
	end

	function producer:getDispatchers()
		return dispatchers
	end

	function producer:getActions()
		return actions
	end

	function producer:clone()
		return createProducer(state, actions)
	end

	function producer:flush()
		if pendingFlush then
			pendingFlush:Disconnect()
			pendingFlush = nil
		end

		if state == stateSinceLastFlush then
			return
		end

		stateSinceLastFlush = state
		currentListeners = nextListeners

		local currentState = state

		for _, listener in currentListeners :: {} do
			task.spawn(listener, currentState)
		end
	end

	function producer:subscribe(...)
		local arguments = select("#", ...)
		local selector, predicate, listener

		if arguments >= 3 then
			selector, predicate, listener = ...
		elseif arguments == 2 then
			selector, listener = ...
		else
			listener = ...
		end

		local selection = self:getState(selector)

		if selector then
			testSelector(selector, selection, state)
		end

		return subscribe(function(nextState)
			local nextSelection = if selector then selector(nextState) else nextState

			if selection == nextSelection then
				return
			end

			local prevSelection = selection
			selection = nextSelection

			if predicate and not predicate(nextSelection, prevSelection) then
				return
			end

			listener(nextSelection, prevSelection)
		end)
	end

	function producer:once(...)
		local arguments = select("#", ...)
		local selector, predicate, listener

		if arguments >= 3 then
			selector, predicate, listener = ...
		elseif arguments == 2 then
			selector, listener = ...
		else
			listener = ...
		end

		local unsubscribe
		unsubscribe = self:subscribe(selector, predicate, function(state, prevState)
			unsubscribe()
			listener(state, prevState)
		end)

		return unsubscribe
	end

	function producer:wait(selector, predicate)
		return Promise.new(function(resolve, _, onCancel)
			local unsubscribe = self:once(selector, predicate, function(state)
				resolve(state)
			end)

			onCancel(unsubscribe)
		end)
	end

	function producer:observe(...)
		local arguments = select("#", ...)
		local selector, discriminator, observer

		if arguments >= 3 then
			selector, discriminator, observer = ...
		else
			selector, observer = ...
		end

		local idToCleanup = {}
		local selectDiffs = createSelectArrayDiffs(selector, discriminator)
		local connected = true

		local function checkDiffs(diffs)
			if not connected then
				return
			end

			for _, entry in diffs.deletions do
				local cleanup = idToCleanup[entry.id]

				if cleanup then
					idToCleanup[entry.id] = nil
					cleanup()
				end
			end

			for _, entry in diffs.additions do
				if not idToCleanup[entry.id] then
					idToCleanup[entry.id] = observer(entry.value, entry.key)
				end
			end
		end

		local unsubscribe = self:subscribe(selectDiffs, checkDiffs)

		checkDiffs(self:getState(selectDiffs))

		return function()
			connected = false
			unsubscribe()

			for _, cleanup in idToCleanup do
				cleanup()
			end

			table.clear(idToCleanup)
		end
	end

	function producer:observeWhile(...)
		local arguments = select("#", ...)
		local selector, predicate, observer

		if arguments >= 3 then
			selector, predicate, observer = ...
		else
			selector, observer = ...
		end

		local initialSelection = self:getState(selector)
		local connected = true
		local cleanup

		local function updateObserver(selection, lastSelection)
			if not connected then
				return
			end

			local shouldObserve = if predicate then predicate(selection, lastSelection) else selection

			if shouldObserve and not cleanup then
				cleanup = observer(selection)
			elseif not shouldObserve and cleanup then
				task.spawn(cleanup)
				cleanup = nil
			end
		end

		local unsubscribe = self:subscribe(selector, updateObserver)

		updateObserver(initialSelection, initialSelection)

		return function()
			connected = false
			unsubscribe()

			if cleanup then
				cleanup()
			end
		end
	end

	function producer:destroy()
		if pendingFlush then
			pendingFlush:Disconnect()
			pendingFlush = nil
		end

		if currentListeners then
			table.clear(currentListeners)
		end

		table.clear(nextListeners)
	end

	function producer:enhance(enhancer)
		return enhancer(self)
	end

	function producer:applyMiddleware(...)
		return self:enhance(applyMiddleware(...))
	end

	-- Support for APIs that require signal-like objects

	function producer:Connect(listener)
		local unsubscribe = self:subscribe(listener)
		return {
			Connected = true,
			Disconnect = function(self)
				self.Connected = false
				unsubscribe()
			end,
		}
	end

	function producer:Once(listener)
		local unsubscribe = self:once(listener)
		return {
			Connected = true,
			Disconnect = function(self)
				self.Connected = false
				unsubscribe()
			end,
		}
	end

	function producer:Wait()
		return self:wait(function(state)
			return state
		end):expect()
	end

	for name, action in actions do
		local function dispatch(...)
			state = action(state, ...)
			scheduleFlush()
			return state
		end

		dispatchers[name] = dispatch

		if not producer[name] then
			producer[name] = dispatch
		else
			warn(`Producer already has a property named {name}`)
		end
	end

	return producer
end

return createProducer
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="58">
              <Properties>
                <string name="Name">createSelector</string>
                <string name="Source"><![CDATA[type CreateSelectorFunction =
	(<Result, Arguments...>(
		dependencies: { (Arguments...) -> any },
		combiner: (...any) -> Result,
		equalityOrOptions: (MemoizeOptions<Result> | EqualityCheck<Result>)?
	) -> (Arguments...) -> Result)
	& (<Result, A, Arguments...>(
		a: (Arguments...) -> A,
		combiner: (A) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		combiner: (A, B) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		combiner: (A, B, C) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, D, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		d: (Arguments...) -> D,
		combiner: (A, B, C, D) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, D, E, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		d: (Arguments...) -> D,
		e: (Arguments...) -> E,
		combiner: (A, B, C, D, E) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, D, E, F, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		d: (Arguments...) -> D,
		e: (Arguments...) -> E,
		f: (Arguments...) -> F,
		combiner: (A, B, C, D, E, F) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (...(((...any) -> any) | MemoizeOptions<any>)) -> (...any) -> any

type EqualityCheck<T = any> = (current: T, previous: T) -> boolean

type MemoizeOptions<Result> = {
	--[=[
		The equality function used when comparing dependencies before calling
		the combiner. By default, a strict equality check is used.
	]=]
	equalityCheck: EqualityCheck?,

	--[=[
		The equality function used when comparing the result of the combiner
		to the previous value. If `true`, it will return the previous value
		of the combiner. By default, the latest result is always returned.
	]=]
	resultEqualityCheck: EqualityCheck<Result>?,
}

--[=[
	Memoizes a function by caching the result of the last call. Recomputes the
	result if any of the arguments have changed.
	@param callback The function to memoize.
	@param equalityCheck An optional equality function to use when
	comparing the arguments of the callback. By default, a strict equality
	check is used.
	@param resultEqualityCheck An optional equality function to use when comparing
	the result of the callback. By default, the latest result is always
	returned.
	@return A memoized function.
]=]
local function memoize(
	callback: (...any) -> any,
	equalityCheck: EqualityCheck?,
	resultEqualityCheck: EqualityCheck?
): (...any) -> any
	local lastArguments = {}
	local lastArgumentCount = -1
	local lastResult
	local firstRun = true

	return function(...)
		local argumentCount = select("#", ...)
		local result = lastResult

		if argumentCount ~= lastArgumentCount then
			result = callback(...)
			lastArgumentCount = argumentCount
			lastArguments = { ... }
		else
			for index = 1, argumentCount do
				local current = select(index, ...)
				local previous = lastArguments[index]

				if current ~= previous and (not equalityCheck or not equalityCheck(current, previous)) then
					result = callback(...)
					lastArguments = { ... }
					break
				end
			end
		end

		if not resultEqualityCheck then
			lastResult = result
			return result
		elseif firstRun or (lastResult ~= result and not resultEqualityCheck(result, lastResult)) then
			firstRun = false
			lastResult = result
		end

		return lastResult
	end
end

local function createSelectorImpl(...: ((...any) -> any) | MemoizeOptions<any>): (...any) -> any
	local arguments = table.pack(...)
	local dependencies, combiner, equalityOrOptions

	if type(...) == "table" then
		-- { ... }, combiner, equalityOrOptions
		dependencies, combiner, equalityOrOptions = ...
	elseif type(arguments[arguments.n]) == "table" then
		-- ..., combiner, options
		dependencies = table.create(arguments.n - 2)
		table.move(arguments, 1, arguments.n - 2, 1, dependencies)
		combiner, equalityOrOptions = arguments[arguments.n - 1], arguments[arguments.n]
	else
		-- ..., combiner
		dependencies = table.create(arguments.n - 1)
		table.move(arguments, 1, arguments.n - 1, 1, dependencies)
		combiner = arguments[arguments.n]
	end

	local options = if type(equalityOrOptions) == "function"
		then { equalityCheck = equalityOrOptions }
		else equalityOrOptions

	local resultEqualityCheck = options and options.resultEqualityCheck
	local equalityCheck = options and options.equalityCheck

	local dependencyCount = #dependencies
	local inputs = table.create(dependencyCount)
	local memoizedCombiner = memoize(combiner, equalityCheck, resultEqualityCheck)

	return memoize(function(...)
		for index = 1, dependencyCount do
			inputs[index] = dependencies[index](...)
		end

		return memoizedCombiner(table.unpack(inputs, 1, dependencyCount))
	end)
end

--[=[
	Creates a memoized selector function. The selector is only called if the
	outputs of the dependencies have changed.

	This function is only necessary if your selector is expensive to compute,
	or returns a new object (i.e. mapping an array). This is because selectors
	are called every state change, and if the selector returns a new object,
	the component will re-render even if the inputs haven't changed.

	@param dependencies A list of dependencies that the selector depends on.
	@param combiner A function that takes the dependencies as arguments and
	returns the result of the selector.
	@param options Options for memoizing the selector.
	@return A memoized selector function.
]=]
local createSelector: CreateSelectorFunction = createSelectorImpl :: any

return createSelector
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="59">
              <Properties>
                <string name="Name">createSelector.spec</string>
                <string name="Source"><![CDATA[return function()
	local createSelector = require(script.Parent.createSelector)

	local function selectFoo(state)
		return state.foo
	end

	local function selectBar(state)
		return state.bar
	end

	it("should return a function", function()
		local selector = createSelector({ selectFoo }, function() end)
		expect(selector).to.be.a("function")
	end)

	it("should return the selected state", function()
		local selector = createSelector({ selectFoo, selectBar }, function(foo, bar)
			return foo .. bar
		end)
		expect(selector({ foo = 1, bar = 2 })).to.equal("12")
	end)

	it("should memoize the result by comparing arguments", function()
		local selector = createSelector({ selectFoo, selectBar }, function(foo, bar)
			return {}
		end)
		local state = { foo = 1, bar = 2 }
		expect(selector(state)).to.equal(selector(state))
		expect(selector(state)).to.never.equal(selector({ foo = 3, bar = 4 }))
	end)

	it("should memoize the result by comparing dependencies", function()
		local selector = createSelector({ selectFoo, selectBar }, function(foo, bar)
			return {}
		end)
		expect(selector({ foo = 1, bar = 2 })).to.equal(selector({ foo = 1, bar = 2 }))
		expect(selector({ foo = 1, bar = 2 })).to.never.equal(selector({ foo = 3, bar = 4 }))
	end)

	it("should not call a dependency unless arguments have changed", function()
		local calls = 0

		local function dependency(state)
			calls += 1
			return state.foo
		end

		local selector = createSelector({ dependency }, function(foo)
			return foo
		end)

		local state = { foo = 1 }

		selector(state)
		selector(state)
		expect(calls).to.equal(1)

		selector({ foo = 1 })
		expect(calls).to.equal(2)
	end)

	it("should not call the selector unless dependencies have changed", function()
		local calls = 0

		local selector = createSelector({ selectFoo, selectBar }, function(foo, bar)
			calls += 1
		end)

		local state = { foo = 1, bar = 2 }

		selector(state)
		selector(state) -- should not call deps
		expect(calls).to.equal(1)

		selector({ foo = 1, bar = 2 }) -- should call deps, but not selector
		expect(calls).to.equal(1)

		selector({ foo = 3, bar = 4 }) -- should call deps and selector
		expect(calls).to.equal(2)
	end)

	it("should allow nil dependencies and keep order", function()
		local selector = createSelector({ selectFoo, selectBar }, function(foo, bar)
			return (foo or "nil") .. (bar or "nil")
		end)
		expect(selector({ foo = 1, bar = 2 })).to.equal("12")
		expect(selector({ foo = 1 })).to.equal("1nil")
		expect(selector({ foo = 1, bar = 2 })).to.equal("12")
		expect(selector({ bar = 2 })).to.equal("nil2")
		expect(selector({})).to.equal("nilnil")
		expect(selector({ foo = 1, bar = 2 })).to.equal("12")
	end)

	it("should allow nil arguments and keep order", function()
		local calls = 0
		local value

		local function dependency(a, b, c)
			return (a or "nil") .. (b or "nil") .. (c or "nil")
		end

		local selector = createSelector({ dependency }, function(value)
			calls += 1
			return value
		end)

		-- two calls with nil arguments should trigger one call
		value = selector()
		selector()
		expect(value).to.equal("nilnilnil")
		expect(calls).to.equal(1)

		-- an argument going from nil to non-nil should trigger a call
		value = selector(nil, 1, nil)
		selector(nil, 1, nil)
		expect(value).to.equal("nil1nil")
		expect(calls).to.equal(2)

		-- an argument going from non-nil to nil should trigger a call
		value = selector(nil, nil, nil)
		selector(nil, nil, nil)
		expect(value).to.equal("nilnilnil")
		expect(calls).to.equal(3)

		-- the location of the nil argument should not matter
		value = selector(1, nil, 1)
		selector(1, nil, 1)
		expect(value).to.equal("1nil1")
		expect(calls).to.equal(4)

		value = selector(1, 1, nil)
		selector(1, 1, nil)
		expect(value).to.equal("11nil")
		expect(calls).to.equal(5)
	end)

	it("should receive an equalityCheck option", function()
		local current, previous

		local selector = createSelector({ selectFoo }, function(foo)
			return { value = foo.value }
		end, {
			equalityCheck = function(a, b)
				return a.value == b.value
			end,
		})

		current, previous = selector({ foo = { value = 1 } }), nil
		expect(current).to.be.a("table")
		expect(current.value).to.equal(1)

		current, previous = selector({ foo = { value = 1 } }), current
		expect(current).to.equal(previous)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.never.equal(previous)
		expect(current.value).to.equal(2)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.equal(previous)
	end)

	it("should receive a resultEqualityCheck option", function()
		local current, previous

		local selector = createSelector({ selectFoo }, function(foo)
			return { value = foo.value }
		end, {
			resultEqualityCheck = function(a, b)
				return a.value == b.value
			end,
		})

		current, previous = selector({ foo = { value = 1 } }), nil
		expect(current).to.be.a("table")
		expect(current.value).to.equal(1)

		current, previous = selector({ foo = { value = 1 } }), current
		expect(current).to.equal(previous)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.never.equal(previous)
		expect(current.value).to.equal(2)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.equal(previous)
	end)

	it("should receive an equalityCheck as options", function()
		local current, previous

		local selector = createSelector({ selectFoo }, function(foo)
			return { value = foo.value }
		end, function(a, b)
			return a.value == b.value
		end)

		current, previous = selector({ foo = { value = 1 } }), nil
		expect(current).to.be.a("table")
		expect(current.value).to.equal(1)

		current, previous = selector({ foo = { value = 1 } }), current
		expect(current).to.equal(previous)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.never.equal(previous)
		expect(current.value).to.equal(2)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.equal(previous)
	end)

	it("should receive dependencies directly as parameters", function()
		local current, previous

		local selector = createSelector(selectFoo, selectBar, function(foo, bar)
			return { value = foo + bar }
		end)

		current, previous = selector({ foo = 1, bar = 1 }), nil
		expect(current).to.be.a("table")
		expect(current.value).to.equal(2)

		current, previous = selector({ foo = 1, bar = 1 }), current
		expect(current).to.equal(previous)

		current, previous = selector({ foo = 2, bar = 1 }), current
		expect(current).to.never.equal(previous)
		expect(current.value).to.equal(3)

		current, previous = selector({ foo = 2, bar = 1 }), current
		expect(current).to.equal(previous)

		current, previous = selector({ foo = 2, bar = 2 }), current
		expect(current).to.never.equal(previous)
		expect(current.value).to.equal(4)
	end)

	it("should receive equality options when passing dependencies directly", function()
		local current, previous

		local selector = createSelector(selectFoo, selectBar, function(foo, bar)
			return { value = foo.value }
		end, {
			resultEqualityCheck = function(a, b)
				return a.value == b.value
			end,
		})

		current, previous = selector({ foo = { value = 1 } }), nil
		expect(current).to.be.a("table")
		expect(current.value).to.equal(1)

		current, previous = selector({ foo = { value = 1 } }), current
		expect(current).to.equal(previous)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.never.equal(previous)
		expect(current.value).to.equal(2)

		current, previous = selector({ foo = { value = 2 } }), current
		expect(current).to.equal(previous)
	end)
end
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="60">
              <Properties>
                <string name="Name">middleware</string>
              </Properties>
              <Item class="ModuleScript" referent="61">
                <Properties>
                  <string name="Name">loggerMiddleware</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local function stringify(value: unknown, _depth: number?): string
	local depth = _depth or 0

	if type(value) == "string" then
		return string.format("%q", value)
	elseif type(value) == "table" and depth < 2 then
		local result = "{"

		for k, v in value :: {} do
			result ..= "[" .. stringify(k, depth + 1) .. "] = " .. stringify(v, depth + 1) .. ", "
		end

		return result .. "}"
	else
		return tostring(value)
	end
end

--[=[
	A middleware that logs every action that is dispatched, and the new state
	after the action is handled.
]=]
local loggerMiddleware: types.Middleware = function(producer)
	print("[Reflex]: Mounted with state", producer:getState())

	producer:subscribe(function(state)
		print("[Reflex]: State changed to", state)
	end)

	return function(dispatch, name)
		return function(...)
			local arguments = table.pack(...)

			for index = 1, arguments.n do
				arguments[index] = stringify(arguments[index])
			end

			print(`[Reflex]: Dispatching {name}({table.concat(arguments, ", ")})`)

			return dispatch(...)
		end
	end
end

return loggerMiddleware
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="62">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[--[=[
	A Producer is a state container that exposes a set of dispatchers that can
	be used to modify the state. The state is immmutable, so dispatchers return
	a new state object.
]=]
export type Producer<State = any, Dispatchers = { [string]: (...any) -> State }> = Dispatchers & {
	--[=[
		Returns the current state of the producer. Receives an optional selector
		function that can be used to select a subset of the state.
		@param selector An optional selector function that can be used to select
		a subset of the state.
		@return The current state of the producer.
	]=]
	getState: ((self: Producer<State, Dispatchers>) -> State)
		& (<Selection>(self: Producer<State, Dispatchers>, selector: (state: State) -> Selection) -> Selection),

	--[=[
		Sets the state of the producer to a shallow copy of the given state.
		Fires listeners on the next frame.
		@param state The new state of the producer.
	]=]
	setState: (self: Producer<State, Dispatchers>, state: State) -> (),

	--[=[
		Resets the state of the producer to the initial state. Fires listeners
		on the next frame if the state has changed.
	]=]
	resetState: (self: Producer<State, Dispatchers>) -> (),

	--[=[
		Returns the dispatchers for the actions passed to `createProducer`.
		@return A map of dispatchers.
	]=]
	getDispatchers: (self: Producer<State, Dispatchers>) -> Dispatchers,

	--[=[
		Returns the original action functions passed to `createProducer`.
		@return A map of action functions.
	]=]
	getActions: (self: Producer<State, Dispatchers>) -> {
		[string]: (state: State, ...any) -> any,
	},

	--[=[
		Returns a distinct copy of the producer. The new copy starts with the
		same state and actions, but functions independently.
	]=]
	clone: (self: Producer<State, Dispatchers>) -> Producer<State, Dispatchers>,

	--[=[
		Flushes any pending updates by calling listeners immediately.
	]=]
	flush: (self: Producer<State, Dispatchers>) -> (),

	--[=[
		Subscribes to changes in a specific part of the state. State updates
		are deferred until the next frame after all state updates have been
		processed.
		@param selector A selector function that can be used to select a subset
		of the state.
		@param predicate An optional predicate function that must return `true`
		for the listener to be called.
		@param listener A callback that is called when the selected part of the
		state changes.
		@return A function that can be used to unsubscribe from the listener.
	]=]
	subscribe: ((self: Producer<State, Dispatchers>, listener: (state: State, prevState: State) -> ()) -> () -> ())
		& (<Selection>(
			self: Producer<State, Dispatchers>,
			selector: (state: State) -> Selection,
			listener: (state: Selection, prevState: Selection) -> ()
		) -> () -> ())
		& <Selection>(
			self: Producer<State, Dispatchers>,
			selector: (state: State) -> Selection,
			predicate: (state: Selection, prevState: Selection) -> boolean,
			listener: (state: Selection, prevState: Selection) -> ()
		) -> () -> (),

	--[=[
		Similar to `subscribe`, but the listener is disconnect after the first
		time it is called.
		@param selector A selector function that can be used to select a subset
		of the state.
		@param predicate An optional predicate function that must return `true`
		for the listener to be called.
		@param listener A callback that is called when the selected part of the
		state changes.
		@return A function that can be used to unsubscribe from the listener.
	]=]
	once: (<Selection>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> Selection,
		listener: (state: Selection, prevState: Selection) -> ()
	) -> () -> ()) & <Selection>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> Selection,
		predicate: ((state: Selection, prevState: Selection) -> boolean)?,
		listener: (state: Selection, prevState: Selection) -> ()
	) -> () -> (),

	--[=[
		Returns a Promise that resolves once a specific part of the state changes.
		Unsubscribes the listener if the Promise is cancelled or resolved.

		Receives an optional `predicate` function that must return `true` for the
		Promise to resolve for a given state change.

		@param selector A selector function that can be used to select a subset
		of the state.
		@param predicate An optional predicate function that must return `true`
		for the Promise to resolve for a given state change.
		@return A Promise that resolves once the selected part of the state changes.
	]=]
	wait: <Selection>(
		self: Producer<State, Dispatchers>,
		selector: ((state: State) -> Selection)?,
		predicate: ((state: Selection, prevState: Selection) -> boolean)?
	) -> any,

	--[=[
		Tracks the addition and removal of items in an array. Calls the given
		observer for each added item and calls the cleanup function when the
		item is removed.

		If your array contains immutable objects, you can use the `discriminator`
		argument to return a unique identifier for each item. This allows the
		observer to avoid calling the observer for items that have already been
		added.

		@param selector The selector to track.
		@param discriminator Optional function that returns a unique identifier for
		each item. Useful when tracking immutable objects.
		@param observer The observer to call when an item is added. Returns a
		function that is called when the item is removed.
		@return An observer that calls the given observer for each added item and
		unsubscribes when the item is removed.
	]=]
	observe: (<K, V>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> { [K]: V },
		discriminator: ((item: V, index: K) -> unknown)?,
		observer: (item: V, index: K) -> (() -> ())?
	) -> () -> ()) & (<K, V>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> { [K]: V },
		observer: (item: V, index: K) -> (() -> ())?
	) -> () -> ()),

	--[=[
		Similar to `observe`, but it creates one observer while a selector or
		predicate is truthy, and destroys the observer when it's no longer truthy.
		@param selector The selector to track.
		@param predicate An optional predicate function that must return `true`
		for the observer to be created.
		@param observer The observer to call when the selector is truthy. Returns
		a function that is called when the selector is falsy.
		@return A cleanup function that removes all observers.
	]=]
	observeWhile: (<T>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> T,
		predicate: (state: T, prevState: T) -> boolean,
		observer: (state: T) -> (() -> ())?
	) -> () -> ()) & (<T>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> T?,
		observer: (state: T) -> (() -> ())?
	) -> () -> ()),

	--[=[
		Disconnects all listeners and cancels all pending flushes.
	]=]
	destroy: (self: Producer<State, Dispatchers>) -> (),

	--[=[
		Enhances the producer with new functionality. The enhancer function
		is passed to the producer as an argument and should mutate the producer
		in place.
		@deprecated Use `applyMiddleware` instead.
		@param enhancer A function that mutates the producer.
		@return The enhanced producer.
	]=]
	enhance: <Enhanced>(self: Producer<State, Dispatchers>, enhancer: (producer: any) -> Enhanced) -> Enhanced,

	--[=[
		Applies the given middlewares to the producer and its dispatchers. Returns
		the producer for chaining.

		Initially, a middleware is called once when it is applied to a producer.
		Next, the returned function is called on a dispatcher in the producer.
		The final function is called whenever the dispatcher is called.

		```lua
		local loggerMiddleware: Reflex.Middleware = function(producer)
			print("Initial state:", producer.getState())
			return function(dispatch, name)
				return function(...)
					print(`Dispatching {name}:`, ...args)
					return dispatch(...)
				end
			end
		end

		producer:applyMiddleware(loggerMiddleware)
		```

		@param middlewares A list of middleware to apply.
		@return The producer.
	]=]
	applyMiddleware: (
		self: Producer<State, Dispatchers>,
		...(producer: any) -> (dispatch: (...any) -> any, name: string) -> (...any) -> any
	) -> Producer<State, Dispatchers>,
}

--[=[
	A middleware is a function that is called before an action is dispatched.

	Initially, a middleware is called once when it is applied to a producer.
	Next, the returned function is called on a dispatcher in the producer.
	The final function is called whenever that dispatcher is called.
]=]
export type Middleware = (producer: Producer) -> (dispatch: (...any) -> any, name: string) -> (...any) -> any

export type ProducerMap = { [string]: Producer }

--[=[
	A container for storing a Reflex dispatcher's name and arguments.
]=]
export type BroadcastAction = {
	name: string,
	arguments: {},
}

--[=[
	Options for the broadcast middleware.
]=]
export type BroadcasterOptions = {
	--[=[
		The producers that will be tracked.
	]=]
	producers: ProducerMap,

	--[=[
		The rate in seconds at which the server should hydrate the
		clients with the latest state.
		@default 60
	]=]
	hydrateRate: number?,

	--[=[
		The rate in seconds at which the server should dispatch
		actions to the clients. If set to `0`, actions will be
		dispatched within the next frame.
		@default 0
	]=]
	dispatchRate: number?,

	--[=[
		Runs before actions are dispatched to a player. Can be used to
		filter actions or manipulate them before sending.

		Avoid directly mutating the action. Instead, return a new action
		if you need to change it. Return `nil` to not share the action
		with this player.
	]=]
	beforeDispatch: ((player: Player, action: BroadcastAction) -> BroadcastAction?)?,

	--[=[
		Runs before the client is hydrated with the latest state. Can be
		used to filter the state or hide certain values from the client.

		Do not mutate the state in this function! Treat it as a read-only
		object, and return a new object if you need to change it.
	]=]
	beforeHydrate: ((player: Player, state: { [string]: any }) -> { [string]: any })?,

	--[=[
		An optional custom hydration function. If provided, this function
		will be called instead of being implicitly handled in 'dispatch'.

		Useful for reducing load on a single remote if your state is large.
	]=]
	hydrate: ((player: Player, state: { [string]: any }) -> ())?,

	--[=[
		The function that will send the actions to the client.
	]=]
	dispatch: (player: Player, actions: { BroadcastAction }) -> (),
}

--[=[
	Options for the broadcast receiver.
]=]
export type BroadcastReceiverOptions = {
	--[=[
		A function that, when called, should fire a remote that calls
		`start(player)` on the server broadcaster.
	]=]
	start: () -> any,
}

--[=[
	A broadcaster that can be used to share actions with the client.
]=]
export type Broadcaster = {
	--[=[
		The middleware that will broadcast actions to the client.
	]=]
	middleware: Middleware,

	--[=[
		Starts broadcasting state and actions to the given player.
	]=]
	start: (self: Broadcaster, player: Player) -> (),

	--[=[
		Disconnects all listeners and cancels all pending dispatches.
	]=]
	destroy: (self: Broadcaster) -> (),
}

--[=[
	A receiver that can be used to dispatch actions broadcasted by the server.
]=]
export type BroadcastReceiver = {
	--[=[
		A middleware that should be applied to the root producer. This will
		merge the producer's state with the server's state on join.
	]=]
	middleware: Middleware,

	--[=[
		Dispatches actions broadcasted by the server.
	]=]
	dispatch: (self: BroadcastReceiver, actions: { BroadcastAction }) -> (),

	--[=[
		Hydrates the client with the latest state from the server.
		Normally, hydration is implicitly handled in 'dispatch' unless a
		custom hydration handler is provided in the broadcaster options.

		Useful for reducing load on a single remote if your state is large.
	]=]
	hydrate: (self: BroadcastReceiver, state: { [string]: any }) -> (),
}

return nil
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="63">
              <Properties>
                <string name="Name">utils</string>
              </Properties>
              <Item class="ModuleScript" referent="64">
                <Properties>
                  <string name="Name">createSelectArrayDiffs</string>
                  <string name="Source"><![CDATA[--!strict
local createSelector = require(script.Parent.Parent.createSelector)

type ArrayDiffs<K, V> = {
	additions: { Entry<K, V> },
	deletions: { Entry<K, V> },
}

type Entry<K, V> = {
	key: K,
	value: V,
	id: unknown,
}

--[=[
	Tracks the addition and removal of items in an array. Creates a selector that
	returns an object containing the additions and deletions since the last update.

	If your array contains immutable objects, you can use the `discriminator`
	argument to return a unique identifier for each item. This prevents excessive
	re-renders when an item is updated but not added or removed.

	@param selector The selector to track.
	@param discriminator A function that returns a unique identifier for each
	item. Useful when tracking immutable objects.
	@returns A selector that returns an object containing the additions and
	deletions since the last update.
]=]
local function createSelectArrayDiffs<State, K, V>(
	selector: (state: State) -> { [K]: V },
	discriminator: ((item: V, index: K) -> unknown)?
): (state: State) -> ArrayDiffs<K, V>
	local lastEntries: { [unknown]: Entry<K, V> } = {}

	return createSelector(selector, function(items: { [K]: V })
		local additions: { Entry<K, V> } = {}
		local deletions: { Entry<K, V> } = {}
		local entries: { [unknown]: Entry<K, V> } = {}

		for key, item in items do
			local id = if discriminator then discriminator(item, key) else item
			local entry = { key = key, value = item, id = id }

			assert(id ~= nil, "Discriminator returned a nil value")

			if not lastEntries[id] then
				table.insert(additions, entry)
			end

			entries[id] = entry
		end

		for id, item in lastEntries do
			if not entries[id] then
				local entry = lastEntries[id]
				table.insert(deletions, entry)
			end
		end

		lastEntries = entries

		return {
			additions = additions,
			deletions = deletions,
		}
	end)
end

return createSelectArrayDiffs
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="65">
                <Properties>
                  <string name="Name">createSelectArrayDiffs.spec</string>
                  <string name="Source"><![CDATA[return function()
	local createSelectArrayDiffs = require(script.Parent.createSelectArrayDiffs)

	local function forward(state)
		return state
	end

	local function discriminator(item)
		return item.id
	end

	local function new(id)
		return { id = id }
	end

	local function hasEntry(items, id, key)
		for _, item in ipairs(items) do
			if item.id == id and (key == nil or key == item.key) then
				return true
			end
		end

		return false
	end

	it("should return initial additions and deletions", function()
		local selector = createSelectArrayDiffs(forward)
		local diffs = selector({ 1, 2, 3 })
		expect(diffs.additions).to.be.a("table")
		expect(diffs.deletions).to.be.a("table")
		expect(hasEntry(diffs.additions, 1)).to.equal(true)
		expect(hasEntry(diffs.additions, 2)).to.equal(true)
		expect(hasEntry(diffs.additions, 3)).to.equal(true)
		expect(#diffs.deletions).to.equal(0)
	end)

	it("should track additions and deletions", function()
		local selector = createSelectArrayDiffs(forward)

		local diffs = selector({ a = 1, b = 2, c = 3 })
		expect(hasEntry(diffs.additions, 1, "a")).to.equal(true)
		expect(hasEntry(diffs.additions, 2, "b")).to.equal(true)
		expect(hasEntry(diffs.additions, 3, "c")).to.equal(true)
		expect(#diffs.deletions).to.equal(0)

		diffs = selector({ a = 1, x = 10, c = 3 })
		expect(hasEntry(diffs.additions, 10, "x")).to.equal(true)
		expect(hasEntry(diffs.deletions, 2, "b")).to.equal(true)
	end)

	it("should receive a discriminator parameter", function()
		local selector = createSelectArrayDiffs(forward, discriminator)

		local diffs = selector({ new(1), new(2), new(3) })
		expect(#diffs.additions).to.equal(3)
		expect(#diffs.deletions).to.equal(0)
		expect(diffs.additions[1].value.id).to.equal(1)
		expect(diffs.additions[2].value.id).to.equal(2)
		expect(diffs.additions[3].value.id).to.equal(3)

		diffs = selector({ new(1), new(3), new(4) })
		expect(#diffs.additions).to.equal(1)
		expect(#diffs.deletions).to.equal(1)
		expect(diffs.additions[1].value.id).to.equal(4)
		expect(diffs.deletions[1].value.id).to.equal(2)
	end)

	it("should track new items with the same discriminator", function()
		local selector = createSelectArrayDiffs(forward, discriminator)

		local diffs = selector({ new(1), new(2), new(3) })
		expect(#diffs.additions).to.equal(3)
		expect(#diffs.deletions).to.equal(0)

		diffs = selector({ new(1), new(2), new(3) })
		expect(#diffs.additions).to.equal(0)
		expect(#diffs.deletions).to.equal(0)
	end)

	it("should allow tracking items by index", function()
		local function discriminator(item, index)
			return index
		end

		local selector = createSelectArrayDiffs(forward, discriminator)

		local diffs = selector({ 1, 2, 3 })
		expect(hasEntry(diffs.additions, 1, 1)).to.equal(true)
		expect(hasEntry(diffs.additions, 2, 2)).to.equal(true)
		expect(hasEntry(diffs.additions, 3, 3)).to.equal(true)

		diffs = selector({ 1, 2, 3, 4 })
		expect(hasEntry(diffs.additions, 4, 4)).to.equal(true)
		expect(#diffs.deletions).to.equal(0)

		-- removing the fourth item should trigger a deletion of 4
		-- because that index is no longer in the array
		diffs = selector({ 1, 3, 4 })
		expect(hasEntry(diffs.deletions, 4, 4)).to.equal(true)
		expect(#diffs.additions).to.equal(0)
	end)

	it("should pass the correct index", function()
		local keys = {}

		local function discriminator(item, index)
			table.insert(keys, index)
			return index
		end

		local selector = createSelectArrayDiffs(forward, discriminator)

		selector({ a = 1, b = 2, c = 3 })
		selector({})

		expect(table.find(keys, "a")).to.be.ok()
		expect(table.find(keys, "b")).to.be.ok()
		expect(table.find(keys, "c")).to.be.ok()

		expect(table.find(keys, 1)).to.never.be.ok()
		expect(table.find(keys, 2)).to.never.be.ok()
		expect(table.find(keys, 3)).to.never.be.ok()
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="66">
                <Properties>
                  <string name="Name">setInterval</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local function setInterval(callback: () -> (), interval: number): () -> ()
	if interval < 0 then
		return function() end
	end

	local timer = 0
	local connection

	connection = RunService.Heartbeat:Connect(function(dt)
		timer += dt

		if timer >= interval then
			timer -= interval
			callback()
		end
	end)

	return function()
		connection:Disconnect()
	end
end

return setInterval
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="67">
                <Properties>
                  <string name="Name">shallowEqual</string>
                  <string name="Source"><![CDATA[--[=[
	Returns whether or not two tables are shallowly equal, or in other words,
	have the same set of key-value pairs.
	@param a The first table to compare.
	@param b The second table to compare.
	@returns Whether or not the tables are shallowly equal.
]=]
local function shallowEqual(a: any, b: any): boolean
	if a == b then
		return true
	end

	if type(a) ~= "table" or type(b) ~= "table" then
		return false
	end

	for key, value in a do
		if b[key] ~= value then
			return false
		end
	end

	for key, value in b do
		if a[key] ~= value then
			return false
		end
	end

	return true
end

return shallowEqual
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="68">
                <Properties>
                  <string name="Name">shallowEqual.spec</string>
                  <string name="Source"><![CDATA[return function()
	local shallowEqual = require(script.Parent.shallowEqual)

	it("should return true when tables are equal", function()
		local value = {}
		expect(shallowEqual(value, value)).to.equal(true)
	end)

	it("should return true when both tables are empty", function()
		expect(shallowEqual({}, {})).to.equal(true)
	end)

	it("should return true when tables have the same key-value pairs", function()
		expect(shallowEqual({ foo = 1 }, { foo = 1 })).to.equal(true)
		expect(shallowEqual({ bar = 1, baz = 2 }, { bar = 1, baz = 2 })).to.equal(true)
	end)

	it("should return false when tables have different key-value pairs", function()
		expect(shallowEqual({ foo = 1 }, { foo = 2 })).to.equal(false)
	end)

	it("should return false when tables have different keys", function()
		expect(shallowEqual({ foo = 1 }, { bar = 1 })).to.equal(false)
		expect(shallowEqual({ foo = 1 }, { foo = 1, bar = 1 })).to.equal(false)
		expect(shallowEqual({ foo = 1, bar = 1 }, { foo = 1 })).to.equal(false)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="69">
                <Properties>
                  <string name="Name">testSelector</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local IS_STUDIO = RunService:IsStudio()
local TEST_WARNING = [[
Reflex detected a selector function that returns conflicting values for the same input!
This is likely caused by one of the following:

- The selector function is not memoized and should use 'createSelector'
- The selector function is memoized but is not idempotent

Learn more about writing selectors here:
https://littensy.github.io/reflex/docs/guides/using-selectors

%s]]

--[=[
	Tests a selector function's memoization. If the selector function is not
	memoized, it will output a warning in Roblox Studio.
	@param selector The selector function to test.
	@param expectedValue The expected value of the selector function.
	@param ... The arguments to pass to the selector function.
	@returns Whether the test passed.
]=]
local function testSelector<T, U...>(selector: (U...) -> T, expectedValue: T, ...: U...)
	if selector(...) == expectedValue then
		return true
	end

	if IS_STUDIO then
		local traceback = debug.traceback("Function traceback", 2)
		warn(string.format(TEST_WARNING, traceback))
	end

	return false
end

return testSelector
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="70">
                <Properties>
                  <string name="Name">testSelector.spec</string>
                  <string name="Source"><![CDATA[return function()
	local testSelector = require(script.Parent.testSelector)

	it("should return false if the selector is not memoized", function()
		local value = {}
		local function badSelector(state)
			return {}
		end
		expect(testSelector(badSelector, value, { value = value })).to.equal(false)
	end)

	it("should return true if the selector is memoized", function()
		local value = {}
		local function goodSelector(state)
			return state.value
		end
		expect(testSelector(goodSelector, value, { value = value })).to.equal(true)
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="71">
          <Properties>
            <string name="Name">littensy_remo@1.5.2</string>
          </Properties>
          <Item class="ModuleScript" referent="72">
            <Properties>
              <string name="Name">Promise</string>
              <string name="Source">local module = require(script.Parent.Parent["evaera_promise@4.0.0"]["promise"])
return module</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="73">
            <Properties>
              <string name="Name">remo</string>
              <string name="Source"><![CDATA[local Promise = require(script.Promise)
local types = require(script.types)
local createRemotes = require(script.createRemotes)
local builder = require(script.builder)
local getSender = require(script.getSender)
local loggerMiddleware = require(script.middleware.loggerMiddleware)
local throttleMiddleware = require(script.middleware.throttleMiddleware)

export type Promise<T> = Promise.Promise<T>
export type PromiseConstructor = Promise.PromiseConstructor

export type Middleware = types.Middleware

export type RemoteBuilder = types.RemoteBuilder
export type RemoteBuilderMetadata = types.RemoteBuilderMetadata
export type RemoteBuilders = types.RemoteBuilders

export type Remotes<Map> = types.Remotes<Map>
export type RemoteMap = types.RemoteMap
export type RemoteType = "event" | "function"

export type Remote<Args... = ...any> = types.Remote<Args...>
export type ClientToServer<Args... = ...any> = types.ClientToServer<Args...>
export type ServerToClient<Args... = ...any> = types.ServerToClient<Args...>

export type AsyncRemote<Args... = ...any, Returns... = ...any> = types.AsyncRemote<Args..., Returns...>
export type ServerAsync<Args... = ...any, Returns... = ...any> = types.ServerAsync<Args..., Returns...>
export type ClientAsync<Args... = ...any, Returns... = ...any> = types.ClientAsync<Args..., Returns...>

--- @deprecated 1.2, use `ServerAsync` instead.
export type ClientToServerAsync<Returns = any, Args... = ...any> = types.ServerAsync<Args..., (Returns)>

--- @deprecated 1.2, use `ClientAsync` instead.
export type ServerToClientAsync<Returns = any, Args... = ...any> = types.ClientAsync<Args..., (Returns)>

return {
	remote = builder.remote,
	namespace = builder.namespace,
	createRemotes = createRemotes,
	loggerMiddleware = loggerMiddleware,
	throttleMiddleware = throttleMiddleware,
	getSender = getSender,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="74">
              <Properties>
                <string name="Name">Promise</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local include = script:FindFirstAncestor("rbxts_include")
	or script:FindFirstAncestor("include")
	or ReplicatedStorage:FindFirstChild("rbxts_include")
	or script.Parent.Parent

export type PromiseStatus = "Started" | "Resolved" | "Rejected" | "Cancelled"

export type PromiseConstructor = {
	Status: {
		Started: "Started",
		Resolved: "Resolved",
		Rejected: "Rejected",
		Cancelled: "Cancelled",
	},
	new: <T...>(
		resolver: (resolve: (T...) -> (), reject: (any) -> (), onCancel: (abortHandler: () -> ()) -> ()) -> ()
	) -> Promise<T...>,
	defer: <T...>(
		resolver: (resolve: (T...) -> (), reject: (any) -> (), onCancel: (abortHandler: () -> ()) -> ()) -> ()
	) -> Promise<T...>,
	resolve: <T>(value: T | Promise<T>, ...any) -> Promise<T>,
	reject: (value: any) -> Promise<never>,
	try: <T, A...>(callback: (A...) -> T, A...) -> Promise<T>,
	all: <T>(promises: { Promise<T> }) -> Promise<{ T }>,
	fold: <T, U>(
		promises: { T | Promise<T> },
		reducer: (U, T, number) -> U | Promise<U>,
		initialValue: U
	) -> Promise<U>,
	some: <T>(promises: { Promise<T> }, count: number) -> Promise<{ T }>,
	any: <T>(promises: { Promise<T> }) -> Promise<T>,
	allSettled: (promises: { Promise<any> }) -> Promise<{ PromiseStatus }>,
	race: <T>(promises: { Promise<T> }) -> Promise<T>,
	each: <T, U>(list: { T | Promise<T> }, predicate: (T, number) -> U | Promise<U>) -> Promise<{ U }>,
	is: (value: any) -> boolean,
	promisify: <R, A...>(fn: (A...) -> R) -> (A...) -> Promise<R>,
	delay: (seconds: number) -> Promise<number>,
	fromEvent: <T>(event: RBXScriptSignal<T>, predicate: ((T) -> boolean)?) -> Promise<T>,
}

export type _Promise = {
	timeout: (self: _Promise, seconds: number, rejectionValue: unknown) -> _Promise,
	getStatus: (self: _Promise) -> PromiseStatus,
	andThen: (self: _Promise, successHandler: (...any) -> any, failureHandler: ((any) -> any)?) -> _Promise,
	catch: (self: _Promise, failureHandler: (...any) -> any) -> _Promise,
	tap: (self: _Promise, successHandler: (...any) -> ()) -> _Promise,
	andThenCall: <T...>(self: _Promise, successHandler: (T...) -> any, T...) -> _Promise,
	andThenReturn: (self: _Promise, value: any) -> _Promise,
	cancel: (self: _Promise) -> (),
	finally: (self: _Promise, callback: (status: PromiseStatus) -> any) -> _Promise,
	finallyCall: <T...>(self: _Promise, callback: (T...) -> any, T...) -> _Promise,
	finallyReturn: (self: _Promise, value: any) -> _Promise,
	awaitStatus: (self: _Promise) -> (PromiseStatus, ...any),
	await: (self: _Promise) -> (boolean, ...any),
	expect: (self: _Promise) -> ...any,
	now: (self: _Promise, rejectionValue: unknown) -> _Promise,
}

export type Promise<T... = ...any> = {
	timeout: (self: Promise<T...>, seconds: number, rejectionValue: unknown) -> Promise<T...>,
	getStatus: (self: Promise<T...>) -> PromiseStatus,
	andThen: (self: Promise<T...>, successHandler: (T...) -> (), failureHandler: ((...any) -> ())?) -> _Promise,
	catch: (self: Promise<T...>, failureHandler: (any) -> ()) -> Promise<T...>,
	tap: (self: Promise<T...>, successHandler: (T...) -> ()) -> Promise<T...>,
	andThenCall: <U...>(self: Promise<T...>, successHandler: (U...) -> (), U...) -> Promise<T...>,
	andThenReturn: (self: Promise<T...>, value: any) -> _Promise,
	cancel: (self: Promise<T...>) -> (),
	finally: (self: Promise<T...>, callback: (status: PromiseStatus) -> ()) -> _Promise,
	finallyCall: <U...>(self: Promise<T...>, callback: (U...) -> (), U...) -> _Promise,
	finallyReturn: (self: Promise<T...>, value: any) -> _Promise,
	awaitStatus: (self: Promise<T...>) -> (PromiseStatus, T...),
	await: (self: Promise<T...>) -> (boolean, T...),
	expect: (self: Promise<T...>) -> T...,
	now: (self: Promise<T...>, rejectionValue: unknown) -> Promise<T...>,
}

if include and include:FindFirstChild("Promise") then
	return require(include.Promise) :: PromiseConstructor
else
	error(`Could not find Promise from {script:GetFullName()}`)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="75">
              <Properties>
                <string name="Name">builder</string>
                <string name="Source"><![CDATA[local types = require(script.Parent.types)

local function remote(...: types.Validator): types.RemoteBuilder
	local metadata: types.RemoteBuilderMetadata = {
		parameters = { ... },
		returns = {},
		middleware = {},
		unreliable = false,
	}

	local self = {
		type = "event",
		metadata = metadata,
	} :: types.RemoteBuilder

	function self.returns(...)
		self.type = "function"
		metadata.returns = { ... }
		return self
	end

	function self.middleware(...)
		for index = 1, select("#", ...) do
			table.insert(metadata.middleware, (select(index, ...)))
		end
		return self
	end

	function self.unreliable()
		metadata.unreliable = true
		return self
	end

	return self
end

local function namespace(remotes: types.RemoteBuilders): types.RemoteNamespace
	return {
		type = "namespace",
		remotes = remotes,
	}
end

return {
	remote = remote,
	namespace = namespace,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="76">
              <Properties>
                <string name="Name">client</string>
                <string name="Source"><![CDATA[local types = require(script.Parent.types)
local createAsyncRemote = require(script.createAsyncRemote)
local createRemote = require(script.createRemote)

local function createRemotes(builders: types.RemoteBuilders, namespace: string?): types.RemoteMap
	local remotes: types.RemoteMap = {}
	local scope = if namespace then `{namespace}.` else ""

	for name, builder in builders do
		remotes[name] = if builder.type == "namespace"
			then createRemotes(builder.remotes, scope .. name)
			elseif builder.type == "event" then createRemote(scope .. name, builder)
			elseif builder.type == "function" then createAsyncRemote(scope .. name, builder)
			else error(`Invalid remote type "{builder.type}"`)
	end

	return remotes
end

return {
	createRemotes = createRemotes,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="77">
                <Properties>
                  <string name="Name">createAsyncRemote</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local compose = require(script.Parent.Parent.utils.compose)
local instances = require(script.Parent.Parent.utils.instances)
local unwrap = require(script.Parent.Parent.utils.unwrap)
local testRemote = require(script.Parent.Parent.utils.testRemote)

local function createAsyncRemote(name: string, builder: types.RemoteBuilder): types.AsyncRemote
	local test = testRemote.createTestAsyncRemote()
	local connected = true
	local handler = function() end :: (...any) -> ()

	local self = {
		name = name,
		type = "function",
		test = test,
	} :: types.AsyncRemote

	function self:onRequest(callback)
		assert(connected, `Cannot use destroyed async remote '{name}'`)
		handler = callback
	end

	function self:request(...)
		assert(connected, `Cannot use destroyed async remote '{name}'`)

		local arguments = table.pack(...)

		return instances.promiseRemoteFunction(name):andThen(function(instance)
			local response = if test:hasRequestHandler()
				then table.pack(test:_request(table.unpack(arguments, 1, arguments.n))) :: never
				else table.pack(instance:InvokeServer(table.unpack(arguments, 1, arguments.n)))

			for index, validator in builder.metadata.returns do
				local value = response[index]
				assert(validator(value), `Invalid return value #{index} for async remote '{name}': got {value}`)
			end

			return table.unpack(response, 1, response.n)
		end, function(error): ()
			warn(`Failed to invoke async remote '{name}': {error}`)
		end) :: any
	end

	function self:destroy()
		if connected then
			connected = false
			handler = function() end :: (...any) -> ()
		end
	end

	local invoke = compose(builder.metadata.middleware)(function(...: any): any
		handler(...)
		return unwrap(handler(...))
	end, self)

	instances.promiseRemoteFunction(name):andThen(function(instance): ()
		if not connected then
			return
		end

		function instance.OnClientInvoke(...)
			assert(connected, `Async remote '{name}' was invoked after it was destroyed`)

			for index, validator in builder.metadata.parameters do
				local value = select(index, ...)
				assert(validator(value), `Invalid parameter #{index} for async remote '{name}': got {value}`)
			end

			return invoke(...)
		end
	end, function(error): ()
		warn(`Failed to initialize async remote '{name}': {error}`)
	end)

	setmetatable(self :: {}, {
		__call = self.request,
	})

	return self
end

return createAsyncRemote
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="78">
                <Properties>
                  <string name="Name">createAsyncRemote.spec</string>
                  <string name="Source"><![CDATA[return function()
	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local t = require(ReplicatedStorage.DevPackages.t)
	local Promise = require(script.Parent.Parent.Promise)
	local builder = require(script.Parent.Parent.builder)
	local mockRemotes = require(script.Parent.Parent.utils.mockRemotes)
	local createAsyncRemote = require(script.Parent.createAsyncRemote)

	local player: Player = Players.LocalPlayer or {} :: any
	local asyncRemote, instance

	beforeEach(function()
		asyncRemote = createAsyncRemote("test", builder.remote(t.string, t.number).returns(t.string))
		instance = mockRemotes.createMockRemoteFunction("test")
	end)

	afterEach(function()
		asyncRemote:destroy()
		instance:Destroy()
	end)

	it("should validate incoming argument types", function()
		asyncRemote:onRequest(function()
			return ""
		end)

		expect(function()
			instance:InvokeClient(player, 1, "")
		end).to.throw()

		expect(function()
			instance:InvokeClient(player, "")
		end).to.throw()

		expect(function()
			instance:InvokeClient(player, "", 1)
		end).to.never.throw()
	end)

	it("should validate incoming return types", function()
		instance.OnServerInvoke = function()
			return 1 -- bad return type
		end

		expect(function()
			asyncRemote:request("", 1):expect()
		end).to.throw()

		instance.OnServerInvoke = function()
			return "" -- good return type
		end

		expect(function()
			asyncRemote:request("", 1):expect()
		end).to.never.throw()
	end)

	it("should send and receive the correct values", function()
		local player, a, b

		asyncRemote:onRequest(function(...)
			a, b = ...
			return "result"
		end)

		function instance.OnServerInvoke(...)
			player, a, b = ...
			return "result"
		end

		-- incoming invoke
		expect(instance:InvokeClient(player, "test", 1)).to.equal("result")
		expect(player).to.never.be.ok()
		expect(a).to.equal("test")
		expect(b).to.equal(1)

		-- outgoing invoke
		expect(asyncRemote:request("test2", 2):expect()).to.equal("result")
		expect(player).to.be.ok()
		expect(a).to.equal("test2")
		expect(b).to.equal(2)
	end)

	it("should unwrap promises on invoke", function()
		local a, b

		asyncRemote:onRequest(function(...)
			a, b = ...
			return Promise.resolve("result")
		end)

		-- incoming invoke
		expect(instance:InvokeClient(player, "test", 1)).to.equal("result")
		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should throw when used after destruction", function()
		asyncRemote:onRequest(function(): () end)
		asyncRemote:destroy()

		expect(function()
			asyncRemote:request("", 1):expect()
		end).to.throw()

		expect(function()
			instance:InvokeClient(player, "", 1)
		end).to.throw()

		expect(function()
			asyncRemote:onRequest(function(): () end)
		end).to.throw()
	end)

	it("should apply the middleware", function()
		local middlewareRemote, arg1, arg2, result

		asyncRemote = createAsyncRemote(
			"test",
			builder.remote(t.string, t.number).returns(t.string).middleware(function(next, remote)
				middlewareRemote = remote
				return function()
					result = next("intercepted", 2)
					return result .. "!"
				end
			end)
		)

		expect(middlewareRemote).to.equal(asyncRemote)

		asyncRemote:onRequest(function(...)
			arg1, arg2 = ...
			return "result"
		end)

		expect(instance:InvokeClient(player, "test", 1)).to.equal("result!")
		expect(arg1).to.equal("intercepted")
		expect(arg2).to.equal(2)
		expect(result).to.equal("result")
	end)

	it("should support multiple return values", function()
		asyncRemote = createAsyncRemote("test", builder.remote().returns(t.string, t.string, t.string))

		asyncRemote:onRequest(function()
			return Promise.resolve("a", "b", "c")
		end)

		local a, b, c = instance:InvokeClient(player)

		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")

		instance.OnServerInvoke = function()
			return "a", "b", "c"
		end

		a, b, c = asyncRemote:request():expect()

		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")
	end)

	it("should be callable", function()
		function instance.OnServerInvoke()
			return "result"
		end

		expect(asyncRemote("test", 1):expect()).to.equal("result")
	end)

	it("should invoke the test handler", function()
		local arg1, arg2

		asyncRemote.test:handleRequest(function(...)
			arg1, arg2 = ...
			return "result"
		end)

		expect(asyncRemote:request("test", 1):expect()).to.equal("result")
		expect(arg1).to.equal("test")
		expect(arg2).to.equal(1)

		asyncRemote.test:disconnectAll()

		expect(function()
			asyncRemote:request("test", 1):expect()
		end).to.throw()
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="79">
                <Properties>
                  <string name="Name">createRemote</string>
                  <string name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Promise)
local types = require(script.Parent.Parent.types)

local compose = require(script.Parent.Parent.utils.compose)
local instances = require(script.Parent.Parent.utils.instances)
local testRemote = require(script.Parent.Parent.utils.testRemote)

local function createRemote(name: string, builder: types.RemoteBuilder): types.Remote
	local connection: RBXScriptConnection?
	local test = testRemote.createTestRemote()
	local connected = true

	local listeners: { (...any) -> () } = {}
	local nextListenerId = 0
	local queue: { { any } } = {}

	local function noop()
		error(`Attempted to use a server-only function on the client remote '{name}'`)
	end

	local self = {
		name = name,
		type = "event" :: "event",
		test = test,
		fireAll = noop,
		fireAllExcept = noop,
		firePlayers = noop,
	} :: types.Remote

	function self:connect(listener)
		assert(connected, `Cannot use destroyed remote '{name}'`)

		local id = nextListenerId
		nextListenerId += 1
		listeners[id] = listener

		if #queue > 0 then
			for _, args in queue do
				task.spawn(listener, table.unpack(args))
			end
			table.clear(queue)
		end

		return function()
			listeners[id] = nil
		end
	end

	function self:promise(predicate, mapper)
		assert(connected, `Cannot promise destroyed event remote '{name}'`)

		return Promise.new(function(resolve, _, onCancel)
			local disconnect
			disconnect = self:connect(function(...)
				if not predicate or predicate(...) then
					disconnect()
					if mapper then
						resolve(mapper(...))
					else
						resolve(...)
					end
				end
			end)

			onCancel(disconnect)
		end)
	end

	function self:fire(...)
		assert(connected, `Cannot use destroyed remote '{name}'`)

		local arguments = table.pack(...)

		instances.promiseRemoteEvent(name):andThen(function(instance)
			instance:FireServer(table.unpack(arguments, 1, arguments.n))
			test:_fire(table.unpack(arguments, 1, arguments.n))
		end, function(error): ()
			warn(`Failed to fire remote '{name}': {error}`)
		end)
	end

	function self:destroy()
		if not connected then
			return
		end

		connected = false

		if connection then
			connection:Disconnect()
			connection = nil
		end

		table.clear(listeners)
		table.clear(queue)
	end

	local emit = compose(builder.metadata.middleware)(function(...): ()
		if next(listeners) then
			for _, listener in listeners do
				task.spawn(listener, ...)
			end
		else
			table.insert(queue, table.pack(...))
		end
	end, self)

	instances.promiseRemoteEvent(name):andThen(function(instance)
		if not connected then
			return
		end

		connection = instance.OnClientEvent:Connect(function(...)
			for index, validator in builder.metadata.parameters do
				local value = select(index, ...)
				assert(validator(value), `Invalid parameter #{index} for remote '{name}': got {value}`)
			end

			emit(...)
		end)
	end, function(error): ()
		warn(`Failed to initialize remote '{name}': {error}`)
	end)

	setmetatable(self :: {}, {
		__call = self.fire,
	})

	return self
end

return createRemote
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="80">
                <Properties>
                  <string name="Name">createRemote.spec</string>
                  <string name="Source"><![CDATA[return function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local t = require(ReplicatedStorage.DevPackages.t)
	local builder = require(script.Parent.Parent.builder)
	local mockRemotes = require(script.Parent.Parent.utils.mockRemotes)
	local createRemote = require(script.Parent.createRemote)

	local remote, instance

	beforeEach(function()
		remote = createRemote("test", builder.remote(t.string, t.number))
		instance = mockRemotes.createMockRemoteEvent("test")
	end)

	afterEach(function()
		remote:destroy()
		instance:Destroy()
	end)

	it("should validate incoming argument types", function()
		expect(function()
			instance:FireAllClients(1, "")
		end).to.throw()

		expect(function()
			instance:FireAllClients("")
		end).to.throw()

		expect(function()
			instance:FireAllClients("", 1)
		end).to.never.throw()
	end)

	it("should receive incoming events", function()
		local a, b

		remote:connect(function(...)
			a, b = ...
		end)

		instance:FireAllClients("test", 1)
		expect(a).to.equal("test")
		expect(b).to.equal(1)

		instance:FireAllClients("test2", 2)
		expect(a).to.equal("test2")
		expect(b).to.equal(2)
	end)

	it("should fire outgoing events", function()
		local player, a, b

		instance.OnServerEvent:Connect(function(...)
			player, a, b = ...
		end)

		remote:fire("test", 1)
		expect(player).to.be.ok()
		expect(a).to.equal("test")
		expect(b).to.equal(1)

		remote:fire("test2", 2)
		expect(player).to.be.ok()
		expect(a).to.equal("test2")
		expect(b).to.equal(2)
	end)

	it("should throw when used after destruction", function()
		remote:destroy()

		expect(function()
			remote:fire("test", 1)
		end).to.throw()

		expect(function()
			remote:connect(function() end)
		end).to.throw()
	end)

	it("should not fire disconnected events", function()
		local fired = false
		local disconnect = remote:connect(function()
			fired = true
		end)
		disconnect()
		instance:FireAllClients("intercepted", 1)
		expect(fired).to.equal(false)
	end)

	it("should apply the middleware", function()
		local middlewareRemote, arg1, arg2

		remote = createRemote(
			"test",
			builder.remote(t.string, t.number).middleware(function(next, remote)
				middlewareRemote = remote
				return function()
					return next("intercepted", 2)
				end
			end)
		)

		expect(middlewareRemote).to.equal(remote)

		remote:connect(function(...)
			arg1, arg2 = ...
		end)

		instance:FireAllClients("test", 1)

		expect(arg1).to.equal("intercepted")
		expect(arg2).to.equal(2)
	end)

	it("should fire the test listeners", function()
		local test1, test2, arg1, arg2

		remote.test:onFire(function(...)
			test1, test2 = ...
		end)

		instance.OnServerEvent:Connect(function(_, ...)
			arg1, arg2 = ...
		end)

		remote:fire("test", 1)

		expect(test1).to.equal(arg1)
		expect(test2).to.equal(arg2)

		test1, test2, arg1, arg2 = nil
		remote.test:disconnectAll()
		remote:fire("test", 1)

		expect(test1).to.never.be.ok()
		expect(test2).to.never.be.ok()
		expect(arg1).to.equal("test")
		expect(arg2).to.equal(1)
	end)

	it("should be callable", function()
		local player, a, b

		instance.OnServerEvent:Connect(function(...)
			player, a, b = ...
		end)

		remote("test", 1)
		expect(player).to.be.ok()
		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should promise an event", function()
		local a, b

		remote:promise():andThen(function(...)
			a, b = ...
		end)

		instance:FireAllClients("test", 1)

		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should promise a predicated event", function()
		local a, b

		remote
			:promise(function(a)
				return a == "true"
			end)
			:andThen(function(...)
				a, b = ...
			end)

		instance:FireAllClients("false", 2)

		expect(a).to.never.be.ok()
		expect(b).to.never.be.ok()

		instance:FireAllClients("true", 1)

		expect(a).to.equal("true")
		expect(b).to.equal(1)
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="81">
              <Properties>
                <string name="Name">constants</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

return {
	IS_EDIT = RunService:IsStudio() and not RunService:IsRunning(),
	IS_STUDIO = RunService:IsStudio(),
	IS_CLIENT = RunService:IsClient(),
	IS_SERVER = RunService:IsServer(),
	IS_TEST = false,
}
]]></string>
              </Properties>
            </Item>
            <Item class="Configuration" referent="82">
              <Properties>
                <string name="Name">container</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="83">
              <Properties>
                <string name="Name">createRemotes</string>
                <string name="Source"><![CDATA[local types = require(script.Parent.types)
local constants = require(script.Parent.constants)
local client = require(script.Parent.client)
local server = require(script.Parent.server)

local function deepApplyMiddleware(builders: types.RemoteBuilders, ...: types.Middleware)
	for _, builder in builders do
		if builder.type == "namespace" then
			deepApplyMiddleware(builder.remotes, ...)
		else
			builder.middleware(...)
		end
	end
end

local function createRemotes<Map>(builders: types.RemoteBuilders, ...: types.Middleware): types.Remotes<Map>
	local self = {} :: types.Remotes<Map>

	deepApplyMiddleware(builders, ...)

	local map = if constants.IS_SERVER then server.createRemotes(builders) else client.createRemotes(builders)

	local function recursiveDestroy(values: any)
		for _, value in values do
			if type(value) ~= "table" then
				return
			end

			if value.destroy then
				value:destroy()
			else
				recursiveDestroy(value)
			end
		end
	end

	function self:destroy()
		recursiveDestroy(map)
	end

	for key, value in map do
		(self :: {})[key] = value
	end

	return self
end

return createRemotes
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="84">
              <Properties>
                <string name="Name">createRemotes.spec</string>
                <string name="Source"><![CDATA[return function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local t = require(ReplicatedStorage.DevPackages.t)
	local types = require(script.Parent.types)
	local createRemotes = require(script.Parent.createRemotes)
	local builder = require(script.Parent.builder)
	local mockRemotes = require(script.Parent.utils.mockRemotes)

	local remotes: types.Remotes<{
		event: types.ClientToServer<string, number>,
		callback: types.ServerAsync<(string, number), (string)>,
		namespace: {
			event: types.ClientToServer<string, number>,
			callback: types.ServerAsync<(string, number), (string)>,
		},
	}>

	beforeEach(function()
		-- This runs on the server, so don't test client APIs in this file
		remotes = createRemotes({
			event = builder.remote(t.string, t.number),
			callback = builder.remote(t.string, t.number).returns(t.string),
			namespace = builder.namespace({
				event = builder.remote(t.string, t.number),
				callback = builder.remote(t.string, t.number).returns(t.string),
			}),
		})
	end)

	afterEach(function()
		remotes:destroy()
	end)

	it("should create top-level remotes", function()
		expect(remotes.event).to.be.ok()
		expect(remotes.callback).to.be.ok()
		expect(mockRemotes.getMockRemoteEvent("event")).to.be.ok()
		expect(mockRemotes.getMockRemoteFunction("callback")).to.be.ok()
	end)

	it("should create namespaced remotes", function()
		expect(remotes.namespace.event).to.be.ok()
		expect(remotes.namespace.callback).to.be.ok()
		expect(mockRemotes.getMockRemoteEvent("namespace.event")).to.be.ok()
		expect(mockRemotes.getMockRemoteFunction("namespace.callback")).to.be.ok()
	end)

	it("should fire a top-level event", function()
		local arg1, arg2, arg3

		remotes.event:connect(function(...)
			arg1, arg2, arg3 = ...
		end)

		mockRemotes.createMockRemoteEvent("event"):FireServer("test", 1)

		expect(arg1).to.be.ok() -- player
		expect(arg2).to.equal("test")
		expect(arg3).to.equal(1)
	end)

	it("should fire a namespaced event", function()
		local arg1, arg2, arg3

		remotes.namespace.event:connect(function(...)
			arg1, arg2, arg3 = ...
		end)

		mockRemotes.createMockRemoteEvent("namespace.event"):FireServer("test", 1)

		expect(arg1).to.be.ok() -- player
		expect(arg2).to.equal("test")
		expect(arg3).to.equal(1)
	end)

	it("should invoke a top-level callback", function()
		local arg1, arg2, arg3

		remotes.callback:onRequest(function(...)
			arg1, arg2, arg3 = ...
			return "test"
		end)

		local result = mockRemotes.createMockRemoteFunction("callback"):InvokeServer("test", 1)

		expect(arg1).to.be.ok() -- player
		expect(arg2).to.equal("test")
		expect(arg3).to.equal(1)
		expect(result).to.equal("test")
	end)

	it("should invoke a namespaced callback", function()
		local arg1, arg2, arg3

		remotes.namespace.callback:onRequest(function(...)
			arg1, arg2, arg3 = ...
			return "test"
		end)

		local result = mockRemotes.createMockRemoteFunction("namespace.callback"):InvokeServer("test", 1)

		expect(arg1).to.be.ok() -- player
		expect(arg2).to.equal("test")
		expect(arg3).to.equal(1)
		expect(result).to.equal("test")
	end)

	it("should apply middleware to every remote", function()
		remotes:destroy()
		mockRemotes.destroyAll()

		local callOrder, middlewareRemotes, middlewareArguments = {}, {}, {}

		local function middleware(index: number): types.Middleware
			return function(next, remote)
				table.insert(middlewareRemotes, remote)
				return function(...)
					table.insert(middlewareArguments, { ... })
					table.insert(callOrder, index)
					return next(...)
				end
			end
		end

		remotes = createRemotes({
			event = builder.remote(t.string, t.number),
			callback = builder.remote(t.string, t.number).returns(t.string),
			namespace = builder.namespace({
				event = builder.remote(t.string, t.number),
				callback = builder.remote(t.string, t.number).returns(t.string),
			}),
		}, middleware(1), middleware(2), middleware(3))

		local function test(eventName, callbackName)
			callOrder, middlewareArguments = {}, {}

			mockRemotes.createMockRemoteEvent(eventName):FireServer("test", 1)

			for i = 1, 3 do
				expect(middlewareRemotes[i]).to.be.ok()
				expect(middlewareArguments[i][1]).to.be.ok() -- player
				expect(middlewareArguments[i][2]).to.equal("test")
				expect(middlewareArguments[i][3]).to.equal(1)
				expect(callOrder[i]).to.equal(i)
			end

			callOrder, middlewareArguments = {}, {}

			mockRemotes.createMockRemoteFunction(callbackName):InvokeServer("test", 1)

			for i = 1, 3 do
				expect(middlewareArguments[i][1]).to.be.ok() -- player
				expect(middlewareArguments[i][2]).to.equal("test")
				expect(middlewareArguments[i][3]).to.equal(1)
				expect(callOrder[i]).to.equal(i)
			end
		end

		test("event", "callback")
		test("namespace.event", "namespace.callback")
	end)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="85">
              <Properties>
                <string name="Name">getSender</string>
                <string name="Source"><![CDATA[local constants = require(script.Parent.constants)

local function getSender(player: any): Player?
	if
		constants.IS_SERVER
		and (type(player) == "table" or typeof(player) == "Instance")
		and player.ClassName == "Player"
	then
		return player :: Player
	end
	return nil
end

return getSender
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="86">
              <Properties>
                <string name="Name">init.spec</string>
                <string name="Source"><![CDATA[return function()
	local constants = require(script.Parent.constants)
	local mockRemotes = require(script.Parent.utils.mockRemotes)

	local IS_EDIT = constants.IS_EDIT

	beforeAll(function()
		-- Edit constants so tests run client and server with mock remotes
		constants.IS_EDIT = true
		constants.IS_TEST = true
	end)

	afterAll(function()
		constants.IS_EDIT = IS_EDIT
		constants.IS_TEST = false
	end)

	afterEach(function()
		mockRemotes.destroyAll()
	end)
end
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="87">
              <Properties>
                <string name="Name">middleware</string>
              </Properties>
              <Item class="ModuleScript" referent="88">
                <Properties>
                  <string name="Name">loggerMiddleware</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local constants = require(script.Parent.Parent.constants)

local SCOPE = constants.IS_SERVER and "client → server" or "server → client"

local function stringify(...)
	local output = {}

	for index = 1, select("#", ...) do
		local value = select(index, ...)

		table.insert(output, `{if index > 1 then "\n" else ""}\t{index}.`)

		if type(value) == "string" then
			table.insert(output, string.format("%q", value))
		elseif type(value) == "userdata" then
			table.insert(output, `{typeof(value)}({value})`)
		else
			table.insert(output, value)
		end
	end

	if #output == 0 then
		return "\t1. (void)\n"
	end

	table.insert(output, "\n")

	return table.unpack(output)
end

local loggerMiddleware: types.Middleware = function(next, remote)
	return function(...)
		if remote.type == "event" then
			print(`\n🟡 ({SCOPE}) {remote.name}\n\n`, stringify(...))
			return next(...)
		end

		print(`\n🟣 ({SCOPE} async) {remote.name}\n`)
		print(`Parameters\n`, stringify(...))

		local results = table.pack(next(...))

		print("Returns\n", stringify(table.unpack(results, 1, results.n)))

		return table.unpack(results, 1, results.n)
	end
end

return loggerMiddleware
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="89">
                <Properties>
                  <string name="Name">throttleMiddleware</string>
                  <string name="Source"><![CDATA[local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Promise = require(script.Parent.Parent.Promise)
local types = require(script.Parent.Parent.types)
local constants = require(script.Parent.Parent.constants)
local getSender = require(script.Parent.Parent.getSender)

local SERVER = "(SERVER)"

export type ThrottleMiddlewareOptions = {
	throttle: number?,
	trailing: boolean?,
	[any]: any,
} | number

local function timeout<T...>(callback: (T...) -> (), amount: number): () -> ()
	local timer = 0
	local connection

	connection = RunService.Heartbeat:Connect(function(deltaTime)
		timer += deltaTime
		if timer >= amount then
			connection:Disconnect()
			callback()
		end
	end)

	return function()
		connection:Disconnect()
	end
end

local function throttleMiddleware(options: ThrottleMiddlewareOptions?): types.Middleware
	local throttle = 0.1
	local trailing = false

	if type(options) == "number" then
		throttle = options
	elseif type(options) == "table" then
		throttle = if options.throttle ~= nil then options.throttle else throttle
		trailing = if options.trailing ~= nil then options.trailing else trailing
	end

	local eventMiddleware: types.Middleware = function(next, remote)
		local timeouts: { [string]: () -> () } = {}
		local cache: { [string]: { [number]: unknown, n: number } } = {}

		return function(...)
			local sender = getSender(...)
			local senderId = if sender then sender.Name else SERVER
			local timeoutId = timeouts[senderId]

			cache[senderId] = table.pack(...)

			if timeoutId then
				if not constants.IS_TEST and constants.IS_STUDIO then
					warn(`🔴 throttled remote '{remote.name}' fired by '{senderId}'`)
				end
				return
			end

			timeouts[senderId] = timeout(function()
				local arguments = cache[senderId]
				timeouts[senderId] = nil
				cache[senderId] = nil

				if trailing then
					next(table.unpack(arguments, 1, arguments.n))
				end
			end, throttle)

			return next(...)
		end
	end

	local asyncMiddleware: types.Middleware = function(next, remote)
		local timeouts: { [string]: () -> () } = {}
		local cache: { [string]: { [number]: unknown, n: number } } = {}
		local pending: { [string]: boolean } = {}
		local watching: { [string]: Promise.Promise } = {}

		local function clearCacheOnPlayerDisconnect(sender: Player)
			if watching[sender.Name] then
				return
			end

			watching[sender.Name] = Promise.fromEvent(Players.PlayerRemoving, function(player)
				return player == sender
			end):andThen(function()
				timeouts[sender.Name] = nil
				cache[sender.Name] = nil
				pending[sender.Name] = nil
				watching[sender.Name] = nil
			end)
		end

		return function(...)
			local sender = getSender(...)
			local senderId = if sender then sender.Name else SERVER

			local timeoutId = timeouts[senderId]
			local isPending = pending[senderId]

			if sender then
				clearCacheOnPlayerDisconnect(sender)
			end

			if timeoutId or isPending then
				-- async remotes should try to return the previous value before
				-- rejecting the request
				local results =
					assert(cache[senderId], `🔴 throttled remote '{remote.name}' requested by '{senderId}'`)
				return table.unpack(results, 1, results.n)
			end

			pending[senderId] = true

			local ok, results = pcall(function(...)
				return table.pack(next(...))
			end, ...)

			pending[senderId] = nil

			timeouts[senderId] = timeout(function()
				timeouts[senderId] = nil
			end, throttle)

			assert(ok, results)

			cache[senderId] = results

			return table.unpack(results, 1, results.n)
		end
	end

	return function(next, remote)
		if remote.type == "event" then
			return eventMiddleware(next, remote)
		elseif remote.type == "function" then
			return asyncMiddleware(next, remote)
		else
			return next
		end
	end
end

return throttleMiddleware
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="90">
                <Properties>
                  <string name="Name">throttleMiddleware.spec</string>
                  <string name="Source"><![CDATA[return function()
	local RunService = game:GetService("RunService")

	local types = require(script.Parent.Parent.types)
	local createRemotes = require(script.Parent.Parent.createRemotes)
	local builder = require(script.Parent.Parent.builder)
	local instances = require(script.Parent.Parent.utils.instances)
	local throttleMiddleware = require(script.Parent.throttleMiddleware)

	local function pause(frames: number?)
		local counter = frames or 1
		local thread = coroutine.running()
		local connection

		connection = RunService.Heartbeat:Connect(function()
			counter -= 1
			if counter <= 0 then
				connection:Disconnect()
				task.defer(thread)
			end
		end)

		coroutine.yield()
	end

	describe("event throttle", function()
		local remotes, remote: types.ClientToServer, instance: RemoteEvent

		local function create(options: throttleMiddleware.ThrottleMiddlewareOptions)
			remotes = createRemotes({ remote = builder.remote() }, throttleMiddleware(options))
			remote = remotes.remote
			instance = instances.createRemoteEvent("remote", false)
		end

		afterEach(function()
			remotes:destroy()
		end)

		it("should throttle subsequent calls", function()
			local calls = 0

			create({ throttle = 0, trailing = false })

			remote:connect(function()
				calls += 1
			end)

			for _ = 1, 5 do
				instance:FireServer()
			end
			expect(calls).to.equal(1)

			pause()

			for _ = 1, 5 do
				instance:FireServer()
			end
			expect(calls).to.equal(2)
		end)

		it("should emit trailing calls", function()
			local calls = 0

			create({ throttle = 0, trailing = true })

			remote:connect(function()
				calls += 1
			end)

			for _ = 1, 5 do
				instance:FireServer()
			end
			expect(calls).to.equal(1)

			pause()
			expect(calls).to.equal(2)

			for _ = 1, 5 do
				instance:FireServer()
			end
			expect(calls).to.equal(3)

			pause()
			expect(calls).to.equal(4)
		end)

		it("should pass the latest arguments to the trailing call", function()
			local calls = 0
			local arg1, arg2

			create({ throttle = 0, trailing = true })

			remote:connect(function(_, a, b)
				calls += 1
				arg1, arg2 = a, b
			end)

			for i = 1, 5 do
				instance:FireServer(i, i + 1)
			end
			instance:FireServer("a", "b")

			expect(calls).to.equal(1)
			expect(arg1).to.be.a("number")
			expect(arg2).to.be.a("number")

			pause()
			expect(calls).to.equal(2)
			expect(arg1).to.equal("a")
			expect(arg2).to.equal("b")

			instance:FireServer("c", "d")
			expect(calls).to.equal(3)
			expect(arg1).to.equal("c")
			expect(arg2).to.equal("d")

			pause()
			expect(calls).to.equal(4)
			expect(arg1).to.equal("c")
			expect(arg2).to.equal("d")
		end)

		it("should receive a throttle time as options", function()
			local calls = 0

			create(0)

			remote:connect(function()
				calls += 1
			end)

			for _ = 1, 5 do
				instance:FireServer()
			end
			expect(calls).to.equal(1)

			pause()

			for _ = 1, 5 do
				instance:FireServer()
			end
			expect(calls).to.equal(2)
		end)
	end)

	describe("async throttle", function()
		local remotes, remote: types.ServerAsync, instance: RemoteFunction

		local function create(options: throttleMiddleware.ThrottleMiddlewareOptions)
			remotes = createRemotes({ remote = builder.remote().returns() }, throttleMiddleware(options))
			remote = remotes.remote
			instance = instances.createRemoteFunction("remote")
		end

		local function didYield(callback: () -> any)
			local blocked = true
			local success, result

			task.spawn(function()
				success, result = pcall(callback)
				blocked = false
			end)

			assert(success or success == nil, result)

			return blocked
		end

		afterEach(function()
			remotes:destroy()
		end)

		it("should throttle subsequent calls", function()
			local calls = 0

			create({ throttle = 0 })

			remote:onRequest(function(): ()
				calls += 1
			end)

			for _ = 1, 5 do
				instance:InvokeServer()
			end
			expect(calls).to.equal(1)

			pause()

			for _ = 1, 5 do
				instance:InvokeServer()
			end
			expect(calls).to.equal(2)
		end)

		it("should return the cached value when throttled", function()
			local acc = 0

			create({ throttle = 0 })

			remote:onRequest(function(): number
				acc += 1
				return acc
			end)

			expect(instance:InvokeServer()).to.equal(1)
			for _ = 1, 5 do
				expect(instance:InvokeServer()).to.equal(1)
			end

			pause()

			expect(instance:InvokeServer()).to.equal(2)
			for _ = 1, 5 do
				expect(instance:InvokeServer()).to.equal(2)
			end
		end)

		it("should throw if the initial cache is not ready", function()
			create({ throttle = 0 })

			remote:onRequest(function(): ()
				pause()
			end)

			task.spawn(function()
				instance:InvokeServer()
			end)

			expect(function()
				instance:InvokeServer()
			end).to.throw()
		end)

		it("should return the cached value if a request is still pending", function()
			local acc = 0

			create({ throttle = 0 })

			remote:onRequest(function(): number
				-- set cache synchronously on first request
				if acc > 0 then
					pause()
				end
				acc += 1
				return acc
			end)

			expect(didYield(function(): ()
				-- initialize cache immediately
				expect(instance:InvokeServer()).to.equal(1)
			end)).to.equal(false)

			expect(didYield(function(): ()
				-- throttle not over, return cached value
				expect(instance:InvokeServer()).to.equal(1)
				expect(instance:InvokeServer()).to.equal(1)
			end)).to.equal(false)

			pause()

			expect(didYield(function(): ()
				-- make a new request, it will eventually return 2
				expect(instance:InvokeServer()).to.equal(2)
			end)).to.equal(true)

			expect(didYield(function(): ()
				-- throttle not over, return cached value
				expect(instance:InvokeServer()).to.equal(1)
				expect(instance:InvokeServer()).to.equal(1)
			end)).to.equal(false)
		end)

		it("should throttle if the handler throws an error", function()
			local acc = 0

			create({ throttle = 0 })

			remote:onRequest(function(): number
				acc += 1
				assert(acc ~= 1, "error")
				return acc
			end)

			expect(function()
				instance:InvokeServer() -- handler error
			end).to.throw()

			expect(function()
				instance:InvokeServer() -- throttle error
			end).to.throw()

			pause()

			expect(instance:InvokeServer()).to.equal(2)
			for _ = 1, 5 do
				expect(instance:InvokeServer()).to.equal(2)
			end

			pause()

			expect(instance:InvokeServer()).to.equal(3)
			for _ = 1, 5 do
				expect(instance:InvokeServer()).to.equal(3)
			end
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="91">
              <Properties>
                <string name="Name">server</string>
                <string name="Source"><![CDATA[local types = require(script.Parent.types)
local createAsyncRemote = require(script.createAsyncRemote)
local createRemote = require(script.createRemote)

local function createRemotes(builders: types.RemoteBuilders, namespace: string?): types.RemoteMap
	local remotes: types.RemoteMap = {}
	local scope = if namespace then `{namespace}.` else ""

	for name, builder in builders do
		remotes[name] = if builder.type == "namespace"
			then createRemotes(builder.remotes, scope .. name)
			elseif builder.type == "event" then createRemote(scope .. name, builder)
			elseif builder.type == "function" then createAsyncRemote(scope .. name, builder)
			else error(`Invalid remote type "{builder.type}"`)
	end

	return remotes
end

return {
	createRemotes = createRemotes,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="92">
                <Properties>
                  <string name="Name">createAsyncRemote</string>
                  <string name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Promise)
local types = require(script.Parent.Parent.types)

local compose = require(script.Parent.Parent.utils.compose)
local instances = require(script.Parent.Parent.utils.instances)
local unwrap = require(script.Parent.Parent.utils.unwrap)
local testRemote = require(script.Parent.Parent.utils.testRemote)

local function createAsyncRemote(name: string, builder: types.RemoteBuilder): types.AsyncRemote
	assert(builder.metadata.returns, `Missing return value validator for async remote '{name}'`)

	local instance = instances.createRemoteFunction(name)
	local test = testRemote.createTestAsyncRemote()
	local connected = true
	local handler = function() end :: (...any) -> ()

	local self = {
		name = name,
		type = "function" :: "function",
		test = test,
	} :: types.AsyncRemote

	function self:onRequest(callback)
		assert(connected, `Cannot use destroyed async remote '{name}'`)
		handler = callback
	end

	function self:request(player, ...)
		assert(connected, `Cannot use destroyed async remote '{name}'`)

		return Promise.try(function(...)
			local response = if test:hasRequestHandler()
				then table.pack(test:_request(player, ...)) :: never
				else table.pack(instance:InvokeClient(player, ...))

			for index, validator in builder.metadata.returns do
				local value = response[index]
				assert(validator(value), `Invalid return value #{index} for async remote '{name}': got {value}`)
			end

			return table.unpack(response, 1, response.n)
		end, ...)
	end

	function self:destroy()
		if connected then
			connected = false
			instance:Destroy()
		end
	end

	local invoke = compose(builder.metadata.middleware)(function(...)
		return unwrap(handler(...))
	end, self)

	function instance.OnServerInvoke(player: Player, ...)
		for index, validator in builder.metadata.parameters do
			local value = select(index, ...)
			assert(validator(value), `Invalid parameter #{index} for async remote '{name}': got {value}`)
		end

		return invoke(player, ...)
	end

	setmetatable(self :: {}, {
		__call = self.request,
	})

	return self
end

return createAsyncRemote
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="93">
                <Properties>
                  <string name="Name">createAsyncRemote.spec</string>
                  <string name="Source"><![CDATA[return function()
	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local t = require(ReplicatedStorage.DevPackages.t)
	local Promise = require(script.Parent.Parent.Promise)
	local builder = require(script.Parent.Parent.builder)
	local mockRemotes = require(script.Parent.Parent.utils.mockRemotes)
	local createAsyncRemote = require(script.Parent.createAsyncRemote)

	local player: Player = Players.LocalPlayer or {} :: any
	local asyncRemote, instance

	beforeEach(function()
		asyncRemote = createAsyncRemote("test", builder.remote(t.string, t.number).returns(t.string))
		instance = mockRemotes.createMockRemoteFunction("test")
	end)

	afterEach(function()
		asyncRemote:destroy()
		instance:Destroy()
	end)

	it("should validate incoming argument types", function()
		asyncRemote:onRequest(function()
			return ""
		end)

		expect(function()
			instance:InvokeServer(1, "")
		end).to.throw()

		expect(function()
			instance:InvokeServer("")
		end).to.throw()

		expect(function()
			instance:InvokeServer("", 1)
		end).to.never.throw()
	end)

	it("should validate incoming return types", function()
		instance.OnClientInvoke = function()
			return 1 -- bad return type
		end

		expect(function()
			asyncRemote:request(player, "", 1):expect()
		end).to.throw()

		instance.OnClientInvoke = function()
			return "" -- good return type
		end

		expect(function()
			asyncRemote:request(player, "", 1):expect()
		end).to.never.throw()
	end)

	it("should send and receive the correct values", function()
		local player, a, b

		asyncRemote:onRequest(function(...)
			player, a, b = ...
			return "result"
		end)

		function instance.OnClientInvoke(...)
			a, b = ...
			return "result"
		end

		-- outgoing invoke
		expect(asyncRemote:request(player, "test2", 2):expect()).to.equal("result")
		expect(player).to.never.be.ok()
		expect(a).to.equal("test2")
		expect(b).to.equal(2)

		-- incoming invoke
		expect(instance:InvokeServer("test", 1)).to.equal("result")
		expect(player).to.be.ok()
		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should unwrap promises on invoke", function()
		local player, a, b

		asyncRemote:onRequest(function(...)
			player, a, b = ...
			return Promise.resolve("result")
		end)

		-- incoming invoke
		expect(instance:InvokeServer("test", 1)).to.equal("result")
		expect(player).to.be.ok()
		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should throw when used after destruction", function()
		asyncRemote:onRequest(function(): () end)
		asyncRemote:destroy()

		expect(function()
			asyncRemote:request(player, "", 1):expect()
		end).to.throw()

		expect(function()
			asyncRemote:onRequest(function(): () end)
		end).to.throw()
	end)

	it("should apply the middleware", function()
		local middlewareRemote, playerInvoked, arg1, arg2, result

		asyncRemote = createAsyncRemote(
			"test",
			builder.remote(t.string, t.number).returns(t.string).middleware(function(next, remote)
				middlewareRemote = remote
				return function(player)
					result = next(player, "intercepted", 2)
					return result .. "!"
				end
			end)
		)

		expect(middlewareRemote).to.equal(asyncRemote)

		asyncRemote:onRequest(function(...)
			playerInvoked, arg1, arg2 = ...
			return "result"
		end)

		expect(instance:InvokeServer("test", 1)).to.equal("result!")
		expect(playerInvoked).to.be.ok()
		expect(arg1).to.equal("intercepted")
		expect(arg2).to.equal(2)
		expect(result).to.equal("result")
	end)

	it("should support multiple return values", function()
		asyncRemote = createAsyncRemote("test", builder.remote().returns(t.string, t.string, t.string))

		asyncRemote:onRequest(function()
			return Promise.resolve("a", "b", "c")
		end)

		local a, b, c = instance:InvokeServer()

		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")

		instance.OnClientInvoke = function()
			return "a", "b", "c"
		end

		a, b, c = asyncRemote:request():expect()

		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")
	end)

	it("should be callable", function()
		function instance.OnClientInvoke()
			return "result"
		end

		expect(asyncRemote(player, "test", 1):expect()).to.equal("result")
	end)

	it("should invoke the test handler", function()
		local arg1, arg2

		asyncRemote.test:handleRequest(function(...)
			arg1, arg2 = ...
			return "result"
		end)

		expect(asyncRemote:request("test", 1):expect()).to.equal("result")
		expect(arg1).to.equal("test")
		expect(arg2).to.equal(1)

		asyncRemote.test:disconnectAll()

		expect(function()
			asyncRemote:request("test", 1):expect()
		end).to.throw()
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="94">
                <Properties>
                  <string name="Name">createRemote</string>
                  <string name="Source"><![CDATA[local Players = game:GetService("Players")

local Promise = require(script.Parent.Parent.Promise)
local types = require(script.Parent.Parent.types)

local compose = require(script.Parent.Parent.utils.compose)
local instances = require(script.Parent.Parent.utils.instances)
local testRemote = require(script.Parent.Parent.utils.testRemote)

local function createRemote(name: string, builder: types.RemoteBuilder): types.Remote
	local instance = instances.createRemoteEvent(name, builder.metadata.unreliable)
	local test = testRemote.createTestRemote()
	local connected = true

	local listeners: { (...any) -> () } = {}
	local nextListenerId = 0

	local self = {
		name = name,
		type = "event" :: "event",
		test = test,
	} :: types.Remote

	function self:connect(listener)
		assert(connected, `Cannot connect to destroyed event remote '{name}'`)

		local id = nextListenerId
		nextListenerId += 1
		listeners[id] = listener

		return function()
			listeners[id] = nil
		end
	end

	function self:promise(predicate, mapper)
		assert(connected, `Cannot promise destroyed event remote '{name}'`)

		return Promise.new(function(resolve, _, onCancel)
			local disconnect
			disconnect = self:connect(function(...)
				if not predicate or predicate(...) then
					disconnect()
					if mapper then
						resolve(mapper(...))
					else
						resolve(...)
					end
				end
			end)

			onCancel(disconnect)
		end)
	end

	function self:fire(player, ...)
		assert(connected, `Cannot fire destroyed event remote '{name}'`)
		instance:FireClient(player, ...)
		test:_fire(player, ...) -- do not risk omitting first argument
	end

	function self:fireAll(...)
		assert(connected, `Cannot fire destroyed event remote '{name}'`)
		instance:FireAllClients(...)
		test:_fire(...)
	end

	function self:fireAllExcept(exception, ...)
		assert(connected, `Cannot fire destroyed event remote '{name}'`)
		for _, player in Players:GetPlayers() do
			if player ~= exception then
				instance:FireClient(player, ...)
			end
		end
		test:_fire(...)
	end

	function self:firePlayers(players, ...)
		assert(connected, `Cannot fire destroyed event remote '{name}'`)
		for _, player in players do
			instance:FireClient(player, ...)
		end
		test:_fire(...)
	end

	function self:destroy()
		if not connected then
			return
		end

		connected = false

		instance:Destroy()
		instance = nil :: never

		table.clear(listeners)
	end

	local emit = compose(builder.metadata.middleware)(function(...): ()
		for _, listener in listeners do
			task.spawn(listener, ...)
		end
	end, self)

	instance.OnServerEvent:Connect(function(player: Player, ...)
		for index, validator in builder.metadata.parameters do
			local value = select(index, ...)
			assert(validator(value), `Invalid parameter #{index} for event remote '{name}': got {value}`)
		end

		emit(player, ...)
	end)

	setmetatable(self :: {}, {
		__call = self.fire,
	})

	return self
end

return createRemote
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="95">
                <Properties>
                  <string name="Name">createRemote.spec</string>
                  <string name="Source"><![CDATA[return function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local t = require(ReplicatedStorage.DevPackages.t)
	local builder = require(script.Parent.Parent.builder)
	local mockRemotes = require(script.Parent.Parent.utils.mockRemotes)
	local createRemote = require(script.Parent.createRemote)

	local remote, instance

	beforeEach(function()
		remote = createRemote("test", builder.remote(t.string, t.number))
		instance = mockRemotes.createMockRemoteEvent("test")
	end)

	afterEach(function()
		remote:destroy()
		instance:Destroy()
	end)

	it("should validate incoming argument types", function()
		expect(function()
			instance:FireServer(1, "")
		end).to.throw()

		expect(function()
			instance:FireServer("")
		end).to.throw()

		expect(function()
			instance:FireServer("", 1)
		end).to.never.throw()
	end)

	it("should receive incoming events", function()
		local player, a, b

		remote:connect(function(...)
			player, a, b = ...
		end)

		instance:FireServer("test", 1)

		expect(player).to.be.ok()
		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should fire outgoing events", function()
		local a, b

		instance.OnClientEvent:Connect(function(...)
			a, b = ...
		end)

		remote:fireAll("test", 1)
		expect(a).to.equal("test")
		expect(b).to.equal(1)

		remote:fireAll("test2", 2)
		expect(a).to.equal("test2")
		expect(b).to.equal(2)
	end)

	it("should throw when used after destruction", function()
		remote:destroy()

		expect(function()
			remote:fireAll("test", 1)
		end).to.throw()

		expect(function()
			remote:connect(function() end)
		end).to.throw()
	end)

	it("should not fire disconnected events", function()
		local fired = false
		local disconnect = remote:connect(function()
			fired = true
		end)
		disconnect()
		remote:fireAll("test", 1)
		expect(fired).to.equal(false)
	end)

	it("should apply the middleware", function()
		local middlewareRemote, player, arg1, arg2

		remote = createRemote(
			"test",
			builder.remote(t.string, t.number).middleware(function(next, remote)
				middlewareRemote = remote
				return function(player)
					return next(player, "intercepted", 2)
				end
			end)
		)

		expect(middlewareRemote).to.equal(remote)

		remote:connect(function(...)
			player, arg1, arg2 = ...
		end)

		instance:FireServer("test", 1)

		expect(player).to.be.ok()
		expect(arg1).to.equal("intercepted")
		expect(arg2).to.equal(2)
	end)

	it("should fire the test listeners", function()
		local test1, test2, arg1, arg2

		remote.test:onFire(function(...)
			test1, test2 = ...
		end)

		instance.OnClientEvent:Connect(function(...)
			arg1, arg2 = ...
		end)

		remote:fireAll("test", 1)

		expect(test1).to.equal(arg1)
		expect(test2).to.equal(arg2)

		test1, test2, arg1, arg2 = nil
		remote.test:disconnectAll()
		remote:fireAll("test", 1)

		expect(test1).to.never.be.ok()
		expect(test2).to.never.be.ok()
		expect(arg1).to.equal("test")
		expect(arg2).to.equal(1)
	end)

	it("should be callable", function()
		local a, b

		instance.OnClientEvent:Connect(function(...)
			a, b = ...
		end)

		remote({}, "test", 1)
		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should promise an event", function()
		local player, a, b

		remote:promise():andThen(function(...)
			player, a, b = ...
		end)

		instance:FireServer("test", 1)

		expect(player).to.be.ok()
		expect(a).to.equal("test")
		expect(b).to.equal(1)
	end)

	it("should promise a predicated event", function()
		local player, a, b

		remote
			:promise(function(_, a)
				return a == "true"
			end)
			:andThen(function(...)
				player, a, b = ...
			end)

		instance:FireServer("false", 2)

		expect(player).to.never.be.ok()
		expect(a).to.never.be.ok()
		expect(b).to.never.be.ok()

		instance:FireServer("true", 1)

		expect(player).to.be.ok()
		expect(a).to.equal("true")
		expect(b).to.equal(1)
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="96">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

type Cleanup = () -> ()

type Promise<T...> = Promise.Promise<T...>

export type Validator = any

export type Middleware = (next: (...any) -> ...any, remote: AnyRemote) -> (...any) -> ...any

export type RemoteBuilder = {
	type: RemoteType,
	metadata: RemoteBuilderMetadata,
	returns: (...Validator) -> RemoteBuilder,
	middleware: (...Middleware) -> RemoteBuilder,
	unreliable: () -> RemoteBuilder,
}

export type RemoteBuilderMetadata = {
	parameters: { Validator },
	returns: { Validator },
	middleware: { Middleware },
	unreliable: boolean,
}

export type RemoteNamespace = {
	type: "namespace",
	remotes: RemoteBuilders,
}

export type RemoteBuilders = {
	[string]: RemoteBuilder | RemoteNamespace,
}

export type RemoteType = "event" | "function"

export type AnyRemote = Remote | AsyncRemote

export type Remotes<Map = RemoteMap> = Map & {
	destroy: (self: Remotes<Map>) -> (),
}

export type RemoteMap = {
	[string]: AnyRemote | RemoteMap,
}

export type Remote<Args... = ...any> = ClientToServer<Args...> & ServerToClient<Args...>

export type ClientToServer<Args... = ...any> = ((Args...) -> ()) & {
	name: string,
	type: "event",
	test: TestRemote<Args...>,
	connect: (self: ClientToServer<Args...>, callback: (player: Player, Args...) -> ()) -> Cleanup,
	promise: (
		self: ClientToServer<Args...>,
		predicate: ((player: Player, Args...) -> boolean)?,
		_mapper: ((player: Player, Args...) -> ...any)?
	) -> Promise<(Player, Args...)>,
	fire: (self: ClientToServer<Args...>, Args...) -> (),
	destroy: (self: ClientToServer<Args...>) -> (),
}

export type ServerToClient<Args... = ...any> = ((player: Player, Args...) -> ()) & {
	name: string,
	type: "event",
	test: TestRemote<Args...>,
	connect: (self: ServerToClient<Args...>, callback: (Args...) -> ()) -> Cleanup,
	promise: (
		self: ClientToServer<Args...>,
		predicate: ((Args...) -> boolean)?,
		_mapper: ((Args...) -> ...any)?
	) -> Promise<Args...>,
	fire: (self: ServerToClient<Args...>, player: Player, Args...) -> (),
	firePlayers: (self: ServerToClient<Args...>, players: { Player }, Args...) -> (),
	fireAll: (self: ServerToClient<Args...>, Args...) -> (),
	fireAllExcept: (self: ServerToClient<Args...>, player: Player, Args...) -> (),
	destroy: (self: ServerToClient<Args...>) -> (),
}

export type AsyncRemote<Args... = ...any, Returns... = ...any> =
	ServerAsync<Args..., Returns...>
	& ClientAsync<Args..., Returns...>

export type ServerAsync<Args... = ...any, Returns... = ...any> = ((Args...) -> Promise<Returns...>) & {
	name: string,
	type: "function",
	test: TestAsyncRemote<Args..., Returns...>,
	onRequest: (
		self: ServerAsync<Args..., Returns...>,
		callback: ((player: Player, Args...) -> Returns...) | (player: Player, Args...) -> Promise<Returns...>
	) -> (),
	request: (self: ServerAsync<Args..., Returns...>, Args...) -> Promise<Returns...>,
	destroy: (self: ServerAsync<Args..., Returns...>) -> (),
}

export type ClientAsync<Args... = ...any, Returns... = ...any> = ((player: Player, Args...) -> Promise<Returns...>) & {
	name: string,
	type: "function",
	test: TestAsyncRemote<Args..., Returns...>,
	onRequest: (
		self: ClientAsync<Args..., Returns...>,
		callback: ((Args...) -> Returns...) | (Args...) -> Promise<Returns...>
	) -> (),
	request: (self: ClientAsync<Args..., Returns...>, Args...) -> Promise<Returns...>,
	destroy: (self: ClientAsync<Args..., Returns...>) -> (),
}

export type TestRemote<Args... = ...any> = {
	_fire: (self: TestRemote<Args...>, Args...) -> (),
	onFire: (self: TestRemote<Args...>, callback: (Args...) -> ()) -> Cleanup,
	disconnectAll: (self: TestRemote<Args...>) -> (),
}

export type TestAsyncRemote<Args... = ...any, Returns... = ...any> = {
	_request: (self: TestAsyncRemote<Args..., Returns...>, Args...) -> Returns...,
	handleRequest: (
		self: TestAsyncRemote<Args..., Returns...>,
		callback: ((Args...) -> Returns...) | (Args...) -> Promise<Returns...>
	) -> (),
	hasRequestHandler: (self: TestAsyncRemote<Args..., Returns...>) -> boolean,
	disconnectAll: (self: TestAsyncRemote<Args..., Returns...>) -> (),
}

return nil
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="97">
              <Properties>
                <string name="Name">utils</string>
              </Properties>
              <Item class="ModuleScript" referent="98">
                <Properties>
                  <string name="Name">compose</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local function compose(middlewares: { types.Middleware }): types.Middleware
	local length = #middlewares

	if length == 0 then
		return function(next)
			return next
		end
	elseif length == 1 then
		return middlewares[1]
	end

	return function(next, ...)
		for index = length, 1, -1 do
			next = middlewares[index](next, ...)
		end

		return next
	end
end

return compose
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="99">
                <Properties>
                  <string name="Name">compose.spec</string>
                  <string name="Source"><![CDATA[return function()
	local types = require(script.Parent.Parent.types)
	local compose = require(script.Parent.compose)

	it("should combine the given middleware", function()
		local a, b, c

		local middleware: types.Middleware = function(next)
			return function(...)
				return next(...) + 1
			end
		end

		local composed = compose({ middleware, middleware, middleware })(function(...): ()
			a, b, c = ...
			return 0
		end, {} :: never)

		expect(composed("foo", "bar", "baz")).to.equal(3)
		expect(a).to.equal("foo")
		expect(b).to.equal("bar")
		expect(c).to.equal("baz")
	end)

	it("should work with no middleware", function()
		local a, b, c

		local composed = compose({})(function(...): ()
			a, b, c = ...
			return 123
		end, {} :: never)

		expect(composed("foo", "bar", "baz")).to.equal(123)
		expect(a).to.equal("foo")
		expect(b).to.equal("bar")
		expect(c).to.equal("baz")
	end)

	it("should be cancellable", function()
		local calls = 0

		local middleware: types.Middleware = function(next)
			return function(cancel)
				return if cancel then nil else next()
			end
		end

		local composed = compose({ middleware })(function(): ()
			calls += 1
		end, {} :: never)

		composed(false)
		composed(true)
		composed(false)

		expect(calls).to.equal(2)
	end)

	it("should allow multiple return values", function()
		local middleware: types.Middleware = function(next)
			return function(...)
				return next(...)
			end
		end

		local composed = compose({ middleware, middleware, middleware })(function(): (string, string, string)
			return "foo", "bar", "baz"
		end, {} :: never)

		local a, b, c = composed("foo", "bar", "baz")

		expect(a).to.equal("foo")
		expect(b).to.equal("bar")
		expect(c).to.equal("baz")
	end)

	it("should pass the correct arguments", function()
		local args1, args2, args3 = {}, {}, {}

		local middleware1: types.Middleware = function(next)
			return function(...)
				args1 = { ... }
				return next(...)
			end
		end

		local middleware2: types.Middleware = function(next)
			return function(...)
				args2 = { ... }
				return next(...)
			end
		end

		local middleware3: types.Middleware = function(next)
			return function(...)
				args3 = { ... }
				return next(...)
			end
		end

		local composed = compose({ middleware1, middleware2, middleware3 })(function(...): ()
			return ...
		end, {} :: never)

		composed("foo", "bar", "baz")

		for _, args in { args1, args2, args3 } do
			expect(args[1]).to.equal("foo")
			expect(args[2]).to.equal("bar")
			expect(args[3]).to.equal("baz")
		end
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="100">
                <Properties>
                  <string name="Name">instances</string>
                  <string name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Promise)
local constants = require(script.Parent.Parent.constants)
local mockRemotes = require(script.Parent.mockRemotes)

local container = script.Parent.Parent.container

local function promiseRemoteFunction(name: string): Promise.Promise<RemoteFunction>
	if container:FindFirstChild(name) then
		return Promise.resolve(container[name])
	end

	if constants.IS_EDIT then
		return Promise.resolve(mockRemotes.createMockRemoteFunction(name))
	end

	return Promise.fromEvent(container.ChildAdded, function(child)
		return child:IsA("RemoteFunction") and child.Name == name
	end)
end

local function promiseRemoteEvent(name: string): Promise.Promise<RemoteEvent>
	if container:FindFirstChild(name) then
		return Promise.resolve(container[name])
	end

	if constants.IS_EDIT then
		return Promise.resolve(mockRemotes.createMockRemoteEvent(name))
	end

	return Promise.fromEvent(container.ChildAdded, function(child)
		return child:IsA("RemoteEvent") and child.Name == name
	end)
end

local function createRemoteFunction(name: string): RemoteFunction
	if container:FindFirstChild(name) then
		return container[name]
	end

	if constants.IS_EDIT then
		return mockRemotes.createMockRemoteFunction(name)
	end

	local remoteFunction = Instance.new("RemoteFunction")
	remoteFunction.Name = name
	remoteFunction.Parent = container

	return remoteFunction
end

local function createRemoteEvent(name: string, unreliable: boolean): RemoteEvent
	if container:FindFirstChild(name) then
		return container[name]
	end

	if constants.IS_EDIT then
		return mockRemotes.createMockRemoteEvent(name)
	end

	local remoteEvent = Instance.new(if unreliable then "UnreliableRemoteEvent" else "RemoteEvent")
	remoteEvent.Name = name
	remoteEvent.Parent = container

	return remoteEvent :: RemoteEvent
end

return {
	promiseRemoteFunction = promiseRemoteFunction,
	promiseRemoteEvent = promiseRemoteEvent,
	createRemoteFunction = createRemoteFunction,
	createRemoteEvent = createRemoteEvent,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="101">
                <Properties>
                  <string name="Name">mockRemotes</string>
                  <string name="Source"><![CDATA[local Players = game:GetService("Players")

local mockRemoteEvents: { [string]: RemoteEvent } = {}
local mockRemoteFunctions: { [string]: RemoteFunction } = {}

local function createMockRemoteEvent(name: string): RemoteEvent
	if mockRemoteEvents[name] then
		return mockRemoteEvents[name]
	end

	local remoteEvent: RemoteEvent = {
		Name = name,
		OnClientEvent = {},
		OnServerEvent = {},
	} :: any

	local clientListeners = {}
	local serverListeners = {}

	function remoteEvent.OnClientEvent:Connect(callback: (any) -> ())
		clientListeners[callback] = true

		return {
			Connected = true,
			Disconnect = function(self: RBXScriptConnection)
				self.Connected = false
				clientListeners[callback] = nil
			end,
		} :: never
	end

	function remoteEvent.OnServerEvent:Connect(callback: (any) -> ())
		serverListeners[callback] = true

		return {
			Connected = true,
			Disconnect = function(self: RBXScriptConnection)
				self.Connected = false
				serverListeners[callback] = nil
			end,
		} :: never
	end

	function remoteEvent:FireClient(_player: Player, ...)
		for callback in clientListeners do
			callback(...)
		end
	end

	function remoteEvent:FireAllClients(...)
		for callback in clientListeners do
			callback(...)
		end
	end

	function remoteEvent:FireServer(...)
		for callback in serverListeners do
			callback(Players.LocalPlayer or {}, ...)
		end
	end

	function remoteEvent:Destroy(): ()
		mockRemoteEvents[name] = nil
		table.clear(clientListeners)
		table.clear(serverListeners)
	end

	mockRemoteEvents[name] = remoteEvent

	return remoteEvent
end

local function createMockRemoteFunction(name: string): RemoteFunction
	if mockRemoteFunctions[name] then
		return mockRemoteFunctions[name]
	end

	local remoteFunction: RemoteFunction = {
		Name = name,
		OnClientInvoke = function() end,
		OnServerInvoke = function() end,
	} :: any

	function remoteFunction:InvokeClient(_player: Player, ...)
		return self.OnClientInvoke(...)
	end

	function remoteFunction:InvokeServer(...)
		return self.OnServerInvoke(Players.LocalPlayer or {} :: any, ...)
	end

	function remoteFunction:Destroy(): ()
		mockRemoteFunctions[name] = nil
		remoteFunction.OnClientInvoke = function() end
		remoteFunction.OnServerInvoke = function() end
	end

	mockRemoteFunctions[name] = remoteFunction

	return remoteFunction
end

local function getMockRemoteEvent(name: string): RemoteEvent?
	return mockRemoteEvents[name]
end

local function getMockRemoteFunction(name: string): RemoteFunction?
	return mockRemoteFunctions[name]
end

local function destroyAll()
	table.clear(mockRemoteEvents)
	table.clear(mockRemoteFunctions)
end

return {
	createMockRemoteEvent = createMockRemoteEvent,
	createMockRemoteFunction = createMockRemoteFunction,
	getMockRemoteEvent = getMockRemoteEvent,
	getMockRemoteFunction = getMockRemoteFunction,
	destroyAll = destroyAll,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="102">
                <Properties>
                  <string name="Name">mockRemotes.spec</string>
                  <string name="Source"><![CDATA[return function()
	local mockRemotes = require(script.Parent.mockRemotes)

	afterEach(function()
		mockRemotes.destroyAll()
	end)

	describe("createMockRemoteEvent", function()
		it("should return a RemoteEvent-like object", function()
			local remote = mockRemotes.createMockRemoteEvent("test")
			expect(remote).to.be.ok()
			expect(remote.Name).to.equal("test")
			expect(remote.OnClientEvent).to.be.ok()
			expect(remote.OnServerEvent).to.be.ok()
			expect(remote.FireClient).to.be.ok()
			expect(remote.FireAllClients).to.be.ok()
			expect(remote.FireServer).to.be.ok()
			expect(remote.Destroy).to.be.ok()
		end)

		it("should return the same object for the same name", function()
			local remote1 = mockRemotes.createMockRemoteEvent("test")
			local remote2 = mockRemotes.createMockRemoteEvent("test")
			expect(remote1).to.equal(remote2)
		end)

		it("should fire OnClientEvent listeners", function()
			local remote = mockRemotes.createMockRemoteEvent("test")
			local arguments1, arguments2

			remote.OnClientEvent:Connect(function(...)
				arguments1 = { ... }
			end)

			remote.OnClientEvent:Connect(function(...)
				arguments2 = { ... }
			end)

			remote:FireClient({} :: never, "test", 1)

			expect(arguments1).to.be.ok()
			expect(arguments1[1]).to.equal("test")
			expect(arguments1[2]).to.equal(1)

			expect(arguments2).to.be.ok()
			expect(arguments2[1]).to.equal("test")
			expect(arguments2[2]).to.equal(1)
		end)

		it("should fire OnServerEvent listeners", function()
			local remote = mockRemotes.createMockRemoteEvent("test")
			local arguments1, arguments2

			remote.OnServerEvent:Connect(function(player, ...)
				arguments1 = { player, ... }
			end)

			remote.OnServerEvent:Connect(function(player, ...)
				arguments2 = { player, ... }
			end)

			remote:FireServer("test", 1)

			expect(arguments1).to.be.ok()
			expect(arguments1[1]).to.be.ok()
			expect(arguments1[2]).to.equal("test")
			expect(arguments1[3]).to.equal(1)

			expect(arguments2).to.be.ok()
			expect(arguments1[1]).to.be.ok()
			expect(arguments2[2]).to.equal("test")
			expect(arguments2[3]).to.equal(1)
		end)

		it("should not fire disconnected listeners", function()
			local remote = mockRemotes.createMockRemoteEvent("test")
			local arguments1, arguments2

			local connection = remote.OnServerEvent:Connect(function(player, ...)
				arguments1 = { player, ... }
			end)

			remote.OnServerEvent:Connect(function(player, ...)
				arguments2 = { player, ... }
			end)

			connection:Disconnect()
			remote:FireServer("test", 1)

			expect(arguments1).to.never.be.ok()
			expect(arguments2).to.be.ok()
			expect(arguments2[1]).to.be.ok()
			expect(arguments2[2]).to.equal("test")
			expect(arguments2[3]).to.equal(1)
		end)

		it("should not fire after being destroyed", function()
			local remote = mockRemotes.createMockRemoteEvent("test")
			local arguments

			remote.OnServerEvent:Connect(function(player, ...)
				arguments = { player, ... }
			end)

			remote:Destroy()
			remote:FireServer("test", 1)

			expect(arguments).to.never.be.ok()
		end)

		it("should not fire the wrong listeners", function()
			local client = mockRemotes.createMockRemoteEvent("client")
			local server = mockRemotes.createMockRemoteEvent("server")
			local fired = false

			server.OnServerEvent:Connect(function()
				fired = true
			end)

			client.OnClientEvent:Connect(function()
				fired = true
			end)

			client:FireServer()
			server:FireClient({} :: never)

			expect(fired).to.equal(false)
		end)
	end)

	describe("createMockRemoteFunction", function()
		it("should return a RemoteFunction-like object", function()
			local remote = mockRemotes.createMockRemoteFunction("test")
			expect(remote).to.be.ok()
			expect(remote.Name).to.equal("test")
			expect(remote.OnClientInvoke).to.be.ok()
			expect(remote.OnServerInvoke).to.be.ok()
			expect(remote.InvokeClient).to.be.ok()
			expect(remote.InvokeServer).to.be.ok()
			expect(remote.Destroy).to.be.ok()
		end)

		it("should return the same object for the same name", function()
			local remote1 = mockRemotes.createMockRemoteFunction("test")
			local remote2 = mockRemotes.createMockRemoteFunction("test")
			expect(remote1).to.equal(remote2)
		end)

		it("should invoke the OnClientInvoke callback", function()
			local remote = mockRemotes.createMockRemoteFunction("test")
			local arguments

			function remote.OnClientInvoke(...)
				arguments = { ... }
				return "test"
			end

			local result = remote:InvokeClient({} :: never, 1)

			expect(arguments).to.be.ok()
			expect(arguments[1]).to.equal(1)
			expect(result).to.equal("test")
		end)

		it("should invoke the OnServerInvoke callback", function()
			local remote = mockRemotes.createMockRemoteFunction("test")
			local arguments

			function remote.OnServerInvoke(player, ...)
				arguments = { player, ... }
				return "test"
			end

			local result = remote:InvokeServer(1)

			expect(arguments).to.be.ok()
			expect(arguments[1]).to.be.ok()
			expect(arguments[2]).to.equal(1)
			expect(result).to.equal("test")
		end)

		it("should not invoke after being destroyed", function()
			local remote = mockRemotes.createMockRemoteFunction("test")
			local arguments

			function remote.OnServerInvoke(player, ...)
				arguments = { player, ... }
				return "test"
			end

			remote:Destroy()

			local result = remote:InvokeServer(1)

			expect(arguments).to.never.be.ok()
			expect(result).to.never.be.ok()
		end)

		it("should not invoke the wrong callback", function()
			local client = mockRemotes.createMockRemoteFunction("client")
			local server = mockRemotes.createMockRemoteFunction("server")
			local fired = false

			function server.OnServerInvoke()
				fired = true
			end

			function client.OnClientInvoke()
				fired = true
			end

			client:InvokeServer()
			server:InvokeClient({} :: never)

			expect(fired).to.equal(false)
		end)
	end)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="103">
                <Properties>
                  <string name="Name">testRemote</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local getSender = require(script.Parent.Parent.getSender)

local function noop() end

local function createTestRemote(): types.TestRemote
	local listeners: { (...any) -> () } = {}
	local nextListenerId = 0

	local function fire(_self, first, ...)
		local shouldOmitPlayer = getSender(first)

		for _, listener in listeners do
			if shouldOmitPlayer then
				listener(...)
			else
				listener(first, ...)
			end
		end
	end

	local function onFire(_self, listener)
		local id = nextListenerId
		nextListenerId += 1
		listeners[id] = listener

		return function()
			listeners[id] = nil
		end
	end

	local function disconnectAll(_self)
		table.clear(listeners)
	end

	local testRemote: types.TestRemote = {
		_fire = fire,
		onFire = onFire,
		disconnectAll = disconnectAll,
	}

	return testRemote
end

local function createTestAsyncRemote(): types.TestAsyncRemote
	local handler: (...any) -> () = noop

	local function request(_self, first, ...)
		return if getSender(first) then handler(...) else handler(first, ...)
	end

	local function handleRequest(_self, newHandler)
		handler = newHandler
	end

	local function hasRequestHandler()
		return handler ~= noop
	end

	local function disconnectAll()
		handler = noop
	end

	local testAsyncRemote: types.TestAsyncRemote = {
		_request = request,
		handleRequest = handleRequest,
		hasRequestHandler = hasRequestHandler,
		disconnectAll = disconnectAll,
	}

	return testAsyncRemote
end

return {
	createTestRemote = createTestRemote,
	createTestAsyncRemote = createTestAsyncRemote,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="104">
                <Properties>
                  <string name="Name">unwrap</string>
                  <string name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Promise)

type Promise<T> = Promise.Promise<T>

local function unwrap<T>(...: Promise<T> | T): T
	if Promise.is(...) then
		return (... :: Promise<T>):expect()
	end

	return (...) :: T
end

return unwrap
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="105">
          <Properties>
            <string name="Name">nezuo_lapis@0.3.4</string>
          </Properties>
          <Item class="ModuleScript" referent="106">
            <Properties>
              <string name="Name">Promise</string>
              <string name="Source">local module = require(script.Parent.Parent["evaera_promise@4.0.0"]["promise"])
return module</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="107">
            <Properties>
              <string name="Name">lapis</string>
              <string name="Source"><![CDATA[--!strict

local Internal = require(script.Internal)
local PromiseTypes = require(script.PromiseTypes)

local internal = Internal.new(true)

type Migrate = (data: any, key: string) -> any
type Migration = Migrate | { backwardsCompatible: boolean?, migrate: Migrate }

export type DataStoreService = {
	GetDataStore: (name: string) -> GlobalDataStore,
	GetRequestBudgetForRequestType: (requestType: Enum.DataStoreRequestType) -> number,
}

export type PartialLapisConfig = {
	saveAttempts: number?,
	loadAttempts: number?,
	loadRetryDelay: number?,
	showRetryWarnings: boolean?,
	dataStoreService: DataStoreService?,
	[any]: nil,
}

export type CollectionOptions<T> = {
	defaultData: T | (key: string) -> T,
	migrations: { Migration }?,
	validate: ((any) -> (boolean, string?))?,
	freezeData: boolean?,
	[any]: nil,
}

export type Collection<T> = {
	load: (self: Collection<T>, key: string, defaultUserIds: { number }?) -> PromiseTypes.TypedPromise<Document<T>>,
	read: (self: Collection<T>, key: string) -> PromiseTypes.TypedPromise<T?>,
	remove: (self: Collection<T>, key: string) -> PromiseTypes.TypedPromise<()>,
}

export type Document<T> = {
	read: (self: Document<T>) -> T,
	write: (self: Document<T>, T) -> (),
	addUserId: (self: Document<T>, userId: number) -> (),
	removeUserId: (self: Document<T>, userId: number) -> (),
	save: (self: Document<T>) -> PromiseTypes.TypedPromise<()>,
	close: (self: Document<T>) -> PromiseTypes.TypedPromise<()>,
	beforeSave: (self: Document<T>, callback: () -> ()) -> (),
	beforeClose: (self: Document<T>, callback: () -> ()) -> (),
}

--[=[
	@class Lapis
]=]
local Lapis = {}

--[=[
	@interface PartialLapisConfig
	@within Lapis
	.saveAttempts number? -- Max save/close retry attempts
	.loadAttempts number? -- Max load retry attempts
	.loadRetryDelay number? -- Seconds between load attempts
	.showRetryWarnings boolean? -- Show warning on retry
	.dataStoreService (DataStoreService | table)? -- Useful for mocking DataStoreService, especially in a local place
]=]

--[=[
	@type Migration (data: any, key: string) -> any | { backwardsCompatible: boolean?, migrate: (data: any, key: string) -> any }
	@within Lapis
]=]

--[=[
	```lua
	Lapis.setConfig({
		saveAttempts = 10,
		showRetryWarnings = false,
	})
	```

	```lua
	-- The default config values:
	{
		saveAttempts = 5,
		loadAttempts = 20,
		loadRetryDelay = 1,
		showRetryWarnings = true,
		dataStoreService = DataStoreService,
	}
	```

	@param partialConfig PartialLapisConfig
]=]
function Lapis.setConfig(partialConfig: PartialLapisConfig)
	internal.setConfig(partialConfig)
end

--[=[
	@interface CollectionOptions<T>
	@within Lapis
	.validate ((any) -> true | (false, string))? -- Takes a document's data and returns true on success or false and an error on fail.
	.defaultData T | (key: string) -> T -- If set to a function, it's called when a new document is created and is passed the key of the document.
	.freezeData boolean? -- If `true`, data will be deep frozen and can only be updated immutably by calling [`Document:write`](Document#write). Default: `true`
	.migrations { Migration }? -- Migrations take old data and return new data. Order is first to last. For more information, see: [Migrations](../docs/Migrations).
]=]

--[=[
	Creates a [Collection].

	@param name string
	@param options CollectionOptions
	@return Collection
]=]
function Lapis.createCollection<T>(name: string, options: CollectionOptions<T>): Collection<T>
	return internal.createCollection(name, options)
end

return Lapis
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="108">
              <Properties>
                <string name="Name">AutoSave</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Promise = require(script.Parent.Parent.Promise)

local UPDATE_INTERVAL = 5 * 60

local AutoSave = {}
AutoSave.__index = AutoSave

function AutoSave.new(data)
	return setmetatable({
		documents = {},
		data = data,
		gameClosed = false,
		ongoingLoads = 0,
		ongoingRemoveLocks = 0,
	}, AutoSave)
end

function AutoSave:addDocument(document)
	table.insert(self.documents, document)
end

function AutoSave:removeDocument(document)
	local index = table.find(self.documents, document)

	table.remove(self.documents, index)
end

function AutoSave:finishLoad(document)
	if self.gameClosed then
		document:close()
	end

	self.ongoingLoads -= 1
end

function AutoSave:onGameClose()
	self.gameClosed = true
	self.data.throttle.gameClosed = true

	while #self.documents > 0 do
		self.documents[#self.documents]:close()
	end

	Promise.try(function()
		while self.ongoingLoads > 0 do
			task.wait()
		end
	end)
		:andThen(function()
			return Promise.allSettled({
				self.data:waitForOngoingSaves(),
				Promise.try(function()
					while self.ongoingRemoveLocks > 0 do
						task.wait()
					end
				end),
			})
		end)
		:await()
end

function AutoSave:start()
	local nextUpdateAt = os.clock() + UPDATE_INTERVAL
	RunService.Heartbeat:Connect(function()
		if os.clock() >= nextUpdateAt then
			for _, document in self.documents do
				document:save():catch(warn)
			end

			nextUpdateAt += UPDATE_INTERVAL
		end
	end)

	game:BindToClose(function()
		self:onGameClose()
	end)
end

return AutoSave
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="109">
              <Properties>
                <string name="Name">Collection</string>
                <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Document = require(script.Parent.Document)
local Error = require(script.Parent.Error)
local freezeDeep = require(script.Parent.freezeDeep)
local Migration = require(script.Parent.Migration)
local Promise = require(script.Parent.Parent.Promise)
local copyDeep = require(script.Parent.copyDeep)

local LOCK_EXPIRE = 30 * 60

--[=[
	Collections are analagous to [GlobalDataStore].

	@class Collection
]=]
local Collection = {}
Collection.__index = Collection

function Collection.new(name, options, data, autoSave, config)
	if typeof(options.defaultData) ~= "function" and options.validate ~= nil then
		assert(options.validate(options.defaultData))
	end

	local migrations = {}
	if options.migrations ~= nil then
		for _, migration in options.migrations do
			if typeof(migration) == "function" then
				table.insert(migrations, { migrate = migration })
			else
				table.insert(migrations, migration)
			end
		end
	end
	options.migrations = migrations

	options.freezeData = if options.freezeData ~= nil then options.freezeData else true

	freezeDeep(options)

	return setmetatable({
		dataStore = config:get("dataStoreService"):GetDataStore(name),
		options = options,
		data = data,
		autoSave = autoSave,
	}, Collection)
end

--[=[
	Loads the document with `key`, migrates it, and session locks it.

	If specified, the document's `DataStoreKeyInfo:GetUserIds()` will be set to `defaultUserIds` if the document has
	never been loaded.

	@param key string
	@param defaultUserIds {number}?
	@return Promise<Document>
]=]
function Collection:load(key, defaultUserIds)
	if self.autoSave.gameClosed then
		-- If game:BindToClose has been called, this infinitely yields so the document can't load.
		return Promise.new(function() end)
	end

	local lockId = HttpService:GenerateGUID(false)

	self.autoSave.ongoingLoads += 1

	return self.data
		:load(self.dataStore, key, function(value, keyInfo)
			if value == nil then
				local defaultData
				if typeof(self.options.defaultData) == "function" then
					local defaultOk, tailoredDefaultData = pcall(self.options.defaultData, key)
					if not defaultOk then
						return "fail",
							Error.new("DefaultDataThrew", `'defaultData' threw an error: {tailoredDefaultData}`)
					end

					if self.options.validate ~= nil then
						local validateOk, valid, message = pcall(self.options.validate, tailoredDefaultData)
						if not validateOk then
							return "fail", Error.new("ValidateThrew", `'validate' threw an error: {valid}`)
						elseif not valid then
							return "fail", Error.new("ValidateFailed", `Invalid data: {message}`)
						end
					end

					defaultData = copyDeep(tailoredDefaultData)
				else
					-- The data was validated when the collection was created.
					defaultData = if self.options.freezeData
						then self.options.defaultData
						else copyDeep(self.options.defaultData)
				end

				local data = {
					migrationVersion = #self.options.migrations,
					lastCompatibleVersion = Migration.getLastCompatibleVersion(self.options.migrations),
					lockId = lockId,
					data = defaultData,
				}

				return "succeed", data, defaultUserIds
			end

			if
				value.lockId ~= nil
				and (DateTime.now().UnixTimestampMillis - keyInfo.UpdatedTime) / 1000 < LOCK_EXPIRE
			then
				return "retry", Error.new("SessionLocked", "Could not acquire lock")
			end

			local savedVersion = value.migrationVersion

			local migrationOk, migrated, lastCompatibleVersion = Migration.migrate(self.options.migrations, value, key)
			if not migrationOk then
				return "fail", Error.new("MigrationError", migrated)
			end

			if self.options.validate ~= nil then
				local validateOk, valid, message = pcall(self.options.validate, migrated)
				if not validateOk then
					return "fail", Error.new("ValidateThrew", `'validate' threw an error: {valid}`)
				elseif not valid then
					return "fail", Error.new("ValidateFailed", `Invalid data: {message}`)
				end
			end

			local data = {
				migrationVersion = math.max(savedVersion, #self.options.migrations),
				lastCompatibleVersion = lastCompatibleVersion,
				lockId = lockId,
				data = migrated,
			}

			return "succeed", data, keyInfo:GetUserIds(), keyInfo:GetMetadata()
		end)
		:andThen(function(value, keyInfo)
			if value == "cancelled" then
				self.autoSave.ongoingLoads -= 1

				-- Infinitely yield because the load was cancelled by game:BindToClose.
				return Promise.new(function() end)
			end

			local data = value.data

			if self.options.freezeData then
				freezeDeep(data)
			end

			local document = Document.new(self, key, self.options.validate, lockId, data, keyInfo)

			self.autoSave:finishLoad(document)

			if self.autoSave.gameClosed then
				-- Infinitely yield because the document will automatically be closed.
				return Promise.new(function() end)
			end

			self.autoSave:addDocument(document)

			return document
		end)
		:catch(function(err)
			self.autoSave.ongoingLoads -= 1

			return Promise.reject(`DataStoreFailure({err.message})`)
		end)
end

--[=[
	Reads the data of the document with `key` regardless of whether it is session locked. This is useful for viewing a
	document without editing or session locking it. The data gets migrated but not saved.

	If the document has never been loaded, the promise will return `nil`.

	[DataStoreGetOptions.UseCache](https://create.roblox.com/docs/reference/engine/classes/DataStoreGetOptions#UseCache) is disabled.

	@param key string
	@return Promise<T?>
]=]
function Collection:read(key)
	return self.data:read(self.dataStore, key):andThen(function(value, keyInfo)
		if value == nil then
			return nil
		end

		local migrationOk, migrated = Migration.migrate(self.options.migrations, value, key)
		if not migrationOk then
			return Promise.reject(migrated)
		end

		if self.options.validate ~= nil then
			local validateOk, valid, message = pcall(self.options.validate, migrated)
			if not validateOk then
				return Promise.reject(`'validate' threw an error: {valid}`)
			elseif not valid then
				return Promise.reject(`Invalid data: {message}`)
			end
		end

		return value.data, keyInfo
	end)
end

--[=[
	Removes the data of the document with `key`.

	If a document is open while `remove` is called, the open document will fail to save/close and the data will still be removed.

	@param key string
	@return Promise<()>
]=]
function Collection:remove(key)
	return self.data:remove(self.dataStore, key)
end

return Collection
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="110">
              <Properties>
                <string name="Name">Config</string>
                <string name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local Config = {}
Config.__index = Config

function Config.new()
	return setmetatable({
		config = {
			saveAttempts = 5,
			loadAttempts = 20,
			loadRetryDelay = 1,
			showRetryWarnings = true,
			dataStoreService = DataStoreService,
		},
	}, Config)
end

function Config:get(key)
	return self.config[key]
end

function Config:set(values)
	for key, value in values do
		if self.config[key] == nil then
			error(`Invalid config key "{tostring(key)}"`)
		end

		self.config[key] = value
	end
end

return Config
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="111">
              <Properties>
                <string name="Name">Data</string>
                <string name="Source"><![CDATA[local Error = require(script.Parent.Error)
local Promise = require(script.Parent.Parent.Promise)
local Throttle = require(script.Throttle)

local Data = {}
Data.__index = Data

function Data.new(config)
	local throttle = Throttle.new(config)

	throttle:start()

	return setmetatable({
		config = config,
		throttle = throttle,
		ongoingSaves = {},
	}, Data)
end

function Data:waitForOngoingSave(dataStore, key)
	if self.ongoingSaves[dataStore] == nil or self.ongoingSaves[dataStore][key] == nil then
		return Promise.resolve()
	end

	local ongoingSave = self.ongoingSaves[dataStore][key]

	return Promise.allSettled({
		ongoingSave.promise,
		if ongoingSave.pendingSave ~= nil then ongoingSave.pendingSave.promise else nil,
	})
end

function Data:waitForOngoingSaves()
	local promises = {}

	for _, ongoingSaves in self.ongoingSaves do
		for _, ongoingSave in ongoingSaves do
			if ongoingSave.pendingSave ~= nil then
				table.insert(promises, ongoingSave.pendingSave.promise)
			end

			table.insert(promises, ongoingSave.promise)
		end
	end

	return Promise.allSettled(promises)
end

function Data:read(dataStore, key)
	return self.throttle:getAsync(dataStore, key)
end

function Data:load(dataStore, key, transform)
	return self:waitForOngoingSave(dataStore, key):andThen(function()
		local attempts = self.config:get("loadAttempts")
		local retryDelay = self.config:get("loadRetryDelay")

		return self.throttle:updateAsync(dataStore, key, transform, true, attempts, retryDelay)
	end)
end

function Data:save(dataStore, key, transform)
	if self.ongoingSaves[dataStore] == nil then
		self.ongoingSaves[dataStore] = {}
	end

	local ongoingSave = self.ongoingSaves[dataStore][key]

	if ongoingSave == nil then
		local attempts = self.config:get("saveAttempts")
		local promise = self.throttle:updateAsync(dataStore, key, transform, false, attempts):finally(function()
			self.ongoingSaves[dataStore][key] = nil

			if next(self.ongoingSaves[dataStore]) == nil then
				self.ongoingSaves[dataStore] = nil
			end
		end)

		if promise:getStatus() == Promise.Status.Started then
			self.ongoingSaves[dataStore][key] = { promise = promise }
		end

		return promise
	elseif ongoingSave.pendingSave == nil then
		local pendingSave = { transform = transform }

		local function save()
			return self:save(dataStore, key, pendingSave.transform)
		end

		-- promise:finally(save) can't be used because if the ongoingSave promise rejects, so will the promise returned from finally.
		pendingSave.promise = ongoingSave.promise:andThen(save, save)

		ongoingSave.pendingSave = pendingSave

		return pendingSave.promise
	else
		ongoingSave.pendingSave.transform = transform

		return ongoingSave.pendingSave.promise
	end
end

function Data:removeLock(dataStore, key, lockIdToRemove)
	local function transform(value, keyInfo)
		if value == nil then
			return "fail", Error.new("DocumentRemoved", "The document was removed")
		end

		if value.lockId ~= lockIdToRemove then
			return "fail", Error.new("SessionLockStolen", "The session lock was stolen")
		end

		value.lockId = nil

		return "succeed", value, keyInfo:GetUserIds(), keyInfo:GetMetadata()
	end

	local attempts = self.config:get("saveAttempts")

	return self.throttle:updateAsync(dataStore, key, transform, false, attempts)
end

function Data:remove(dataStore, key)
	return self.throttle:removeAsync(dataStore, key)
end

return Data
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="112">
                <Properties>
                  <string name="Name">Throttle</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Error = require(script.Parent.Parent.Error)
local Promise = require(script.Parent.Parent.Parent.Promise)

local GET_ASYNC_RETRY_ATTEMPTS = 5
local GET_ASYNC_RETRY_DELAY = 1

local REMOVE_ASYNC_RETRY_ATTEMPTS = 5
local REMOVE_ASYNC_RETRY_DELAY = 1

local getAsyncOptions = Instance.new("DataStoreGetOptions")
getAsyncOptions.UseCache = false

local function updateAsync(throttle, request)
	return Promise.new(function(resolve)
		local resultOutside, transformedOutside, keyInfo
		local ok, err = pcall(function()
			_, keyInfo = request.dataStore:UpdateAsync(request.key, function(...)
				if request.cancelOnGameClose and throttle.gameClosed then
					resultOutside = "cancelled"
					return nil
				end

				local result, transformed, userIds, metadata = request.transform(...)

				resultOutside = result
				transformedOutside = transformed

				if result == "succeed" then
					return transformed, userIds, metadata
				else
					return nil
				end
			end)
		end)

		if resultOutside == "cancelled" then
			resolve("cancelled")
		elseif not ok then
			resolve("retry", Error.new("RobloxApiError", err))
		else
			resolve(resultOutside, transformedOutside, keyInfo)
		end
	end)
end

local function getAsync(request)
	return Promise.new(function(resolve)
		local ok, value, keyInfo = pcall(function()
			return request.dataStore:GetAsync(request.key, getAsyncOptions)
		end)

		resolve(ok, value, keyInfo)
	end)
end

local function removeAsync(request)
	return Promise.new(function(resolve)
		local ok, message = pcall(function()
			request.dataStore:RemoveAsync(request.key)
		end)

		resolve(ok, message)
	end)
end

local Throttle = {}
Throttle.__index = Throttle

function Throttle.new(config)
	return setmetatable({
		config = config,
		updateAsyncQueue = {},
		getAsyncQueue = {},
		removeAsyncQueue = {},
		gameClosed = false,
	}, Throttle)
end

function Throttle:getUpdateAsyncBudget()
	return self.config:get("dataStoreService"):GetRequestBudgetForRequestType(Enum.DataStoreRequestType.UpdateAsync)
end

function Throttle:getGetAsyncBudget()
	return self.config:get("dataStoreService"):GetRequestBudgetForRequestType(Enum.DataStoreRequestType.GetAsync)
end

function Throttle:getRemoveAsyncBudget()
	return self.config
		:get("dataStoreService")
		:GetRequestBudgetForRequestType(Enum.DataStoreRequestType.SetIncrementAsync)
end

function Throttle:start()
	local function retryRequest(request, err)
		request.attempts -= 1

		if request.attempts == 0 then
			request.reject(err)
		else
			if self.config:get("showRetryWarnings") then
				warn(`DataStore operation failed. Retrying...\nError: {err.message}`)
			end

			task.wait(request.retryDelay)
		end
	end

	local function updateUpdateAsync()
		for index = #self.updateAsyncQueue, 1, -1 do
			local request = self.updateAsyncQueue[index]

			if request.attempts == 0 then
				table.remove(self.updateAsyncQueue, index)
			elseif request.promise == nil and request.cancelOnGameClose and self.gameClosed then
				request.resolve("cancelled")
				table.remove(self.updateAsyncQueue, index)
			end
		end

		for _, request in self.updateAsyncQueue do
			if self:getUpdateAsyncBudget() == 0 then
				break
			end

			if request.promise ~= nil then
				continue
			end

			local promise = updateAsync(self, request):andThen(function(result, value, keyInfo)
				if result == "cancelled" then
					request.attempts = 0
					request.resolve("cancelled")
				elseif result == "succeed" then
					request.attempts = 0
					request.resolve(value, keyInfo)
				elseif result == "fail" then
					request.attempts = 0
					request.reject(value)
				elseif result == "retry" then
					retryRequest(request, value)
				else
					error("unreachable")
				end

				request.promise = nil
			end)

			if promise:getStatus() == Promise.Status.Started then
				request.promise = promise
			end
		end
	end

	local function updateGetAsync()
		for index = #self.getAsyncQueue, 1, -1 do
			local request = self.getAsyncQueue[index]

			if request.attempts == 0 then
				table.remove(self.getAsyncQueue, index)
			end
		end

		for _, request in self.getAsyncQueue do
			if self:getGetAsyncBudget() == 0 then
				break
			end

			if request.promise ~= nil then
				continue
			end

			local promise = getAsync(request):andThen(function(ok, value, keyInfo)
				if ok then
					request.attempts = 0
					request.resolve(value, keyInfo)
				else
					retryRequest(request, value)
				end

				request.promise = nil
			end)

			if promise:getStatus() == Promise.Status.Started then
				request.promise = promise
			end
		end
	end

	local function updateRemoveAsync()
		for index = #self.removeAsyncQueue, 1, -1 do
			local request = self.removeAsyncQueue[index]

			if request.attempts == 0 then
				table.remove(self.removeAsyncQueue, index)
			end
		end

		for _, request in self.removeAsyncQueue do
			if self:getRemoveAsyncBudget() == 0 then
				break
			end

			if request.promise ~= nil then
				continue
			end

			local promise = removeAsync(request):andThen(function(ok, message)
				if ok then
					request.attempts = 0
					request.resolve()
				else
					retryRequest(request, message)
				end

				request.promise = nil
			end)

			if promise:getStatus() == Promise.Status.Started then
				request.promise = promise
			end
		end
	end

	RunService.PostSimulation:Connect(function()
		updateUpdateAsync()
		updateGetAsync()
		updateRemoveAsync()
	end)
end

function Throttle:updateAsync(dataStore, key, transform, cancelOnGameClose, retryAttempts, retryDelay)
	return Promise.new(function(resolve, reject)
		table.insert(self.updateAsyncQueue, {
			dataStore = dataStore,
			key = key,
			transform = transform,
			attempts = retryAttempts,
			retryDelay = retryDelay,
			cancelOnGameClose = cancelOnGameClose,
			resolve = resolve,
			reject = reject,
		})
	end)
end

function Throttle:getAsync(dataStore, key)
	return Promise.new(function(resolve, reject)
		table.insert(self.getAsyncQueue, {
			dataStore = dataStore,
			key = key,
			attempts = GET_ASYNC_RETRY_ATTEMPTS,
			retryDelay = GET_ASYNC_RETRY_DELAY,
			resolve = resolve,
			reject = reject,
		})
	end)
end

function Throttle:removeAsync(dataStore, key)
	return Promise.new(function(resolve, reject)
		table.insert(self.removeAsyncQueue, {
			dataStore = dataStore,
			key = key,
			attempts = REMOVE_ASYNC_RETRY_ATTEMPTS,
			retryDelay = REMOVE_ASYNC_RETRY_DELAY,
			resolve = resolve,
			reject = reject,
		})
	end)
end

return Throttle
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="113">
              <Properties>
                <string name="Name">Document</string>
                <string name="Source"><![CDATA[local Error = require(script.Parent.Error)
local freezeDeep = require(script.Parent.freezeDeep)
local Promise = require(script.Parent.Parent.Promise)
local noYield = require(script.Parent.noYield)

local function runCallback(document, name, callback)
	if callback == nil then
		return Promise.resolve()
	end

	document.callingCallback = name

	return Promise.new(function(resolve, reject)
		local ok, message = pcall(noYield, callback)

		document.callingCallback = nil

		if not ok then
			reject(Error.new("BeforeSaveCloseCallbackThrew", `{name} callback threw error: {message}`))
		else
			resolve()
		end
	end)
end

--[=[
	@class Document
]=]
local Document = {}
Document.__index = Document

function Document.new(collection, key, validate, lockId, data, keyInfo)
	return setmetatable({
		collection = collection,
		key = key,
		validate = validate,
		lockId = lockId,
		data = data,
		userIds = keyInfo:GetUserIds(),
		lastKeyInfo = keyInfo,
		closed = false,
	}, Document)
end

--[=[
	Returns the document's data.

	@return any
]=]
function Document:read()
	return self.data
end

--[=[
	Updates the document's cached data. This method doesn't save the data to the DataStore; it only modifies the
	document's in-memory data.

	This method should be used when performing immutable updates to the document's data. For mutable updates, the data
	can be directly modified:
	```lua
	local data = document:read()
	data.coins += 100
	```

	:::warning
	Throws an error if the document was closed or if the data is invalid.
	:::

	@param data any
]=]
function Document:write(data)
	assert(not self.closed, "Cannot write to a closed document")

	if self.validate ~= nil then
		assert(self.validate(data))
	end

	if self.collection.options.freezeData then
		freezeDeep(data)
	end

	self.data = data
end

--[=[
	Adds a user id to the document's `DataStoreKeyInfo:GetUserIds()`. The change won't apply until the document is
	saved or closed.

	If the user id is already associated with the document the method won't do anything.

	@param userId number
]=]
function Document:addUserId(userId)
	assert(not self.closed, "Cannot add user id to a closed document")

	if table.find(self.userIds, userId) == nil then
		table.insert(self.userIds, userId)
	end
end

--[=[
	Removes a user id from the document's `DataStoreKeyInfo:GetUserIds()`. The change won't apply until the document is
	saved or closed.

	If the user id is not associated with the document the method won't do anything.

	@param userId number
]=]
function Document:removeUserId(userId)
	assert(not self.closed, "Cannot remove user id from a closed document")

	local index = table.find(self.userIds, userId)

	if index ~= nil then
		table.remove(self.userIds, index)
	end
end

--[=[
	Returns the last updated `DataStoreKeyInfo` returned from loading, saving, or closing the document.

	@return DataStoreKeyInfo
]=]
function Document:keyInfo()
	return self.lastKeyInfo
end

--[=[
	Saves the document's data. If the save is throttled and you call it multiple times, it will save only once with the
	latest data.

	Documents are saved automatically. This method is used mainly to handle developer product purchases
	(see the [example](../docs/DeveloperProduct)) or other situations requiring immediate saving.

	:::warning
	Throws an error if the document was closed.
	:::

	:::warning
	If the beforeSave callback yields or errors, the returned promise will reject and the data will not be saved.
	:::

	@return Promise<()>
]=]
function Document:save()
	assert(not self.closed, "Cannot save a closed document")
	assert(self.callingCallback == nil, `Cannot save in {self.callingCallback} callback`)

	return runCallback(self, "beforeSave", self.beforeSaveCallback)
		:andThen(function()
			return self.collection.data
				:save(self.collection.dataStore, self.key, function(value, keyInfo)
					if value == nil then
						return "fail", Error.new("DocumentRemoved", "The document was removed")
					end

					if value.lockId ~= self.lockId then
						return "fail", Error.new("SessionLockStolen", "The session lock was stolen")
					end

					if not self.collection.options.freezeData and self.validate ~= nil then
						local validateOk, valid, message = pcall(self.validate, self.data)
						if not validateOk then
							return "fail", Error.new("ValidateThrew", `'validate' threw an error: {valid}`)
						elseif not valid then
							return "fail", Error.new("ValidateFailed", `Invalid data: {message}`)
						end
					end

					value.data = self.data

					return "succeed", value, self.userIds, keyInfo:GetMetadata()
				end)
				:andThen(function(_, keyInfo)
					self.lastKeyInfo = keyInfo
				end)
		end)
		:catch(function(err)
			return Promise.reject(`DataStoreFailure({err.message})`)
		end)
end

--[=[
	Saves the document and removes the session lock. The document is unusable after calling. If a save is currently in
	progress it will close the document instead.

	If called again, it will return the promise from the original call.

	:::warning
	If the beforeSave or beforeClose callbacks yield or error, the returned promise will reject and the data will not be saved.
	:::

	@return Promise<()>
]=]
function Document:close()
	assert(self.callingCallback == nil, `Cannot close in {self.callingCallback} callback`)

	if self.closePromise == nil then
		self.closePromise = runCallback(self, "beforeSave", self.beforeSaveCallback)
			:andThenCall(runCallback, self, "beforeClose", self.beforeCloseCallback)
			:finally(function()
				self.closed = true

				self.collection.autoSave:removeDocument(self)
			end)
			:andThen(function()
				return self.collection.data:save(self.collection.dataStore, self.key, function(value, keyInfo)
					if value == nil then
						return "fail", Error.new("DocumentRemoved", "The document was removed")
					end

					if value.lockId ~= self.lockId then
						return "fail", Error.new("SessionLockStolen", "The session lock was stolen")
					end

					if not self.collection.options.freezeData and self.validate ~= nil then
						local validateOk, valid, message = pcall(self.validate, self.data)
						if not validateOk then
							return "fail", Error.new("ValidateThrew", `'validate' threw an error: {valid}`)
						elseif not valid then
							return "fail", Error.new("ValidateFailed", `Invalid data: {message}`)
						end
					end

					value.data = self.data
					value.lockId = nil

					return "succeed", value, self.userIds, keyInfo:GetMetadata()
				end)
			end)
			:andThen(function(_, keyInfo)
				self.lastKeyInfo = keyInfo
			end)
			:catch(function(err)
				if
					err.kind == "BeforeSaveCloseCallbackThrew"
					or err.kind == "ValidateThrew"
					or err.kind == "ValidateFailed"
				then
					self.collection.autoSave.ongoingRemoveLocks += 1

					self.collection.data
						:removeLock(self.collection.dataStore, self.key, self.lockId)
						:catch(function(removeLockErr)
							warn(`RemoveLockFailure({removeLockErr.message})`)
						end)
						:finally(function()
							self.collection.autoSave.ongoingRemoveLocks -= 1
						end)
				end

				return Promise.reject(`DataStoreFailure({err.message})`)
			end)
	end

	return self.closePromise
end

--[=[
	Sets a callback that is run inside `document:save` and `document:close` before it saves. The document can be read and written to in the
	callback.

	The callback will run before the beforeClose callback inside of `document:close`.

	:::warning
	Throws an error if it was called previously.
	:::

	@param callback () -> ()
]=]
function Document:beforeSave(callback)
	assert(self.beforeSaveCallback == nil, "Document:beforeSave can only be called once")

	self.beforeSaveCallback = callback
end

--[=[
	Sets a callback that is run inside `document:close` before it saves. The document can be read and written to in the
	callback.

	:::warning
	Throws an error if it was called previously.
	:::

	@param callback () -> ()
]=]
function Document:beforeClose(callback)
	assert(self.beforeCloseCallback == nil, "Document:beforeClose can only be called once")

	self.beforeCloseCallback = callback
end

return Document
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="114">
              <Properties>
                <string name="Name">Document.test</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Promise = require(ReplicatedStorage.Packages.Promise)

local function defaultOptions()
	return {
		validate = function(data)
			return typeof(data.foo) == "string", "foo must be a string"
		end,
		defaultData = { foo = "bar" },
	}
end

return function(x)
	local assertEqual = x.assertEqual
	local shouldThrow = x.shouldThrow

	x.test("it should not merge close into save when save is running", function(context)
		local document = context.lapis.createCollection("collection", defaultOptions()):load("doc"):expect()

		-- It's not safe to merge saves when UpdateAsync is running.
		-- This will yield the UpdateAsync call until stopYield is called.
		context.dataStoreService.yield:startYield()

		local save = document:save()
		document:write({ foo = "new" })
		local close = document:close()

		context.dataStoreService.yield:stopYield()

		Promise.all({ save, close }):expect()

		local saved = context.read("collection", "doc")

		-- If data.foo == "bar", that means the close was merged with the save when it wasn't safe to.
		assert(saved.data.foo == "new", "")
	end)

	x.test("it should merge pending saves", function(context)
		local document = context.lapis.createCollection("collection", defaultOptions()):load("doc"):expect()

		context.dataStoreService.yield:startYield()

		local ongoingSave = document:save()

		local pendingSave = document:save()
		local pendingClose = document:close() -- This should override the pending save.

		context.dataStoreService.yield:stopYield()

		local values = Promise.all({ ongoingSave, pendingSave }):expect()

		-- This stops the close if it wasn't merged.
		context.dataStoreService.yield:startYield()

		-- Since the following code is resumed by the save promise, we need to wait for the close promise to resolve.
		task.wait()

		pendingClose:now("save and close didn't merge"):expect()

		-- save and close should never resolve with a value.
		-- It's checked in this test to make sure it works with save merging.
		assert(#values == 0, "")

		local saved = context.read("collection", "doc")

		assert(saved.lockId == nil, "")
	end)

	x.test("saves data", function(context)
		local document = context.lapis.createCollection("12345", defaultOptions()):load("doc"):expect()

		document:write({
			foo = "new value",
		})

		document:save():expect()

		local saved = context.read("12345", "doc")

		assert(typeof(saved) == "table", "")
		assert(typeof(saved.lockId) == "string", "")
		assert(saved.data.foo == "new value", "")
	end)

	x.test("writes the data", function(context)
		local document = context.lapis.createCollection("1", defaultOptions()):load("doc"):expect()

		document:write({
			foo = "baz",
		})

		assert(document:read().foo == "baz", "")
	end)

	x.test("write throws if data doesn't validate", function(context)
		local document = context.lapis.createCollection("2", defaultOptions()):load("doc"):expect()

		shouldThrow(function()
			document:write({
				foo = 5,
			})
		end, "foo must be a string")
	end)

	x.test("methods throw when called on a closed document", function(context)
		local document = context.lapis.createCollection("5", defaultOptions()):load("doc"):expect()

		local promise = document:close()

		shouldThrow(function()
			document:write({})
		end, "Cannot write to a closed document")

		shouldThrow(function()
			document:save()
		end, "Cannot save a closed document")

		shouldThrow(function()
			document:addUserId(1234)
		end, "Cannot add user id to a closed document")

		shouldThrow(function()
			document:removeUserId(1234)
		end, "Cannot remove user id from a closed document")

		promise:expect()
	end)

	x.test("close returns first promise when called again", function(context)
		local document = context.lapis.createCollection("col", defaultOptions()):load("doc"):expect()

		local promise = document:close()

		assertEqual(promise, document:close())
	end)

	x.test("loads with default data", function(context)
		local document = context.lapis.createCollection("o", defaultOptions()):load("a"):expect()

		assert(document:read().foo == "bar", "")
	end)

	x.test("loads with existing data", function(context)
		local collection = context.lapis.createCollection("xyz", defaultOptions())

		context.write("xyz", "xyz", {
			foo = "existing",
		})

		local document = collection:load("xyz"):expect()

		assert(document:read().foo == "existing", "")
	end)

	x.test("freezes document data", function(context)
		local collection = context.lapis.createCollection("collection", {
			defaultData = {},
		})

		context.write("collection", "document", { a = { b = 1 } })

		local document = collection:load("document"):expect()

		shouldThrow(function()
			document:read().a.b = 2
		end)

		document:write({ a = { b = 2 } })

		shouldThrow(function()
			document:read().a.b = 3
		end)
	end)

	x.test("doesn't save data when the lock was stolen", function(context)
		local collection = context.lapis.createCollection("hi", defaultOptions())

		local document = collection:load("hi"):expect()

		context.write("hi", "hi", {
			foo = "stolen",
		}, "stolenLockId")

		document:write({
			foo = "qux",
		})

		shouldThrow(function()
			document:save():expect()
		end, "The session lock was stolen")

		assert(context.read("hi", "hi").data.foo == "stolen", "")

		shouldThrow(function()
			document:close():expect()
		end, "The session lock was stolen")

		assert(context.read("hi", "hi").data.foo == "stolen", "")
	end)

	x.test("doesn't throw when the budget is exhausted", function(context)
		-- This makes sure the test doesn't pass by retyring after budget is added.
		context.lapis.setConfig({ loadAttempts = 1 })

		local document = context.lapis.createCollection("bye", defaultOptions()):load("bye"):expect()

		context.dataStoreService.budget.budgets[Enum.DataStoreRequestType.GetAsync] = 0
		context.dataStoreService.budget.budgets[Enum.DataStoreRequestType.SetIncrementAsync] = 0
		context.dataStoreService.budget.budgets[Enum.DataStoreRequestType.UpdateAsync] = 0

		local promise = document:save()

		-- This wait is necessary so that the request is run by Throttle.
		task.wait(0.1)

		context.dataStoreService.budget:update()

		promise:expect()
	end)

	x.test(":save doesn't resolve with any value", function(context)
		local document = context.lapis.createCollection("12345", defaultOptions()):load("doc"):expect()

		local a, b = document:save():expect()

		assert(a == nil, "")
		assert(b == nil, "")
	end)

	x.test(":close doesn't resolve with any value", function(context)
		local document = context.lapis.createCollection("12345", defaultOptions()):load("doc"):expect()

		local a, b = document:close():expect()

		assert(a == nil, "")
		assert(b == nil, "")
	end)

	x.nested("Document:beforeSave", function()
		x.test("throws when yielding", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeSave(function()
				task.wait()
			end)

			shouldThrow(function()
				document:save():expect()
			end, "beforeSave callback threw error: thread is not yieldable")
		end)

		x.test("throws when setting twice", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeSave(function() end)

			shouldThrow(function()
				document:beforeSave(function() end)
			end, "Document:beforeSave can only be called once")
		end)

		x.test("throws when calling close in callback", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeSave(function()
				document:close()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeSave callback threw error")
		end)

		x.test("throws when calling save in callback", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeSave(function()
				document:save()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeSave callback threw error")
		end)

		x.test("saves new data in document:save", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeSave(function()
				document:read() -- This checks that read doesn't error in the callback.
				document:write({ foo = "new" })
			end)

			document:save():expect()

			assertEqual(context.read("collection", "document").data.foo, "new")
		end)

		x.test("saves new data in document:close", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeSave(function()
				document:write({ foo = "new" })
			end)

			document:close():expect()

			assertEqual(context.read("collection", "document").data.foo, "new")
		end)
	end)

	x.nested("Document:beforeClose", function()
		x.test("throws when yielding", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeClose(function()
				task.wait()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeClose callback threw error: thread is not yieldable")
		end)

		x.test("throws when setting twice", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeClose(function() end)

			shouldThrow(function()
				document:beforeClose(function() end)
			end, "Document:beforeClose can only be called once")
		end)

		x.test("throws when calling close in callback", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeClose(function()
				document:close()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeClose callback threw error")
		end)

		x.test("throws when calling save in callback", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeClose(function()
				document:save()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeClose callback threw error")
		end)

		x.test("closes document even if beforeClose errors", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			local promise = collection:load("document")
			local document = promise:expect()

			document:beforeClose(function()
				error("error")
			end)

			shouldThrow(function()
				document:close():expect()
			end)

			local secondPromise = collection:load("document")

			assert(secondPromise ~= promise, "collection:load should return a new promise")

			shouldThrow(function()
				document:write({ foo = "baz" })
			end, "Cannot write to a closed document")

			-- Ignore the could not acquire lock error.
			secondPromise:catch(function() end)
		end)

		x.test("saves new data", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			document:beforeClose(function()
				document:read() -- This checks that read doesn't error in the callback.

				document:write({ foo = "new" })
			end)

			document:close():expect()

			assertEqual(context.read("collection", "document").data.foo, "new")
		end)

		x.test("beforeSave runs before beforeClose", function(context)
			local document = context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()

			local order = ""

			document:beforeSave(function()
				order ..= "s"
			end)

			document:beforeClose(function()
				order ..= "c"
			end)

			document:close():expect()

			assertEqual(order, "sc")
		end)

		x.nested("keyInfo", function()
			x.test("gets load key info", function(context)
				local collection = context.lapis.createCollection("collection", defaultOptions())

				local before = context.getKeyInfo("collection", "document")
				local document = collection:load("document"):expect()
				local keyInfo = document:keyInfo()

				assert(before ~= keyInfo, "")
				assert(typeof(keyInfo) == "table", "")
				assert(keyInfo.Version == "0", "")
			end)

			x.test("updating user ids shouldn't affect key info", function(context)
				local collection = context.lapis.createCollection("collection", defaultOptions())

				local document = collection:load("document"):expect()
				local keyInfo = document:keyInfo()

				document:addUserId(123)

				assertEqual(#keyInfo:GetUserIds(), 0)
			end)

			x.test("key info is updated after :save", function(context)
				local document =
					context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()
				local keyInfo = document:keyInfo()

				document:save():expect()

				local newKeyInfo = document:keyInfo()

				assert(keyInfo ~= newKeyInfo, "")
				assert(newKeyInfo.Version == "1", "")
			end)

			x.test("key info is updated after :close", function(context)
				local document =
					context.lapis.createCollection("collection", defaultOptions()):load("document"):expect()
				local keyInfo = document:keyInfo()

				document:close():expect()

				local newKeyInfo = document:keyInfo()

				assert(keyInfo ~= newKeyInfo, "")
				assert(newKeyInfo.Version == "1", "")
			end)
		end)
	end)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="115">
              <Properties>
                <string name="Name">Error</string>
                <string name="Source"><![CDATA[type ErrorKind =
	"RobloxApiError"
	| "DefaultDataThrew"
	| "SessionLocked"
	| "MigrationError"
	| "BeforeSaveCloseCallbackThrew"
	| "DocumentRemoved"
	| "SessionLockStolen"
	| "ValidateThrew"
	| "ValidateFailed"

local Error = {}

function Error.new(kind: ErrorKind, message: string)
	return {
		kind = kind,
		message = message,
	}
end

return Error
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="116">
              <Properties>
                <string name="Name">Internal</string>
                <string name="Source"><![CDATA[local AutoSave = require(script.Parent.AutoSave)
local Collection = require(script.Parent.Collection)
local Config = require(script.Parent.Config)
local Data = require(script.Parent.Data)

local Internal = {}

function Internal.new(enableAutoSave)
	local config = Config.new()
	local data = Data.new(config)
	local autoSave = AutoSave.new(data)

	if enableAutoSave then
		autoSave:start()
	end

	local usedCollections = {}

	local internal = {}

	if not enableAutoSave then
		-- This exposes AutoSave to unit tests.
		internal.autoSave = autoSave
	end

	function internal.setConfig(values)
		config:set(values)
	end

	function internal.createCollection(name, options)
		if usedCollections[name] then
			error(`Collection "{name}" already exists`)
		end

		usedCollections[name] = true

		return Collection.new(name, options, data, autoSave, config)
	end

	return internal
end

return Internal
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="117">
              <Properties>
                <string name="Name">Migration</string>
                <string name="Source"><![CDATA[local Migration = {}

function Migration.getLastCompatibleVersion(migrations)
	local serverVersion = #migrations

	for version = serverVersion, 1, -1 do
		local migration = migrations[version]

		if migration.backwardsCompatible ~= true then
			return version
		end
	end

	return 0
end

function Migration.migrate(migrations, value, key)
	local serverVersion = #migrations
	local savedVersion = value.migrationVersion

	local data = value.data
	local lastCompatibleVersion = value.lastCompatibleVersion

	if serverVersion > savedVersion then
		for version = savedVersion + 1, #migrations do
			local ok, migrated = pcall(migrations[version].migrate, data, key)
			if not ok then
				return false, `Migration {version} threw an error: {migrated}`
			end

			if migrated == nil then
				return false, `Migration {version} returned 'nil'`
			end

			data = migrated
		end

		lastCompatibleVersion = Migration.getLastCompatibleVersion(migrations)
	elseif serverVersion < savedVersion then
		-- lastCompatibleVersion will be nil for documents that existed before backwards compatibilty was added and haven't been migrated to a new version since.
		if lastCompatibleVersion == nil or serverVersion < lastCompatibleVersion then
			return false,
				`Saved migration version {savedVersion} is not backwards compatible with version {serverVersion}`
		end
	end

	return true, data, lastCompatibleVersion
end

return Migration
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="118">
              <Properties>
                <string name="Name">PromiseTypes</string>
                <string name="Source"><![CDATA[export type Status = "Started" | "Resolved" | "Rejected" | "Cancelled"

export type Promise = {
	andThen: (
		self: Promise,
		successHandler: (...any) -> ...any,
		failureHandler: ((...any) -> ...any)?
	) -> Promise,
	andThenCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> any,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, ...any),
	awaitStatus: (self: Promise) -> (Status, ...any),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> ...any,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (...any) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

export type TypedPromise<T...> = {
	andThen: (self: Promise, successHandler: (T...) -> ...any, failureHandler: ((...any) -> ...any)?) -> Promise,
	andThenCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> Promise,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, T...),
	awaitStatus: (self: Promise) -> (Status, T...),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> T...,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (T...) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

return nil
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="119">
              <Properties>
                <string name="Name">copyDeep</string>
                <string name="Source"><![CDATA[local function copyDeep(value)
	if typeof(value) ~= "table" then
		return value
	end

	local new = table.clone(value)

	for k, v in value do
		if type(v) == "table" then
			new[k] = copyDeep(v)
		end
	end

	return new
end

return copyDeep
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="120">
              <Properties>
                <string name="Name">freezeDeep</string>
                <string name="Source"><![CDATA[local function freezeDeep(value)
	if typeof(value) ~= "table" then
		return
	end

	if not table.isfrozen(value) then
		table.freeze(value)
	end

	for _, innerValue in value do
		freezeDeep(innerValue)
	end
end

return freezeDeep
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="121">
              <Properties>
                <string name="Name">init.test</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local DataStoreServiceMock = require(ReplicatedStorage.DevPackages.DataStoreServiceMock)
local Internal = require(script.Parent.Internal)
local Promise = require(script.Parent.Parent.Promise)

local function defaultOptions()
	return {
		validate = function(data)
			return typeof(data.apples) == "number", "apples should be a number"
		end,
		defaultData = {
			apples = 20,
		},
	}
end

return function(x)
	local assertEqual = x.assertEqual
	local shouldThrow = x.shouldThrow

	x.beforeEach(function(context)
		local dataStoreService = DataStoreServiceMock.manual()

		context.dataStoreService = dataStoreService

		-- We want requests to overflow the throttle queue so that they result in errors.
		dataStoreService.budget:setMaxThrottleQueueSize(0)

		context.lapis = Internal.new(false)
		context.lapis.setConfig({ dataStoreService = dataStoreService, showRetryWarnings = false })

		context.write = function(name, key, data, lockId, userIds, metadata)
			local dataStore = dataStoreService.dataStores[name]["global"]

			dataStore:write(key, {
				migrationVersion = 0,
				lockId = lockId,
				data = data,
			}, userIds, metadata)
		end

		context.read = function(name, key)
			return dataStoreService.dataStores[name]["global"].data[key]
		end

		context.expectUnlocked = function(name, key)
			local data = dataStoreService.dataStores[name]["global"].data[key]

			if data ~= nil and data.lockId ~= nil then
				error("Document is locked")
			end
		end

		context.expectLocked = function(name, key)
			local data = dataStoreService.dataStores[name]["global"].data[key]

			if data == nil or data.lockId == nil then
				error("Document is not locked")
			end
		end

		context.expectUserIds = function(name, key, targetUserIds)
			local keyInfo = dataStoreService.dataStores[name]["global"].keyInfos[key]

			local currentUserIds = if keyInfo ~= nil then keyInfo:GetUserIds() else {}

			if #currentUserIds ~= #targetUserIds then
				error("Incorrect user ids length")
			end

			for index, value in targetUserIds do
				if currentUserIds[index] ~= value then
					error("Invalid user id")
				end
			end
		end

		context.getKeyInfo = function(name, key)
			return dataStoreService.dataStores[name]["global"].keyInfos[key]
		end
	end)

	x.test("throws when setting invalid config key", function(context)
		shouldThrow(function()
			context.lapis.setConfig({
				foo = true,
			})
		end, 'Invalid config key "foo"')
	end)

	x.test("throws when creating a duplicate collection", function(context)
		context.lapis.createCollection("foo", defaultOptions())

		shouldThrow(function()
			context.lapis.createCollection("foo", defaultOptions())
		end, 'Collection "foo" already exists')
	end)

	x.test("freezes default data", function(context)
		local defaultData = { a = { b = { c = 5 } } }

		context.lapis.createCollection("baz", {
			defaultData = defaultData,
		})

		shouldThrow(function()
			defaultData.a.b.c = 8
		end)
	end)

	x.test("validates default data as a table", function(context)
		shouldThrow(function()
			context.lapis.createCollection("bar", {
				validate = function()
					return false, "data is invalid"
				end,
			})
		end, "data is invalid")
	end)

	x.test("handles default data erroring", function(context)
		local collection = context.lapis.createCollection("collection", {
			defaultData = function()
				error("foo")
			end,
		})

		shouldThrow(function()
			collection:load("document"):expect()
		end, "'defaultData' threw an error", "foo")
	end)

	x.test("validates default data as a function", function(context)
		local collection = context.lapis.createCollection("collection", {
			defaultData = function()
				return {}
			end,
			validate = function()
				return false, "foo"
			end,
		})

		shouldThrow(function()
			collection:load("document"):expect()
		end, "Invalid data:", "foo")
	end)

	x.test("default data function should set default data", function(context)
		local collection = context.lapis.createCollection("collection", {
			defaultData = function()
				return "default"
			end,
		})

		local document = collection:load("document"):expect()

		assertEqual(document:read(), "default")
	end)

	x.test("should pass key to default data", function(context)
		local key
		local collection = context.lapis.createCollection("collection", {
			defaultData = function(passed)
				key = passed
				return {}
			end,
		})

		collection:load("document"):expect()
		assertEqual(key, "document")
	end)

	x.test("default data function should deep copy data", function(context)
		local returned = { {} }
		local collection = context.lapis.createCollection("collection", {
			defaultData = function()
				return returned
			end,
		})

		local document = collection:load("document"):expect()

		assert(document:read() ~= returned, "")
		assert(document:read()[1] ~= returned[1], "")
	end)

	x.test("default data function should freeze data", function(context)
		local collection = context.lapis.createCollection("collection", {
			defaultData = function()
				return {}
			end,
		})

		local document = collection:load("document"):expect()

		shouldThrow(function()
			document:read().foo = true
		end, "readonly")
	end)

	x.test("handles validate erroring", function(context)
		local created = false

		local collection = context.lapis.createCollection("collection", {
			validate = function()
				if created then
					error("foo")
				else
					return true
				end
			end,
		})

		created = true

		context.write("collection", "document", {})

		shouldThrow(function()
			collection:load("document"):expect()
		end, "'validate' threw an error", "foo")
	end)

	x.test("should not override data if validation fails", function(context)
		local collection = context.lapis.createCollection("collection", defaultOptions())

		context.write("collection", "doc", { apples = "string" })

		local old = context.read("collection", "doc")

		shouldThrow(function()
			collection:load("doc"):expect()
		end, "apples should be a number")

		assertEqual(old, context.read("collection", "doc"))
	end)

	x.test("should session lock the document", function(context)
		local collection = context.lapis.createCollection("collection", defaultOptions())
		local document = collection:load("doc"):expect()

		local otherLapis = Internal.new(false)
		otherLapis.setConfig({ dataStoreService = context.dataStoreService, loadAttempts = 1 })

		local otherCollection = otherLapis.createCollection("collection", defaultOptions())

		shouldThrow(function()
			otherCollection:load("doc"):expect()
		end, "Could not acquire lock")

		-- It should keep the session lock when saved.
		document:save():expect()

		shouldThrow(function()
			otherCollection:load("doc"):expect()
		end, "Could not acquire lock")

		-- It should remove the session lock when closed.
		document:close():expect()

		otherCollection:load("doc"):expect()
	end)

	x.test("load should retry when document is session locked", function(context)
		local collection = context.lapis.createCollection("collection", defaultOptions())
		local document = collection:load("doc"):expect()

		local otherLapis = Internal.new(false)
		otherLapis.setConfig({
			dataStoreService = context.dataStoreService,
			loadAttempts = 4,
			loadRetryDelay = 0.5,
			showRetryWarnings = false,
		})

		local otherCollection = otherLapis.createCollection("collection", defaultOptions())
		local promise = otherCollection:load("doc")

		-- Wait for the document to attempt to load once.
		task.wait(0.1)

		-- Remove the sesssion lock.
		document:close():expect()

		promise:expect()
	end)

	x.test("second load should fail because of session lock", function(context)
		local collection = context.lapis.createCollection("collection", defaultOptions())

		context.lapis.setConfig({ loadAttempts = 1 })

		local first = collection:load("document")
		local second = collection:load("document")

		first:expect()

		shouldThrow(function()
			second:expect()
		end, "Could not acquire lock")
	end)

	x.test("load returns a new promise when first load fails", function(context)
		context.lapis.setConfig({ loadAttempts = 1 })
		context.dataStoreService.errors:addSimulatedErrors(1)

		local collection = context.lapis.createCollection("ghi", defaultOptions())

		local promise1 = collection:load("ghi")

		shouldThrow(function()
			promise1:expect()
		end)

		local promise2 = collection:load("ghi")

		assert(promise1 ~= promise2, "load should return new promise")

		promise2:expect()
	end)

	x.nested("migrations", function()
		x.test("migrates the data", function(context)
			local collection = context.lapis.createCollection("migration", {
				validate = function(value)
					return value == "newData", "value does not equal newData"
				end,
				defaultData = "newData",
				migrations = {
					function()
						return "newData"
					end,
				},
			})

			context.write("migration", "migration", "data")

			collection:load("migration"):expect()

			local readData = collection:read("migration"):expect()

			assertEqual(readData, "newData")
		end)

		x.test("error is thrown if a migration returns nil", function(context)
			local collection = context.lapis.createCollection("collection", {
				defaultData = {},
				migrations = {
					function() end,
				},
			})

			context.write("collection", "document", {})

			shouldThrow(function()
				collection:load("document"):expect()
			end, "Migration 1 returned 'nil'")

			shouldThrow(function()
				collection:read("document"):expect()
			end, "Migration 1 returned 'nil'")
		end)

		x.test("passes key to migrations", function(context)
			local passedKey
			local collection = context.lapis.createCollection("collection", {
				defaultData = "newData",
				migrations = {
					function(_, key)
						passedKey = key
						return "newData"
					end,
				},
			})

			context.write("collection", "key", "data")

			collection:read("key"):expect()
			assertEqual(passedKey, "key")
			passedKey = nil

			collection:load("key"):expect()
			assertEqual(passedKey, "key")
		end)

		x.test("migrations should allow mutable updates", function(context)
			local collection = context.lapis.createCollection("collection", {
				validate = function(value)
					return typeof(value.coins) == "number"
				end,
				defaultData = { coins = 0 },
				migrations = {
					function(old)
						old.coins = 0

						return old
					end,
					function(old)
						old.coins = 100

						return old
					end,
				},
			})

			context.write("collection", "document", {})

			local document = collection:load("document"):expect()

			assertEqual(document:read().coins, 100)
		end)

		x.test("data should be frozen after a migration", function(context)
			local collection = context.lapis.createCollection("collection", {
				validate = function(value)
					return typeof(value.coins) == "number"
				end,
				defaultData = { coins = 0 },
				migrations = {
					function(old)
						old.coins = 0
						return old
					end,
				},
			})

			context.write("collection", "document", {})

			local document = collection:load("document"):expect()

			shouldThrow(function()
				document:read().coins = 100
			end, "readonly")
		end)

		x.test("migrations should work with tables and functions", function(context)
			local collection = context.lapis.createCollection("collection", {
				defaultData = "a",
				migrations = {
					{
						backwardsCompatible = false,
						migrate = function(old)
							return old
						end,
					},
					function(old)
						return old
					end,
				},
			})

			local dataStore = context.dataStoreService.dataStores.collection.global
			dataStore:write("document", {
				migrationVersion = 0,
				data = "a",
			})

			collection:load("document"):expect()
		end)

		x.nested("saved version ahead", function()
			x.test(
				"throws when migration version is ahead of latest version and is not backwards compatible",
				function(context)
					local collection = context.lapis.createCollection("collection", {
						defaultData = "a",
						migrations = {
							function(old)
								return old
							end,
						},
					})

					local dataStore = context.dataStoreService.dataStores.collection.global
					dataStore:write("document", {
						migrationVersion = 2,
						data = "b",
					})

					shouldThrow(function()
						collection:load("document"):expect()
					end, "Saved migration version 2 is not backwards compatible with version 1")

					shouldThrow(function()
						collection:read("document"):expect()
					end, "Saved migration version 2 is not backwards compatible with version 1")
				end
			)

			x.test("default data gets lastCompatibleVersion", function(context)
				local migrate = function(old)
					return old
				end

				local collection = context.lapis.createCollection("collection", {
					defaultData = "a",
					migrations = {
						{ migrate = migrate, backwardsCompatible = true },
					},
				})

				collection:load("document"):expect():close():expect()

				local otherLapis = Internal.new(false)
				otherLapis.setConfig({ dataStoreService = context.dataStoreService, loadAttempts = 1 })

				local otherCollection = otherLapis.createCollection("collection", {
					defaultData = "a",
				})

				-- This would error if lastCompatibleVersion = 0 wasn't saved.
				otherCollection:load("document"):expect()
			end)

			x.test("handles lastCompatibleVersion == nil", function(context)
				local collection = context.lapis.createCollection("collection", {
					defaultData = "a",
				})

				local dataStore = context.dataStoreService.dataStores.collection.global
				dataStore:write("document", {
					migrationVersion = 1,
					data = "b",
				})

				shouldThrow(function()
					collection:load("document"):expect()
				end, "Saved migration version 1 is not backwards compatible with version 0")

				shouldThrow(function()
					collection:read("document"):expect()
				end, "Saved migration version 1 is not backwards compatible with version 0")
			end)

			x.test("migration saves lastCompatibleVersion", function(context)
				local function migrate(old)
					return old
				end

				local collection = context.lapis.createCollection("collection", {
					defaultData = "a",
					migrations = {
						{ migrate = migrate, backwardsCompatible = false },
						{ migrate = migrate, backwardsCompatible = true },
						{ migrate = migrate, backwardsCompatible = true },
					},
				})

				local dataStore = context.dataStoreService.dataStores.collection.global
				dataStore:write("document", {
					migrationVersion = 0,
					data = "b",
				})

				collection:load("document"):expect():close():expect()

				local lapisWithV0 = Internal.new(false)
				lapisWithV0.setConfig({ dataStoreService = context.dataStoreService, loadAttempts = 1 })

				local collectionWithV0 = lapisWithV0.createCollection("collection", {
					defaultData = "a",
				})

				shouldThrow(function()
					collectionWithV0:load("document"):expect()
				end, "Saved migration version 3 is not backwards compatible with version 0")

				local lapisWithV1 = Internal.new(false)
				lapisWithV1.setConfig({ dataStoreService = context.dataStoreService, loadAttempts = 1 })

				local collectionWithV1 = lapisWithV1.createCollection("collection", {
					defaultData = "a",
					migrations = {
						{ migrate = migrate, backwardsCompatible = false },
						{ migrate = migrate, backwardsCompatible = true },
					},
				})

				-- This shouldn't error because v3 is backwards compatible with v1.
				collectionWithV1:load("document"):expect()
			end)

			x.test("keeps saved version", function(context)
				local collection = context.lapis.createCollection("collection", {
					defaultData = "a",
				})

				local dataStore = context.dataStoreService.dataStores.collection.global
				dataStore:write("document", {
					lastCompatibleVersion = 0,
					migrationVersion = 1,
					data = "b",
				})

				local document = collection:load("document"):expect()

				assertEqual(context.read("collection", "document").migrationVersion, 1)

				document:save("document"):expect()

				assertEqual(context.read("collection", "document").migrationVersion, 1)

				document:close("document"):expect()

				assertEqual(context.read("collection", "document").migrationVersion, 1)
			end)
		end)
	end)

	x.test("closing and immediately opening should return a new document", function(context)
		local collection = context.lapis.createCollection("ccc", defaultOptions())

		local document = collection:load("doc"):expect()

		local close = document:close()
		local open = collection:load("doc")

		close:expect()

		local newDocument = open:expect()

		assert(newDocument ~= document, "")
	end)

	x.test("closes all document on game:BindToClose", function(context)
		local collection = context.lapis.createCollection("collection", defaultOptions())

		local one = collection:load("one"):expect()
		local two = collection:load("two"):expect()
		local three = collection:load("three"):expect()

		context.dataStoreService.yield:startYield()

		local thread = task.spawn(function()
			context.lapis.autoSave:onGameClose()
		end)

		assert(coroutine.status(thread) == "suspended", "onGameClose didn't wait for the documents to finish closing")

		-- Verify each document has been closed.
		for _, document in { one, two, three } do
			shouldThrow(function()
				document:save():expect()
			end, "Cannot save a closed document")
		end

		context.dataStoreService.yield:stopYield()

		-- Wait for documents to finish saving.
		task.wait(0.1)

		assert(coroutine.status(thread) == "dead", "")
	end)

	x.nested("user ids", function()
		x.test("it uses defaultUserIds on first load", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			local document = collection:load("document", { 123 }):expect()
			context.expectUserIds("collection", "document", { 123 })
			document:close():expect()
			context.expectUserIds("collection", "document", { 123 })

			-- Since the document has already been created, the defaultUserIds should not override the saved ones.
			document = collection:load("document", { 321 }):expect()
			context.expectUserIds("collection", "document", { 123 })
			document:close():expect()
			context.expectUserIds("collection", "document", { 123 })
		end)

		x.test("adds new user ids", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			local document = collection:load("document", {}):expect()

			document:addUserId(111)
			document:addUserId(111) -- It should not add this user id twice.
			document:addUserId(222)

			context.expectUserIds("collection", "document", {})

			document:save():expect()

			context.expectUserIds("collection", "document", { 111, 222 })

			document:close():expect()

			context.expectUserIds("collection", "document", { 111, 222 })
		end)

		x.test("removes new user ids", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			local document = collection:load("document", { 333, 444, 555 }):expect()

			document:removeUserId(111) -- It should do nothing if the user id doesn't exist.
			document:removeUserId(444)

			context.expectUserIds("collection", "document", { 333, 444, 555 })

			document:save():expect()

			context.expectUserIds("collection", "document", { 333, 555 })

			document:close():expect()

			context.expectUserIds("collection", "document", { 333, 555 })
		end)
	end)

	x.nested("load during BindToClose", function()
		x.test("load infinitely yields after BindToClose", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			task.spawn(function()
				context.lapis.autoSave:onGameClose()
			end)

			shouldThrow(function()
				collection:load("document"):timeout(0.5):expect()
			end, "Timed out")
		end)

		x.test("load just before BindToClose", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			context.dataStoreService.yield:startYield()

			collection:load("document")

			local waited = false
			local finished = false
			local thread = task.spawn(function()
				RunService.PostSimulation:Wait()
				RunService.PostSimulation:Wait()
				waited = true
				context.lapis.autoSave:onGameClose()
				finished = true
			end)

			while not waited do
				task.wait()
			end

			context.dataStoreService.yield:stopYield()

			context.dataStoreService.yield:startYield()
			assert(
				coroutine.status(thread) == "suspended",
				"onGameClose didn't wait for the documents to finish closing"
			)
			context.dataStoreService.yield:stopYield()

			while not finished do
				task.wait()
			end

			context.expectUnlocked("collection", "document")

			assert(coroutine.status(thread) == "dead", "")
		end)

		x.test("BindToClose should finish if a document fails to load", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			context.write("collection", "document", "INVALID DATA")
			collection:load("document"):catch(function() end)

			-- Wait to close game so that the save request doesn't get cancelled.
			task.wait(0.1)

			Promise.try(function()
				context.lapis.autoSave:onGameClose()
			end)
				:timeout(1)
				:expect()
		end)
	end)

	x.nested("freezeData = false", function()
		x.test("default data should be deep copied", function(context)
			local defaultData = { foo = {} }

			local collection = context.lapis.createCollection("collection", {
				freezeData = false,
				defaultData = defaultData,
			})

			local document = collection:load("document"):expect()
			local data = document:read()

			assert(data ~= defaultData, "")
			assert(data.foo ~= defaultData.foo, "")
			assert(typeof(data.foo) == "table", "")
		end)

		x.test("data should not be frozen", function(context)
			local collection = context.lapis.createCollection("collection", {
				freezeData = false,
				defaultData = {},
			})
			local document = collection:load("document"):expect()

			-- This would error if the data was frozen.
			document:read().apples = 1

			-- Make sure write doesn't freeze the data.
			document:write(document:read())
			document:read().apples = 1
		end)

		x.test("should validate data in save and close", function(context)
			local valid = true
			local collection = context.lapis.createCollection("collection", {
				freezeData = false,
				validate = function()
					return valid, "data is invalid"
				end,
				defaultData = {},
			})

			local document = collection:load("document"):expect()

			valid = false

			shouldThrow(function()
				document:save():expect()
			end, "data is invalid")

			shouldThrow(function()
				document:close():expect()
			end, "data is invalid")
		end)

		x.test("should handle validate errors data in save and close", function(context)
			local throwError = false
			local collection = context.lapis.createCollection("collection", {
				freezeData = false,
				validate = function()
					if throwError then
						error("foo")
					end

					return true
				end,
				defaultData = {},
			})

			local document = collection:load("document"):expect()

			throwError = true

			shouldThrow(function()
				document:save():expect()
			end, "'validate' threw an error", "foo")

			shouldThrow(function()
				document:close():expect()
			end, "'validate' threw an error", "foo")
		end)
	end)

	x.nested("Collection:read", function()
		x.test("returns nil when there is no data", function(context)
			local collection = context.lapis.createCollection("collection", {
				defaultData = "data",
			})

			local data, keyInfo = collection:read("key"):expect()

			assertEqual(data, nil)
			assertEqual(keyInfo, nil)
		end)

		x.test("returns existing data", function(context)
			local collection = context.lapis.createCollection("collection", {
				defaultData = "data",
			})

			collection:load("key", { 321 }):expect()

			local data, keyInfo = collection:read("key"):expect()

			assertEqual(data, "data")
			assertEqual(keyInfo:GetUserIds()[1], 321)
		end)

		x.test("throws error when data is invalid", function(context)
			local collection = context.lapis.createCollection("collection", {
				defaultData = "data",
				validate = function(data)
					return data == "data", "data was invalid"
				end,
			})

			context.write("collection", "key", "INVALID DATA")

			shouldThrow(function()
				collection:read("key"):expect()
			end, "Invalid data")
		end)

		x.test("throws error when validate throws", function(context)
			local created = false
			local collection = context.lapis.createCollection("collection", {
				defaultData = "data",
				validate = function()
					if created then
						error("validate error")
					else
						return true
					end
				end,
			})
			created = true

			context.write("collection", "key", "data")

			shouldThrow(function()
				collection:read("key"):expect()
			end, "'validate' threw an error")
		end)
	end)

	x.nested("Collection:remove", function()
		x.test("should remove data", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			collection:load("document"):expect():close():expect()

			collection:remove("document"):expect()

			assertEqual(context.read("collection", "document"), nil)
		end)

		x.test("documents open during remove should fail to save/close", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			local document = collection:load("document"):expect()

			collection:remove("document"):expect()

			shouldThrow(function()
				document:save():expect()
			end, "The document was removed")

			shouldThrow(function()
				document:close():expect()
			end, "The document was removed")
		end)
	end)

	x.nested("Document:close should still unlock after specific errors", function()
		x.test("shouldn't overwrite stolen lock", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())
			local document = collection:load("document"):expect()

			context.write("collection", "document", { apples = 20 }, "stolen lock")

			document:beforeSave(function()
				error("oh no")
			end)

			shouldThrow(function()
				document:close("document"):expect()
			end)

			task.wait(0.1)

			context.expectLocked("collection", "document")
		end)

		x.test("doesn't work for session lock stolen error", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())
			local document = collection:load("document"):expect()

			context.write("collection", "document", { apples = 20 }, "another lock id")

			document:write({ apples = 100 })

			shouldThrow(function()
				document:close("document"):expect()
			end)

			task.wait(0.1)

			context.expectLocked("collection", "document")
			assertEqual(context.read("collection", "document").data.apples, 20) -- Only the lock should have changed.
		end)

		x.test("beforeSave error", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			local document = collection:load("document"):expect()

			document:write({ apples = 100 })

			document:beforeSave(function()
				error("oh no")
			end)

			shouldThrow(function()
				document:close("document"):expect()
			end)

			task.wait(0.1)

			context.expectUnlocked("collection", "document")
			assertEqual(context.read("collection", "document").data.apples, 20) -- Only the lock should have changed.
		end)

		x.test("beforeClose error", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())

			local document = collection:load("document"):expect()

			document:write({ apples = 100 })

			document:beforeClose(function()
				error("oh no")
			end)

			shouldThrow(function()
				document:close("document"):expect()
			end)

			task.wait(0.1)

			context.expectUnlocked("collection", "document")
			assertEqual(context.read("collection", "document").data.apples, 20) -- Only the lock should have changed.
		end)

		x.test("validate error", function(context)
			local collection = context.lapis.createCollection("collection", {
				validate = function(data)
					return typeof(data.apples) == "number", "apples should be a number"
				end,
				defaultData = { apples = 20 },
				freezeData = false,
			})

			local document = collection:load("document"):expect()

			document:read().apples = nil

			shouldThrow(function()
				document:close("document"):expect()
			end)

			task.wait(0.1)

			context.expectUnlocked("collection", "document")
			assertEqual(context.read("collection", "document").data.apples, 20) -- Only the lock should have changed.
		end)

		x.test("validate threw error", function(context)
			local loaded = false
			local collection = context.lapis.createCollection("collection", {
				validate = function()
					if loaded then
						error("oh no")
					end
					return true
				end,
				defaultData = { apples = 20 },
				freezeData = false,
			})

			local document = collection:load("document"):expect()

			loaded = true

			shouldThrow(function()
				document:close("document"):expect()
			end)

			task.wait(0.1)

			context.expectUnlocked("collection", "document")
			assertEqual(context.read("collection", "document").data.apples, 20) -- Only the lock should have changed.
		end)

		x.test("onGameClose should wait for the lock to remove", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())
			local document = collection:load("document"):expect()

			document:beforeSave(function()
				error("oh no")
			end)

			context.dataStoreService.yield:startYield()

			shouldThrow(function()
				document:close("document"):expect()
			end)

			local thread = task.spawn(function()
				context.lapis.autoSave:onGameClose()
			end)

			assert(coroutine.status(thread) == "suspended", "onGameClose didn't wait for locks to be removed")

			context.dataStoreService.yield:stopYield()

			-- Wait for locks to be removed.
			task.wait(0.1)

			assert(coroutine.status(thread) == "dead", "")
		end)

		x.test("should preserve userids/metadata", function(context)
			local collection = context.lapis.createCollection("collection", defaultOptions())
			local document = collection:load("document"):expect()

			document:beforeSave(function()
				error("oh no")
			end)

			context.write(
				"collection",
				"document",
				document:read(),
				context.read("collection", "document").lockId,
				{ 1234 },
				{ foo = "bar" }
			)

			shouldThrow(function()
				document:close("document"):expect()
			end)

			task.wait(0.1)

			local keyInfo = context.getKeyInfo("collection", "document")

			assertEqual(keyInfo:GetUserIds()[1], 1234)
			assertEqual(keyInfo:GetMetadata().foo, "bar")
		end)
	end)

	x.test("preserves metadata", function(context)
		local collection = context.lapis.createCollection("collection", defaultOptions())

		context.write("collection", "document", { apples = 30 }, nil, nil, { foo = "bar" })

		local function verifyMetadata()
			local keyInfo = context.getKeyInfo("collection", "document")
			assertEqual(keyInfo:GetMetadata().foo, "bar")
		end

		local document = collection:load("document"):expect()
		verifyMetadata()

		document:save():expect()
		verifyMetadata()

		document:close():expect()
		verifyMetadata()
	end)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="122">
              <Properties>
                <string name="Name">noYield</string>
                <string name="Source"><![CDATA[local function noYield(callback)
	for _ in
		function()
			callback()
		end
	do
		break
	end
end

return noYield
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="123">
          <Properties>
            <string name="Name">osyrisrblx_t@3.1.1</string>
          </Properties>
          <Item class="ModuleScript" referent="124">
            <Properties>
              <string name="Name">t</string>
              <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false, "unexpected non-NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end

	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end

		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)
		if not stringSuccess then
			return false, stringErrMsg
		end

		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])
				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false, "bad type for union"
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)
			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])
				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

return t
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="125">
        <Properties>
          <string name="Name">lapis</string>
          <string name="Source">local module = require(script.Parent[".pesde"]["nezuo_lapis@0.3.4"]["lapis"])
export type DataStoreService  = module.DataStoreService 
export type PartialLapisConfig  = module.PartialLapisConfig 
export type CollectionOptions&lt;T> = module.CollectionOptions&lt;T>
export type Collection&lt;T> = module.Collection&lt;T>
export type Document&lt;T> = module.Document&lt;T>
return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="126">
        <Properties>
          <string name="Name">reflex</string>
          <string name="Source">local module = require(script.Parent[".pesde"]["littensy_reflex@4.3.1"]["reflex"])
export type Broadcaster  = module.Broadcaster 
export type BroadcastAction  = module.BroadcastAction 
export type BroadcasterOptions  = module.BroadcasterOptions 
export type BroadcastReceiver  = module.BroadcastReceiver 
export type BroadcastReceiverOptions  = module.BroadcastReceiverOptions 
export type Producer&lt;State = any, Dispatchers = { [string]: (...any) -> State }> = module.Producer&lt;State , Dispatchers >
export type Middleware  = module.Middleware 
return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="127">
        <Properties>
          <string name="Name">remo</string>
          <string name="Source">local module = require(script.Parent[".pesde"]["littensy_remo@1.5.2"]["remo"])
export type Promise&lt;T> = module.Promise&lt;T>
export type PromiseConstructor  = module.PromiseConstructor 
export type Middleware  = module.Middleware 
export type RemoteBuilder  = module.RemoteBuilder 
export type RemoteBuilderMetadata  = module.RemoteBuilderMetadata 
export type RemoteBuilders  = module.RemoteBuilders 
export type Remotes&lt;Map> = module.Remotes&lt;Map>
export type RemoteMap  = module.RemoteMap 
export type RemoteType  = module.RemoteType 
export type Remote&lt;Args... = ...any> = module.Remote&lt;Args... >
export type ClientToServer&lt;Args... = ...any> = module.ClientToServer&lt;Args... >
export type ServerToClient&lt;Args... = ...any> = module.ServerToClient&lt;Args... >
export type AsyncRemote&lt;Args... = ...any, Returns... = ...any> = module.AsyncRemote&lt;Args... , Returns... >
export type ServerAsync&lt;Args... = ...any, Returns... = ...any> = module.ServerAsync&lt;Args... , Returns... >
export type ClientAsync&lt;Args... = ...any, Returns... = ...any> = module.ClientAsync&lt;Args... , Returns... >
export type ClientToServerAsync&lt;Returns = any, Args... = ...any> = module.ClientToServerAsync&lt;Returns , Args... >
export type ServerToClientAsync&lt;Returns = any, Args... = ...any> = module.ServerToClientAsync&lt;Returns , Args... >
return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="128">
        <Properties>
          <string name="Name">t</string>
          <string name="Source">local module = require(script.Parent[".pesde"]["osyrisrblx_t@3.1.1"]["t"])
return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="129">
        <Properties>
          <string name="Name">vide</string>
          <string name="Source">local module = require(script.Parent[".pesde"]["centau_vide@0.3.1"]["vide"])
export type Source&lt;T> = module.Source&lt;T>
export type source&lt;T> = module.source&lt;T>
export type Context&lt;T> = module.Context&lt;T>
export type context&lt;T> = module.context&lt;T>
return module</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="130">
      <Properties>
        <string name="Name">shared</string>
      </Properties>
      <Item class="ModuleScript" referent="131">
        <Properties>
          <string name="Name">Hello</string>
          <string name="Source">return function()
	print("Hello, world!")
end</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="132">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="133">
      <Properties>
        <string name="Name">server</string>
        <token name="RunContext">1</token>
        <string name="Source">print("Hello world, from server!")</string>
      </Properties>
    </Item>
  </Item>
</roblox>